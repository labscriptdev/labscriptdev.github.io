import{g as Jt,h as Ie,i as yt,j as es,k as ue,l as At,m as J,n as q,o as ts,p as ss,D as ns,M as ne,q as de,r as H,f as v,a as $,V as L,I as is,s as os,O as Tt,t as rs,u as as,v as he,w as cs,x as bt,y as wt,z as Oe,A as xt,E as Ee,G as Ne,H as Ve,J as Et,K as ls,c as Be,N as us,d as St,Q as Rt,U as Mt,X as hs,Y as Lt,Z as Se,P as _t,_ as ve,$ as ds,a0 as ms,a1 as ps,a2 as fs,a3 as Ct,a4 as $e,a5 as K,a6 as gs,a7 as ys,a8 as As,a9 as Ts,aa as bs,ab as ws,ac as xs,ad as Es,ae as Ss,af as Je,ag as et,ah as tt,ai as st,B as Dt,aj as Rs,ak as Ms,al as It,am as Ls,an as _s,ao as Cs,ap as Ds,aq as Is,ar as Os,as as ks,at as Ps,au as Ns,av as Vs,aw as Bs,ax as vs,b as Fs,ay as Hs,az as te,aA as se,aB as nt,aC as Ot,aD as it,R as Us,S as Gs,C as zs,W as js,aE as Ks,aF as Ws}from"./three.module.6da1ccc8.js";import{l as fe,E as ge,a as Xs,C as Ys,b as qs,A as Qs,c as Re,d as Zs,e as $s,f as Js,i as en}from"./matter.0784338f.js";import{l as tn,f as ot,n as sn,E as nn,o as on,e as rn,a as ye,x as Me,y as rt,g as at,d as an,t as cn}from"./entry.0189ed9e.js";function ct(m,t){if(t===Jt)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),m;if(t===Ie||t===yt){let s=m.getIndex();if(s===null){const o=[],a=m.getAttribute("position");if(a!==void 0){for(let r=0;r<a.count;r++)o.push(r);m.setIndex(o),s=m.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),m}const e=s.count-2,n=[];if(t===Ie)for(let o=1;o<=e;o++)n.push(s.getX(0)),n.push(s.getX(o)),n.push(s.getX(o+1));else for(let o=0;o<e;o++)o%2===0?(n.push(s.getX(o)),n.push(s.getX(o+1)),n.push(s.getX(o+2))):(n.push(s.getX(o+2)),n.push(s.getX(o+1)),n.push(s.getX(o)));n.length/3!==e&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=m.clone();return i.setIndex(n),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),m}class ln extends es{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(s){return new pn(s)}),this.register(function(s){return new En(s)}),this.register(function(s){return new Sn(s)}),this.register(function(s){return new Rn(s)}),this.register(function(s){return new gn(s)}),this.register(function(s){return new yn(s)}),this.register(function(s){return new An(s)}),this.register(function(s){return new Tn(s)}),this.register(function(s){return new mn(s)}),this.register(function(s){return new bn(s)}),this.register(function(s){return new fn(s)}),this.register(function(s){return new xn(s)}),this.register(function(s){return new wn(s)}),this.register(function(s){return new hn(s)}),this.register(function(s){return new Mn(s)}),this.register(function(s){return new Ln(s)})}load(t,s,e,n){const i=this;let o;if(this.resourcePath!=="")o=this.resourcePath;else if(this.path!==""){const c=ue.extractUrlBase(t);o=ue.resolveURL(c,this.path)}else o=ue.extractUrlBase(t);this.manager.itemStart(t);const a=function(c){n?n(c):console.error(c),i.manager.itemError(t),i.manager.itemEnd(t)},r=new At(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,function(c){try{i.parse(c,o,function(u){s(u),i.manager.itemEnd(t)},a)}catch(u){a(u)}},e,a)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,s,e,n){let i;const o={},a={},r=new TextDecoder;if(typeof t=="string")i=JSON.parse(t);else if(t instanceof ArrayBuffer)if(r.decode(new Uint8Array(t,0,4))===kt){try{o[S.KHR_BINARY_GLTF]=new _n(t)}catch(l){n&&n(l);return}i=JSON.parse(o[S.KHR_BINARY_GLTF].content)}else i=JSON.parse(r.decode(t));else i=t;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Un(i,{path:s||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const l=this.pluginCallbacks[u](c);l.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[l.name]=l,o[l.name]=!0}if(i.extensionsUsed)for(let u=0;u<i.extensionsUsed.length;++u){const l=i.extensionsUsed[u],d=i.extensionsRequired||[];switch(l){case S.KHR_MATERIALS_UNLIT:o[l]=new dn;break;case S.KHR_DRACO_MESH_COMPRESSION:o[l]=new Cn(i,this.dracoLoader);break;case S.KHR_TEXTURE_TRANSFORM:o[l]=new Dn;break;case S.KHR_MESH_QUANTIZATION:o[l]=new In;break;default:d.indexOf(l)>=0&&a[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(o),c.setPlugins(a),c.parse(e,n)}parseAsync(t,s){const e=this;return new Promise(function(n,i){e.parse(t,s,n,i)})}}function un(){let m={};return{get:function(t){return m[t]},add:function(t,s){m[t]=s},remove:function(t){delete m[t]},removeAll:function(){m={}}}}const S={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class hn{constructor(t){this.parser=t,this.name=S.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,s=this.parser.json.nodes||[];for(let e=0,n=s.length;e<n;e++){const i=s[e];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(t){const s=this.parser,e="light:"+t;let n=s.cache.get(e);if(n)return n;const i=s.json,r=((i.extensions&&i.extensions[this.name]||{}).lights||[])[t];let c;const u=new J(16777215);r.color!==void 0&&u.setRGB(r.color[0],r.color[1],r.color[2],q);const l=r.range!==void 0?r.range:0;switch(r.type){case"directional":c=new ns(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new ss(u),c.distance=l;break;case"spot":c=new ts(u),c.distance=l,r.spot=r.spot||{},r.spot.innerConeAngle=r.spot.innerConeAngle!==void 0?r.spot.innerConeAngle:0,r.spot.outerConeAngle=r.spot.outerConeAngle!==void 0?r.spot.outerConeAngle:Math.PI/4,c.angle=r.spot.outerConeAngle,c.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return c.position.set(0,0,0),c.decay=2,Y(c,r),r.intensity!==void 0&&(c.intensity=r.intensity),c.name=s.createUniqueName(r.name||"light_"+t),n=Promise.resolve(c),s.cache.add(e,n),n}getDependency(t,s){if(t==="light")return this._loadLight(s)}createNodeAttachment(t){const s=this,e=this.parser,i=e.json.nodes[t],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(r){return e._getNodeRef(s.cache,a,r)})}}class dn{constructor(){this.name=S.KHR_MATERIALS_UNLIT}getMaterialType(){return ne}extendParams(t,s,e){const n=[];t.color=new J(1,1,1),t.opacity=1;const i=s.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;t.color.setRGB(o[0],o[1],o[2],q),t.opacity=o[3]}i.baseColorTexture!==void 0&&n.push(e.assignTexture(t,"map",i.baseColorTexture,de))}return Promise.all(n)}}class mn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,s){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(s.emissiveIntensity=i),Promise.resolve()}}class pn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];if(o.clearcoatFactor!==void 0&&(s.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(e.assignTexture(s,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(s.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(e.assignTexture(s,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(e.assignTexture(s,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;s.clearcoatNormalScale=new v(a,a)}return Promise.all(i)}}class fn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.iridescenceFactor!==void 0&&(s.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&i.push(e.assignTexture(s,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(s.iridescenceIOR=o.iridescenceIor),s.iridescenceThicknessRange===void 0&&(s.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(s.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(s.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&i.push(e.assignTexture(s,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(i)}}class gn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];s.sheenColor=new J(0,0,0),s.sheenRoughness=0,s.sheen=1;const o=n.extensions[this.name];if(o.sheenColorFactor!==void 0){const a=o.sheenColorFactor;s.sheenColor.setRGB(a[0],a[1],a[2],q)}return o.sheenRoughnessFactor!==void 0&&(s.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&i.push(e.assignTexture(s,"sheenColorMap",o.sheenColorTexture,de)),o.sheenRoughnessTexture!==void 0&&i.push(e.assignTexture(s,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(i)}}class yn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.transmissionFactor!==void 0&&(s.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(e.assignTexture(s,"transmissionMap",o.transmissionTexture)),Promise.all(i)}}class An{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];s.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(e.assignTexture(s,"thicknessMap",o.thicknessTexture)),s.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return s.attenuationColor=new J().setRGB(a[0],a[1],a[2],q),Promise.all(i)}}class Tn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return s.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class bn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];s.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&i.push(e.assignTexture(s,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return s.specularColor=new J().setRGB(a[0],a[1],a[2],q),o.specularColorTexture!==void 0&&i.push(e.assignTexture(s,"specularColorMap",o.specularColorTexture,de)),Promise.all(i)}}class wn{constructor(t){this.parser=t,this.name=S.EXT_MATERIALS_BUMP}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return s.bumpScale=o.bumpFactor!==void 0?o.bumpFactor:1,o.bumpTexture!==void 0&&i.push(e.assignTexture(s,"bumpMap",o.bumpTexture)),Promise.all(i)}}class xn{constructor(t){this.parser=t,this.name=S.KHR_MATERIALS_ANISOTROPY}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:H}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.anisotropyStrength!==void 0&&(s.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(s.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&i.push(e.assignTexture(s,"anisotropyMap",o.anisotropyTexture)),Promise.all(i)}}class En{constructor(t){this.parser=t,this.name=S.KHR_TEXTURE_BASISU}loadTexture(t){const s=this.parser,e=s.json,n=e.textures[t];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],o=s.options.ktx2Loader;if(!o){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return s.loadTextureImage(t,i.source,o)}}class Sn{constructor(t){this.parser=t,this.name=S.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const s=this.name,e=this.parser,n=e.json,i=n.textures[t];if(!i.extensions||!i.extensions[s])return null;const o=i.extensions[s],a=n.images[o.source];let r=e.textureLoader;if(a.uri){const c=e.options.manager.getHandler(a.uri);c!==null&&(r=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,o.source,r);if(n.extensionsRequired&&n.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const s=new Image;s.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",s.onload=s.onerror=function(){t(s.height===1)}})),this.isSupported}}class Rn{constructor(t){this.parser=t,this.name=S.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(t){const s=this.name,e=this.parser,n=e.json,i=n.textures[t];if(!i.extensions||!i.extensions[s])return null;const o=i.extensions[s],a=n.images[o.source];let r=e.textureLoader;if(a.uri){const c=e.options.manager.getHandler(a.uri);c!==null&&(r=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,o.source,r);if(n.extensionsRequired&&n.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const s=new Image;s.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",s.onload=s.onerror=function(){t(s.height===1)}})),this.isSupported}}class Mn{constructor(t){this.name=S.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const s=this.parser.json,e=s.bufferViews[t];if(e.extensions&&e.extensions[this.name]){const n=e.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(a){const r=n.byteOffset||0,c=n.byteLength||0,u=n.count,l=n.byteStride,d=new Uint8Array(a,r,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(u,l,d,n.mode,n.filter).then(function(p){return p.buffer}):o.ready.then(function(){const p=new ArrayBuffer(u*l);return o.decodeGltfBuffer(new Uint8Array(p),u,l,d,n.mode,n.filter),p})})}else return null}}class Ln{constructor(t){this.name=S.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const s=this.parser.json,e=s.nodes[t];if(!e.extensions||!e.extensions[this.name]||e.mesh===void 0)return null;const n=s.meshes[e.mesh];for(const c of n.primitives)if(c.mode!==F.TRIANGLES&&c.mode!==F.TRIANGLE_STRIP&&c.mode!==F.TRIANGLE_FAN&&c.mode!==void 0)return null;const o=e.extensions[this.name].attributes,a=[],r={};for(const c in o)a.push(this.parser.getDependency("accessor",o[c]).then(u=>(r[c]=u,r[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(t)),Promise.all(a).then(c=>{const u=c.pop(),l=u.isGroup?u.children:[u],d=c[0].count,p=[];for(const f of l){const y=new $,A=new L,g=new K,b=new L(1,1,1),M=new is(f.geometry,f.material,d);for(let x=0;x<d;x++)r.TRANSLATION&&A.fromBufferAttribute(r.TRANSLATION,x),r.ROTATION&&g.fromBufferAttribute(r.ROTATION,x),r.SCALE&&b.fromBufferAttribute(r.SCALE,x),M.setMatrixAt(x,y.compose(A,g,b));for(const x in r)if(x==="_COLOR_0"){const R=r[x];M.instanceColor=new os(R.array,R.itemSize,R.normalized)}else x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&f.geometry.setAttribute(x,r[x]);Tt.prototype.copy.call(M,f),this.parser.assignFinalMaterial(M),p.push(M)}return u.isGroup?(u.clear(),u.add(...p),u):p[0]}))}}const kt="glTF",le=12,lt={JSON:1313821514,BIN:5130562};class _n{constructor(t){this.name=S.KHR_BINARY_GLTF,this.content=null,this.body=null;const s=new DataView(t,0,le),e=new TextDecoder;if(this.header={magic:e.decode(new Uint8Array(t.slice(0,4))),version:s.getUint32(4,!0),length:s.getUint32(8,!0)},this.header.magic!==kt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-le,i=new DataView(t,le);let o=0;for(;o<n;){const a=i.getUint32(o,!0);o+=4;const r=i.getUint32(o,!0);if(o+=4,r===lt.JSON){const c=new Uint8Array(t,le+o,a);this.content=e.decode(c)}else if(r===lt.BIN){const c=le+o;this.body=t.slice(c,c+a)}o+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Cn{constructor(t,s){if(!s)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=S.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=s,this.dracoLoader.preload()}decodePrimitive(t,s){const e=this.json,n=this.dracoLoader,i=t.extensions[this.name].bufferView,o=t.extensions[this.name].attributes,a={},r={},c={};for(const u in o){const l=ke[u]||u.toLowerCase();a[l]=o[u]}for(const u in t.attributes){const l=ke[u]||u.toLowerCase();if(o[u]!==void 0){const d=e.accessors[t.attributes[u]],p=ie[d.componentType];c[l]=p.name,r[l]=d.normalized===!0}}return s.getDependency("bufferView",i).then(function(u){return new Promise(function(l){n.decodeDracoFile(u,function(d){for(const p in d.attributes){const f=d.attributes[p],y=r[p];y!==void 0&&(f.normalized=y)}l(d)},a,c)})})}}class Dn{constructor(){this.name=S.KHR_TEXTURE_TRANSFORM}extendTexture(t,s){return(s.texCoord===void 0||s.texCoord===t.channel)&&s.offset===void 0&&s.rotation===void 0&&s.scale===void 0||(t=t.clone(),s.texCoord!==void 0&&(t.channel=s.texCoord),s.offset!==void 0&&t.offset.fromArray(s.offset),s.rotation!==void 0&&(t.rotation=s.rotation),s.scale!==void 0&&t.repeat.fromArray(s.scale),t.needsUpdate=!0),t}}class In{constructor(){this.name=S.KHR_MESH_QUANTIZATION}}class Pt extends Ms{constructor(t,s,e,n){super(t,s,e,n)}copySampleValue_(t){const s=this.resultBuffer,e=this.sampleValues,n=this.valueSize,i=t*n*3+n;for(let o=0;o!==n;o++)s[o]=e[i+o];return s}interpolate_(t,s,e,n){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,r=a*2,c=a*3,u=n-s,l=(e-s)/u,d=l*l,p=d*l,f=t*c,y=f-c,A=-2*p+3*d,g=p-d,b=1-A,M=g-d+l;for(let x=0;x!==a;x++){const R=o[y+x+a],C=o[y+x+r]*u,w=o[f+x+a],V=o[f+x]*u;i[x]=b*R+M*C+A*w+g*V}return i}}const On=new K;class kn extends Pt{interpolate_(t,s,e,n){const i=super.interpolate_(t,s,e,n);return On.fromArray(i).normalize().toArray(i),i}}const F={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},ie={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ut={9728:gs,9729:bt,9984:ys,9985:As,9986:Ts,9987:wt},ht={33071:bs,33648:ws,10497:Oe},Le={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ke={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},X={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Pn={CUBICSPLINE:void 0,LINEAR:Ct,STEP:xs},_e={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Nn(m){return m.DefaultMaterial===void 0&&(m.DefaultMaterial=new Ve({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Es})),m.DefaultMaterial}function Z(m,t,s){for(const e in s.extensions)m[e]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[e]=s.extensions[e])}function Y(m,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(m.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function Vn(m,t,s){let e=!1,n=!1,i=!1;for(let c=0,u=t.length;c<u;c++){const l=t[c];if(l.POSITION!==void 0&&(e=!0),l.NORMAL!==void 0&&(n=!0),l.COLOR_0!==void 0&&(i=!0),e&&n&&i)break}if(!e&&!n&&!i)return Promise.resolve(m);const o=[],a=[],r=[];for(let c=0,u=t.length;c<u;c++){const l=t[c];if(e){const d=l.POSITION!==void 0?s.getDependency("accessor",l.POSITION):m.attributes.position;o.push(d)}if(n){const d=l.NORMAL!==void 0?s.getDependency("accessor",l.NORMAL):m.attributes.normal;a.push(d)}if(i){const d=l.COLOR_0!==void 0?s.getDependency("accessor",l.COLOR_0):m.attributes.color;r.push(d)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(r)]).then(function(c){const u=c[0],l=c[1],d=c[2];return e&&(m.morphAttributes.position=u),n&&(m.morphAttributes.normal=l),i&&(m.morphAttributes.color=d),m.morphTargetsRelative=!0,m})}function Bn(m,t){if(m.updateMorphTargets(),t.weights!==void 0)for(let s=0,e=t.weights.length;s<e;s++)m.morphTargetInfluences[s]=t.weights[s];if(t.extras&&Array.isArray(t.extras.targetNames)){const s=t.extras.targetNames;if(m.morphTargetInfluences.length===s.length){m.morphTargetDictionary={};for(let e=0,n=s.length;e<n;e++)m.morphTargetDictionary[s[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function vn(m){let t;const s=m.extensions&&m.extensions[S.KHR_DRACO_MESH_COMPRESSION];if(s?t="draco:"+s.bufferView+":"+s.indices+":"+Ce(s.attributes):t=m.indices+":"+Ce(m.attributes)+":"+m.mode,m.targets!==void 0)for(let e=0,n=m.targets.length;e<n;e++)t+=":"+Ce(m.targets[e]);return t}function Ce(m){let t="";const s=Object.keys(m).sort();for(let e=0,n=s.length;e<n;e++)t+=s[e]+":"+m[s[e]]+";";return t}function Pe(m){switch(m){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Fn(m){return m.search(/\.jpe?g($|\?)/i)>0||m.search(/^data\:image\/jpeg/)===0?"image/jpeg":m.search(/\.webp($|\?)/i)>0||m.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Hn=new $;class Un{constructor(t={},s={}){this.json=t,this.extensions={},this.plugins={},this.options=s,this.cache=new un,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let e=!1,n=!1,i=-1;typeof navigator<"u"&&(e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,i=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||e||n&&i<98?this.textureLoader=new rs(this.options.manager):this.textureLoader=new as(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new At(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,s){const e=this,n=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([e.getDependencies("scene"),e.getDependencies("animation"),e.getDependencies("camera")])}).then(function(o){const a={scene:o[0][n.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:n.asset,parser:e,userData:{}};return Z(i,a,n),Y(a,n),Promise.all(e._invokeAll(function(r){return r.afterRoot&&r.afterRoot(a)})).then(function(){t(a)})}).catch(s)}_markDefs(){const t=this.json.nodes||[],s=this.json.skins||[],e=this.json.meshes||[];for(let n=0,i=s.length;n<i;n++){const o=s[n].joints;for(let a=0,r=o.length;a<r;a++)t[o[a]].isBone=!0}for(let n=0,i=t.length;n<i;n++){const o=t[n];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(e[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(t,s){s!==void 0&&(t.refs[s]===void 0&&(t.refs[s]=t.uses[s]=0),t.refs[s]++)}_getNodeRef(t,s,e){if(t.refs[s]<=1)return e;const n=e.clone(),i=(o,a)=>{const r=this.associations.get(o);r!=null&&this.associations.set(a,r);for(const[c,u]of o.children.entries())i(u,a.children[c])};return i(e,n),n.name+="_instance_"+t.uses[s]++,n}_invokeOne(t){const s=Object.values(this.plugins);s.push(this);for(let e=0;e<s.length;e++){const n=t(s[e]);if(n)return n}return null}_invokeAll(t){const s=Object.values(this.plugins);s.unshift(this);const e=[];for(let n=0;n<s.length;n++){const i=t(s[n]);i&&e.push(i)}return e}getDependency(t,s){const e=t+":"+s;let n=this.cache.get(e);if(!n){switch(t){case"scene":n=this.loadScene(s);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(s)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(s)});break;case"accessor":n=this.loadAccessor(s);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(s)});break;case"buffer":n=this.loadBuffer(s);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(s)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(s)});break;case"skin":n=this.loadSkin(s);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(s)});break;case"camera":n=this.loadCamera(s);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(t,s)}),!n)throw new Error("Unknown type: "+t);break}this.cache.add(e,n)}return n}getDependencies(t){let s=this.cache.get(t);if(!s){const e=this,n=this.json[t+(t==="mesh"?"es":"s")]||[];s=Promise.all(n.map(function(i,o){return e.getDependency(t,o)})),this.cache.add(t,s)}return s}loadBuffer(t){const s=this.json.buffers[t],e=this.fileLoader;if(s.type&&s.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+s.type+" buffer type is not supported.");if(s.uri===void 0&&t===0)return Promise.resolve(this.extensions[S.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,o){e.load(ue.resolveURL(s.uri,n.path),i,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+s.uri+'".'))})})}loadBufferView(t){const s=this.json.bufferViews[t];return this.getDependency("buffer",s.buffer).then(function(e){const n=s.byteLength||0,i=s.byteOffset||0;return e.slice(i,i+n)})}loadAccessor(t){const s=this,e=this.json,n=this.json.accessors[t];if(n.bufferView===void 0&&n.sparse===void 0){const o=Le[n.type],a=ie[n.componentType],r=n.normalized===!0,c=new a(n.count*o);return Promise.resolve(new he(c,o,r))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(o){const a=o[0],r=Le[n.type],c=ie[n.componentType],u=c.BYTES_PER_ELEMENT,l=u*r,d=n.byteOffset||0,p=n.bufferView!==void 0?e.bufferViews[n.bufferView].byteStride:void 0,f=n.normalized===!0;let y,A;if(p&&p!==l){const g=Math.floor(d/p),b="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+g+":"+n.count;let M=s.cache.get(b);M||(y=new c(a,g*p,n.count*p/u),M=new cs(y,p/u),s.cache.add(b,M)),A=new Ss(M,r,d%p/u,f)}else a===null?y=new c(n.count*r):y=new c(a,d,n.count*r),A=new he(y,r,f);if(n.sparse!==void 0){const g=Le.SCALAR,b=ie[n.sparse.indices.componentType],M=n.sparse.indices.byteOffset||0,x=n.sparse.values.byteOffset||0,R=new b(o[1],M,n.sparse.count*g),C=new c(o[2],x,n.sparse.count*r);a!==null&&(A=new he(A.array.slice(),A.itemSize,A.normalized));for(let w=0,V=R.length;w<V;w++){const E=R[w];if(A.setX(E,C[w*r]),r>=2&&A.setY(E,C[w*r+1]),r>=3&&A.setZ(E,C[w*r+2]),r>=4&&A.setW(E,C[w*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return A})}loadTexture(t){const s=this.json,e=this.options,i=s.textures[t].source,o=s.images[i];let a=this.textureLoader;if(o.uri){const r=e.manager.getHandler(o.uri);r!==null&&(a=r)}return this.loadTextureImage(t,i,a)}loadTextureImage(t,s,e){const n=this,i=this.json,o=i.textures[t],a=i.images[s],r=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[r])return this.textureCache[r];const c=this.loadImageSource(s,e).then(function(u){u.flipY=!1,u.name=o.name||a.name||"",u.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(u.name=a.uri);const d=(i.samplers||{})[o.sampler]||{};return u.magFilter=ut[d.magFilter]||bt,u.minFilter=ut[d.minFilter]||wt,u.wrapS=ht[d.wrapS]||Oe,u.wrapT=ht[d.wrapT]||Oe,n.associations.set(u,{textures:t}),u}).catch(function(){return null});return this.textureCache[r]=c,c}loadImageSource(t,s){const e=this,n=this.json,i=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(l=>l.clone());const o=n.images[t],a=self.URL||self.webkitURL;let r=o.uri||"",c=!1;if(o.bufferView!==void 0)r=e.getDependency("bufferView",o.bufferView).then(function(l){c=!0;const d=new Blob([l],{type:o.mimeType});return r=a.createObjectURL(d),r});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const u=Promise.resolve(r).then(function(l){return new Promise(function(d,p){let f=d;s.isImageBitmapLoader===!0&&(f=function(y){const A=new Je(y);A.needsUpdate=!0,d(A)}),s.load(ue.resolveURL(l,i.path),f,void 0,p)})}).then(function(l){return c===!0&&a.revokeObjectURL(r),l.userData.mimeType=o.mimeType||Fn(o.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",r),l});return this.sourceCache[t]=u,u}assignTexture(t,s,e,n){const i=this;return this.getDependency("texture",e.index).then(function(o){if(!o)return null;if(e.texCoord!==void 0&&e.texCoord>0&&(o=o.clone(),o.channel=e.texCoord),i.extensions[S.KHR_TEXTURE_TRANSFORM]){const a=e.extensions!==void 0?e.extensions[S.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const r=i.associations.get(o);o=i.extensions[S.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),i.associations.set(o,r)}}return n!==void 0&&(o.colorSpace=n),t[s]=o,o})}assignFinalMaterial(t){const s=t.geometry;let e=t.material;const n=s.attributes.tangent===void 0,i=s.attributes.color!==void 0,o=s.attributes.normal===void 0;if(t.isPoints){const a="PointsMaterial:"+e.uuid;let r=this.cache.get(a);r||(r=new xt,Ee.prototype.copy.call(r,e),r.color.copy(e.color),r.map=e.map,r.sizeAttenuation=!1,this.cache.add(a,r)),e=r}else if(t.isLine){const a="LineBasicMaterial:"+e.uuid;let r=this.cache.get(a);r||(r=new Ne,Ee.prototype.copy.call(r,e),r.color.copy(e.color),r.map=e.map,this.cache.add(a,r)),e=r}if(n||i||o){let a="ClonedMaterial:"+e.uuid+":";n&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let r=this.cache.get(a);r||(r=e.clone(),i&&(r.vertexColors=!0),o&&(r.flatShading=!0),n&&(r.normalScale&&(r.normalScale.y*=-1),r.clearcoatNormalScale&&(r.clearcoatNormalScale.y*=-1)),this.cache.add(a,r),this.associations.set(r,this.associations.get(e))),e=r}t.material=e}getMaterialType(){return Ve}loadMaterial(t){const s=this,e=this.json,n=this.extensions,i=e.materials[t];let o;const a={},r=i.extensions||{},c=[];if(r[S.KHR_MATERIALS_UNLIT]){const l=n[S.KHR_MATERIALS_UNLIT];o=l.getMaterialType(),c.push(l.extendParams(a,i,s))}else{const l=i.pbrMetallicRoughness||{};if(a.color=new J(1,1,1),a.opacity=1,Array.isArray(l.baseColorFactor)){const d=l.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],q),a.opacity=d[3]}l.baseColorTexture!==void 0&&c.push(s.assignTexture(a,"map",l.baseColorTexture,de)),a.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,a.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(s.assignTexture(a,"metalnessMap",l.metallicRoughnessTexture)),c.push(s.assignTexture(a,"roughnessMap",l.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(t)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(t,a)})))}i.doubleSided===!0&&(a.side=Et);const u=i.alphaMode||_e.OPAQUE;if(u===_e.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,u===_e.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&o!==ne&&(c.push(s.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new v(1,1),i.normalTexture.scale!==void 0)){const l=i.normalTexture.scale;a.normalScale.set(l,l)}if(i.occlusionTexture!==void 0&&o!==ne&&(c.push(s.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&o!==ne){const l=i.emissiveFactor;a.emissive=new J().setRGB(l[0],l[1],l[2],q)}return i.emissiveTexture!==void 0&&o!==ne&&c.push(s.assignTexture(a,"emissiveMap",i.emissiveTexture,de)),Promise.all(c).then(function(){const l=new o(a);return i.name&&(l.name=i.name),Y(l,i),s.associations.set(l,{materials:t}),i.extensions&&Z(n,l,i),l})}createUniqueName(t){const s=ls.sanitizeNodeName(t||"");return s in this.nodeNamesUsed?s+"_"+ ++this.nodeNamesUsed[s]:(this.nodeNamesUsed[s]=0,s)}loadGeometries(t){const s=this,e=this.extensions,n=this.primitiveCache;function i(a){return e[S.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,s).then(function(r){return dt(r,a,s)})}const o=[];for(let a=0,r=t.length;a<r;a++){const c=t[a],u=vn(c),l=n[u];if(l)o.push(l.promise);else{let d;c.extensions&&c.extensions[S.KHR_DRACO_MESH_COMPRESSION]?d=i(c):d=dt(new Be,c,s),n[u]={primitive:c,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(t){const s=this,e=this.json,n=this.extensions,i=e.meshes[t],o=i.primitives,a=[];for(let r=0,c=o.length;r<c;r++){const u=o[r].material===void 0?Nn(this.cache):this.getDependency("material",o[r].material);a.push(u)}return a.push(s.loadGeometries(o)),Promise.all(a).then(function(r){const c=r.slice(0,r.length-1),u=r[r.length-1],l=[];for(let p=0,f=u.length;p<f;p++){const y=u[p],A=o[p];let g;const b=c[p];if(A.mode===F.TRIANGLES||A.mode===F.TRIANGLE_STRIP||A.mode===F.TRIANGLE_FAN||A.mode===void 0)g=i.isSkinnedMesh===!0?new us(y,b):new St(y,b),g.isSkinnedMesh===!0&&g.normalizeSkinWeights(),A.mode===F.TRIANGLE_STRIP?g.geometry=ct(g.geometry,yt):A.mode===F.TRIANGLE_FAN&&(g.geometry=ct(g.geometry,Ie));else if(A.mode===F.LINES)g=new Rt(y,b);else if(A.mode===F.LINE_STRIP)g=new Mt(y,b);else if(A.mode===F.LINE_LOOP)g=new hs(y,b);else if(A.mode===F.POINTS)g=new Lt(y,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+A.mode);Object.keys(g.geometry.morphAttributes).length>0&&Bn(g,i),g.name=s.createUniqueName(i.name||"mesh_"+t),Y(g,i),A.extensions&&Z(n,g,A),s.assignFinalMaterial(g),l.push(g)}for(let p=0,f=l.length;p<f;p++)s.associations.set(l[p],{meshes:t,primitives:p});if(l.length===1)return i.extensions&&Z(n,l[0],i),l[0];const d=new Se;i.extensions&&Z(n,d,i),s.associations.set(d,{meshes:t});for(let p=0,f=l.length;p<f;p++)d.add(l[p]);return d})}loadCamera(t){let s;const e=this.json.cameras[t],n=e[e.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return e.type==="perspective"?s=new _t(ve.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):e.type==="orthographic"&&(s=new ds(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),e.name&&(s.name=this.createUniqueName(e.name)),Y(s,e),Promise.resolve(s)}loadSkin(t){const s=this.json.skins[t],e=[];for(let n=0,i=s.joints.length;n<i;n++)e.push(this._loadNodeShallow(s.joints[n]));return s.inverseBindMatrices!==void 0?e.push(this.getDependency("accessor",s.inverseBindMatrices)):e.push(null),Promise.all(e).then(function(n){const i=n.pop(),o=n,a=[],r=[];for(let c=0,u=o.length;c<u;c++){const l=o[c];if(l){a.push(l);const d=new $;i!==null&&d.fromArray(i.array,c*16),r.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',s.joints[c])}return new ms(a,r)})}loadAnimation(t){const s=this.json,e=this,n=s.animations[t],i=n.name?n.name:"animation_"+t,o=[],a=[],r=[],c=[],u=[];for(let l=0,d=n.channels.length;l<d;l++){const p=n.channels[l],f=n.samplers[p.sampler],y=p.target,A=y.node,g=n.parameters!==void 0?n.parameters[f.input]:f.input,b=n.parameters!==void 0?n.parameters[f.output]:f.output;y.node!==void 0&&(o.push(this.getDependency("node",A)),a.push(this.getDependency("accessor",g)),r.push(this.getDependency("accessor",b)),c.push(f),u.push(y))}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(r),Promise.all(c),Promise.all(u)]).then(function(l){const d=l[0],p=l[1],f=l[2],y=l[3],A=l[4],g=[];for(let b=0,M=d.length;b<M;b++){const x=d[b],R=p[b],C=f[b],w=y[b],V=A[b];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const E=e._createAnimationTracks(x,R,C,w,V);if(E)for(let _=0;_<E.length;_++)g.push(E[_])}return new ps(i,void 0,g)})}createNodeMesh(t){const s=this.json,e=this,n=s.nodes[t];return n.mesh===void 0?null:e.getDependency("mesh",n.mesh).then(function(i){const o=e._getNodeRef(e.meshCache,n.mesh,i);return n.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let r=0,c=n.weights.length;r<c;r++)a.morphTargetInfluences[r]=n.weights[r]}),o})}loadNode(t){const s=this.json,e=this,n=s.nodes[t],i=e._loadNodeShallow(t),o=[],a=n.children||[];for(let c=0,u=a.length;c<u;c++)o.push(e.getDependency("node",a[c]));const r=n.skin===void 0?Promise.resolve(null):e.getDependency("skin",n.skin);return Promise.all([i,Promise.all(o),r]).then(function(c){const u=c[0],l=c[1],d=c[2];d!==null&&u.traverse(function(p){p.isSkinnedMesh&&p.bind(d,Hn)});for(let p=0,f=l.length;p<f;p++)u.add(l[p]);return u})}_loadNodeShallow(t){const s=this.json,e=this.extensions,n=this;if(this.nodeCache[t]!==void 0)return this.nodeCache[t];const i=s.nodes[t],o=i.name?n.createUniqueName(i.name):"",a=[],r=n._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(t)});return r&&a.push(r),i.camera!==void 0&&a.push(n.getDependency("camera",i.camera).then(function(c){return n._getNodeRef(n.cameraCache,i.camera,c)})),n._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(t)}).forEach(function(c){a.push(c)}),this.nodeCache[t]=Promise.all(a).then(function(c){let u;if(i.isBone===!0?u=new fs:c.length>1?u=new Se:c.length===1?u=c[0]:u=new Tt,u!==c[0])for(let l=0,d=c.length;l<d;l++)u.add(c[l]);if(i.name&&(u.userData.name=i.name,u.name=o),Y(u,i),i.extensions&&Z(e,u,i),i.matrix!==void 0){const l=new $;l.fromArray(i.matrix),u.applyMatrix4(l)}else i.translation!==void 0&&u.position.fromArray(i.translation),i.rotation!==void 0&&u.quaternion.fromArray(i.rotation),i.scale!==void 0&&u.scale.fromArray(i.scale);return n.associations.has(u)||n.associations.set(u,{}),n.associations.get(u).nodes=t,u}),this.nodeCache[t]}loadScene(t){const s=this.extensions,e=this.json.scenes[t],n=this,i=new Se;e.name&&(i.name=n.createUniqueName(e.name)),Y(i,e),e.extensions&&Z(s,i,e);const o=e.nodes||[],a=[];for(let r=0,c=o.length;r<c;r++)a.push(n.getDependency("node",o[r]));return Promise.all(a).then(function(r){for(let u=0,l=r.length;u<l;u++)i.add(r[u]);const c=u=>{const l=new Map;for(const[d,p]of n.associations)(d instanceof Ee||d instanceof Je)&&l.set(d,p);return u.traverse(d=>{const p=n.associations.get(d);p!=null&&l.set(d,p)}),l};return n.associations=c(i),i})}_createAnimationTracks(t,s,e,n,i){const o=[],a=t.name?t.name:t.uuid,r=[];X[i.path]===X.weights?t.traverse(function(d){d.morphTargetInfluences&&r.push(d.name?d.name:d.uuid)}):r.push(a);let c;switch(X[i.path]){case X.weights:c=tt;break;case X.rotation:c=st;break;case X.position:case X.scale:c=et;break;default:switch(e.itemSize){case 1:c=tt;break;case 2:case 3:default:c=et;break}break}const u=n.interpolation!==void 0?Pn[n.interpolation]:Ct,l=this._getArrayFromAccessor(e);for(let d=0,p=r.length;d<p;d++){const f=new c(r[d]+"."+X[i.path],s.array,l,u);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(f),o.push(f)}return o}_getArrayFromAccessor(t){let s=t.array;if(t.normalized){const e=Pe(s.constructor),n=new Float32Array(s.length);for(let i=0,o=s.length;i<o;i++)n[i]=s[i]*e;s=n}return s}_createCubicSplineTrackInterpolant(t){t.createInterpolant=function(e){const n=this instanceof st?kn:Pt;return new n(this.times,this.values,this.getValueSize()/3,e)},t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Gn(m,t,s){const e=t.attributes,n=new Dt;if(e.POSITION!==void 0){const a=s.json.accessors[e.POSITION],r=a.min,c=a.max;if(r!==void 0&&c!==void 0){if(n.set(new L(r[0],r[1],r[2]),new L(c[0],c[1],c[2])),a.normalized){const u=Pe(ie[a.componentType]);n.min.multiplyScalar(u),n.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=t.targets;if(i!==void 0){const a=new L,r=new L;for(let c=0,u=i.length;c<u;c++){const l=i[c];if(l.POSITION!==void 0){const d=s.json.accessors[l.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(r.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),r.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),r.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const y=Pe(ie[d.componentType]);r.multiplyScalar(y)}a.max(r)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}m.boundingBox=n;const o=new Rs;n.getCenter(o.center),o.radius=n.min.distanceTo(n.max)/2,m.boundingSphere=o}function dt(m,t,s){const e=t.attributes,n=[];function i(o,a){return s.getDependency("accessor",o).then(function(r){m.setAttribute(a,r)})}for(const o in e){const a=ke[o]||o.toLowerCase();a in m.attributes||n.push(i(e[o],a))}if(t.indices!==void 0&&!m.index){const o=s.getDependency("accessor",t.indices).then(function(a){m.setIndex(a)});n.push(o)}return $e.workingColorSpace!==q&&"COLOR_0"in e&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${$e.workingColorSpace}" not supported.`),Y(m,t),Gn(m,t,s),Promise.all(n).then(function(){return t.targets!==void 0?Vn(m,t.targets,s):m})}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class zn extends St{constructor(t,s){super(t,s),this.isExtendedMesh=!0,this.isGroup=!1,this.vector3=new L,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class Nt{constructor(){this._defaultMaterial=new It({color:13421772})}get(){return this._defaultMaterial}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class jn{constructor(t){this.scene=t,this.isHeadless=t==="headless",this.defaultMaterial=new Nt}get make(){return{plane:(t={},s={})=>this.makePlane(t,s),box:(t={},s={})=>this.makeBox(t,s),sphere:(t={},s={})=>this.makeSphere(t,s),capsule:(t={},s={})=>this.makeCapsule(t,s),cylinder:(t={},s={})=>this.makeCylinder(t,s),cone:(t={},s={})=>this.makeCone(t,s),torus:(t={},s={})=>this.makeTorus(t,s),extrude:(t,s={})=>this.makeExtrude(t,s)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},s={})=>this.addPlane(t,s),box:(t={},s={})=>this.addBox(t,s),ground:(t,s={})=>this.addGround(t,s),sphere:(t={},s={})=>this.addSphere(t,s),capsule:(t={},s={})=>this.addCapsule(t,s),cylinder:(t={},s={})=>this.addCylinder(t,s),cone:(t={},s={})=>this.addCone(t,s),torus:(t={},s={})=>this.addTorus(t,s),extrude:(t,s={})=>this.addExtrude(t,s),material:(t={})=>this.addMaterial(t)}}addExisting(...t){this.scene!=="headless"&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let s=0;s<t.length;s++)this.addExisting(t[s]);else this.addExisting(t);return this}createMesh(t,s,e){const{x:n=0,y:i=0,z:o=0}=e;let a;switch(!Array.isArray(s)&&s.type){case"LineBasicMaterial":a=new Mt(t,s);break;case"PointsMaterial":a=new Lt(t,s);break;default:a=new zn(t,s);break}return a.position.set(n,i,o),a.castShadow=a.receiveShadow=!0,a}makeExtrude(t,s){const{x:e,y:n,z:i,name:o,shape:a,autoCenter:r=!0,breakable:c=!1,...u}=t,{depth:l=1,bevelEnabled:d=!1}=u,p=new Ls(a,{depth:l,bevelEnabled:d,...u}),f=this.addMaterial(s),y=this.createMesh(p,f,{x:e,y:n,z:i});return r&&y.geometry.center(),y.name=o||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,s={}){const e=this.makeExtrude(t,s);return this.addExisting(e),e}makePlane(t,s){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new _s(r.width||1,r.height||1,r.widthSegments||1,r.heightSegments||1),u=this.addMaterial(s);u.side=Et;const l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="plane",l}addPlane(t,s){const e=this.makePlane(t,s);return this.addExisting(e),e}makeSphere(t,s){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new Cs(r.radius||1,r.widthSegments||16,r.heightSegments||12,r.phiStart||void 0,r.phiLength||void 0,r.thetaStart||void 0,r.thetaLength||void 0),u=this.addMaterial(s),l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="sphere",l}addSphere(t={},s={}){const e=this.makeSphere(t,s);return this.addExisting(e),e}makeBox(t,s){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new Ds(r.width||1,r.height||1,r.depth||1,r.widthSegments||void 0,r.heightSegments||void 0,r.depthSegments||void 0),u=this.addMaterial(s),l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="box",l}addBox(t={},s={}){const e=this.makeBox(t,s);return this.addExisting(e),e}addGround(t,s={}){const e=this.makeBox(t,s);return e.rotateX(ve.degToRad(90)),this.addExisting(e),e}makeCapsule(t={},s={}){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new Is(r.radius||.5,r.length||1,r.capSegments||4,r.radialSegments||16),u=this.addMaterial(s),l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="capsule",l}addCapsule(t={},s={}){const e=this.makeCapsule(t,s);return this.addExisting(e),e}makeCylinder(t={},s={}){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new Os(r.radiusTop||1,r.radiusBottom||1,r.height||1,r.radiusSegments||void 0,r.heightSegments||void 0,r.openEnded||void 0,r.thetaStart||void 0,r.thetaLength||void 0),u=this.addMaterial(s),l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="cylinder",l}addCylinder(t={},s={}){const e=this.makeCylinder(t,s);return this.addExisting(e),e}makeCone(t={},s={}){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new ks(r.radius||1,r.height||1,r.radiusSegments||8,r.heightSegments||1,r.openEnded||!1,r.thetaStart||0,r.thetaLength||2*Math.PI),u=this.addMaterial(s),l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="cone",l}addCone(t={},s={}){const e=this.makeCone(t,s);return this.addExisting(e),e}makeTorus(t={},s={}){const{x:e,y:n,z:i,name:o,breakable:a=!1,...r}=t,c=new Ps(r.radius||void 0,r.tube||void 0,r.radialSegments||void 0,r.tubularSegments||void 0,r.arc||void 0),u=this.addMaterial(s),l=this.createMesh(c,u,{x:e,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="torus",l}addTorus(t={},s={}){const e=this.makeTorus(t,s);return this.addExisting(e),e}addMaterial(t={}){const s=Object.keys(t)[0];let e;if(this.scene==="headless")return this.defaultMaterial.get();switch(s){case"basic":e=new ne(t.basic);break;case"normal":e=new Bs(t.normal);break;case"standard":e=new Ve(t.standard);break;case"lambert":e=new It(t.lambert);break;case"phong":e=new Vs(t.phong);break;case"physical":typeof t.physical<"u"?e=new H(t.physical):(fe("You need to pass parameters to the physical material. (Fallback to default material)"),e=this.defaultMaterial.get());break;case"toon":e=new Ns(t.toon);break;case"line":e=new Ne(t.line);break;case"points":e=new xt(t.points);break;case"custom":e=t.custom||this.defaultMaterial.get();break;default:e=this.defaultMaterial.get();break}return e}}const mt={type:"change"},De={type:"start"},pt={type:"end"},pe=new vs,ft=new Fs,Kn=Math.cos(70*ve.DEG2RAD);class Wn extends Hs{constructor(t,s){super(),this.object=t,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new L,this.cursor=new L,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:te.ROTATE,MIDDLE:te.DOLLY,RIGHT:te.PAN},this.touches={ONE:se.ROTATE,TWO:se.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(h){h.addEventListener("keydown",be),this._domElementKeyEvents=h},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",be),this._domElementKeyEvents=null},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(mt),e.update(),i=n.NONE},this.update=function(){const h=new L,T=new K().setFromUnitVectors(t.up,new L(0,1,0)),I=T.clone().invert(),P=new L,B=new K,ee=new L,W=2*Math.PI;return function($t=null){const Ze=e.object.position;h.copy(Ze).sub(e.target),h.applyQuaternion(T),a.setFromVector3(h),e.autoRotate&&i===n.NONE&&O(E($t)),e.enableDamping?(a.theta+=r.theta*e.dampingFactor,a.phi+=r.phi*e.dampingFactor):(a.theta+=r.theta,a.phi+=r.phi);let z=e.minAzimuthAngle,j=e.maxAzimuthAngle;isFinite(z)&&isFinite(j)&&(z<-Math.PI?z+=W:z>Math.PI&&(z-=W),j<-Math.PI?j+=W:j>Math.PI&&(j-=W),z<=j?a.theta=Math.max(z,Math.min(j,a.theta)):a.theta=a.theta>(z+j)/2?Math.max(z,a.theta):Math.min(j,a.theta)),a.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,a.phi)),a.makeSafe(),e.enableDamping===!0?e.target.addScaledVector(u,e.dampingFactor):e.target.add(u),e.target.sub(e.cursor),e.target.clampLength(e.minTargetRadius,e.maxTargetRadius),e.target.add(e.cursor),e.zoomToCursor&&C||e.object.isOrthographicCamera?a.radius=Ae(a.radius):a.radius=Ae(a.radius*c),h.setFromSpherical(a),h.applyQuaternion(I),Ze.copy(e.target).add(h),e.object.lookAt(e.target),e.enableDamping===!0?(r.theta*=1-e.dampingFactor,r.phi*=1-e.dampingFactor,u.multiplyScalar(1-e.dampingFactor)):(r.set(0,0,0),u.set(0,0,0));let xe=!1;if(e.zoomToCursor&&C){let ae=null;if(e.object.isPerspectiveCamera){const ce=h.length();ae=Ae(ce*c);const me=ce-ae;e.object.position.addScaledVector(x,me),e.object.updateMatrixWorld()}else if(e.object.isOrthographicCamera){const ce=new L(R.x,R.y,0);ce.unproject(e.object),e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/c)),e.object.updateProjectionMatrix(),xe=!0;const me=new L(R.x,R.y,0);me.unproject(e.object),e.object.position.sub(me).add(ce),e.object.updateMatrixWorld(),ae=h.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),e.zoomToCursor=!1;ae!==null&&(this.screenSpacePanning?e.target.set(0,0,-1).transformDirection(e.object.matrix).multiplyScalar(ae).add(e.object.position):(pe.origin.copy(e.object.position),pe.direction.set(0,0,-1).transformDirection(e.object.matrix),Math.abs(e.object.up.dot(pe.direction))<Kn?t.lookAt(e.target):(ft.setFromNormalAndCoplanarPoint(e.object.up,e.target),pe.intersectPlane(ft,e.target))))}else e.object.isOrthographicCamera&&(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/c)),e.object.updateProjectionMatrix(),xe=!0);return c=1,C=!1,xe||P.distanceToSquared(e.object.position)>o||8*(1-B.dot(e.object.quaternion))>o||ee.distanceToSquared(e.target)>0?(e.dispatchEvent(mt),P.copy(e.object.position),B.copy(e.object.quaternion),ee.copy(e.target),!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",qe),e.domElement.removeEventListener("pointerdown",Xe),e.domElement.removeEventListener("pointercancel",re),e.domElement.removeEventListener("wheel",Ye),e.domElement.removeEventListener("pointermove",Te),e.domElement.removeEventListener("pointerup",re),e._domElementKeyEvents!==null&&(e._domElementKeyEvents.removeEventListener("keydown",be),e._domElementKeyEvents=null)};const e=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=n.NONE;const o=1e-6,a=new nt,r=new nt;let c=1;const u=new L,l=new v,d=new v,p=new v,f=new v,y=new v,A=new v,g=new v,b=new v,M=new v,x=new L,R=new v;let C=!1;const w=[],V={};function E(h){return h!==null?2*Math.PI/60*e.autoRotateSpeed*h:2*Math.PI/60/60*e.autoRotateSpeed}function _(){return Math.pow(.95,e.zoomSpeed)}function O(h){r.theta-=h}function k(h){r.phi-=h}const D=function(){const h=new L;return function(I,P){h.setFromMatrixColumn(P,0),h.multiplyScalar(-I),u.add(h)}}(),N=function(){const h=new L;return function(I,P){e.screenSpacePanning===!0?h.setFromMatrixColumn(P,1):(h.setFromMatrixColumn(P,0),h.crossVectors(e.object.up,h)),h.multiplyScalar(I),u.add(h)}}(),U=function(){const h=new L;return function(I,P){const B=e.domElement;if(e.object.isPerspectiveCamera){const ee=e.object.position;h.copy(ee).sub(e.target);let W=h.length();W*=Math.tan(e.object.fov/2*Math.PI/180),D(2*I*W/B.clientHeight,e.object.matrix),N(2*P*W/B.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(D(I*(e.object.right-e.object.left)/e.object.zoom/B.clientWidth,e.object.matrix),N(P*(e.object.top-e.object.bottom)/e.object.zoom/B.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function Q(h){e.object.isPerspectiveCamera||e.object.isOrthographicCamera?c/=h:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function G(h){e.object.isPerspectiveCamera||e.object.isOrthographicCamera?c*=h:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function oe(h){if(!e.zoomToCursor)return;C=!0;const T=e.domElement.getBoundingClientRect(),I=h.clientX-T.left,P=h.clientY-T.top,B=T.width,ee=T.height;R.x=I/B*2-1,R.y=-(P/ee)*2+1,x.set(R.x,R.y,1).unproject(e.object).sub(e.object.position).normalize()}function Ae(h){return Math.max(e.minDistance,Math.min(e.maxDistance,h))}function Fe(h){l.set(h.clientX,h.clientY)}function Vt(h){oe(h),g.set(h.clientX,h.clientY)}function He(h){f.set(h.clientX,h.clientY)}function Bt(h){d.set(h.clientX,h.clientY),p.subVectors(d,l).multiplyScalar(e.rotateSpeed);const T=e.domElement;O(2*Math.PI*p.x/T.clientHeight),k(2*Math.PI*p.y/T.clientHeight),l.copy(d),e.update()}function vt(h){b.set(h.clientX,h.clientY),M.subVectors(b,g),M.y>0?Q(_()):M.y<0&&G(_()),g.copy(b),e.update()}function Ft(h){y.set(h.clientX,h.clientY),A.subVectors(y,f).multiplyScalar(e.panSpeed),U(A.x,A.y),f.copy(y),e.update()}function Ht(h){oe(h),h.deltaY<0?G(_()):h.deltaY>0&&Q(_()),e.update()}function Ut(h){let T=!1;switch(h.code){case e.keys.UP:h.ctrlKey||h.metaKey||h.shiftKey?k(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):U(0,e.keyPanSpeed),T=!0;break;case e.keys.BOTTOM:h.ctrlKey||h.metaKey||h.shiftKey?k(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):U(0,-e.keyPanSpeed),T=!0;break;case e.keys.LEFT:h.ctrlKey||h.metaKey||h.shiftKey?O(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):U(e.keyPanSpeed,0),T=!0;break;case e.keys.RIGHT:h.ctrlKey||h.metaKey||h.shiftKey?O(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):U(-e.keyPanSpeed,0),T=!0;break}T&&(h.preventDefault(),e.update())}function Ue(){if(w.length===1)l.set(w[0].pageX,w[0].pageY);else{const h=.5*(w[0].pageX+w[1].pageX),T=.5*(w[0].pageY+w[1].pageY);l.set(h,T)}}function Ge(){if(w.length===1)f.set(w[0].pageX,w[0].pageY);else{const h=.5*(w[0].pageX+w[1].pageX),T=.5*(w[0].pageY+w[1].pageY);f.set(h,T)}}function ze(){const h=w[0].pageX-w[1].pageX,T=w[0].pageY-w[1].pageY,I=Math.sqrt(h*h+T*T);g.set(0,I)}function Gt(){e.enableZoom&&ze(),e.enablePan&&Ge()}function zt(){e.enableZoom&&ze(),e.enableRotate&&Ue()}function je(h){if(w.length==1)d.set(h.pageX,h.pageY);else{const I=we(h),P=.5*(h.pageX+I.x),B=.5*(h.pageY+I.y);d.set(P,B)}p.subVectors(d,l).multiplyScalar(e.rotateSpeed);const T=e.domElement;O(2*Math.PI*p.x/T.clientHeight),k(2*Math.PI*p.y/T.clientHeight),l.copy(d)}function Ke(h){if(w.length===1)y.set(h.pageX,h.pageY);else{const T=we(h),I=.5*(h.pageX+T.x),P=.5*(h.pageY+T.y);y.set(I,P)}A.subVectors(y,f).multiplyScalar(e.panSpeed),U(A.x,A.y),f.copy(y)}function We(h){const T=we(h),I=h.pageX-T.x,P=h.pageY-T.y,B=Math.sqrt(I*I+P*P);b.set(0,B),M.set(0,Math.pow(b.y/g.y,e.zoomSpeed)),Q(M.y),g.copy(b)}function jt(h){e.enableZoom&&We(h),e.enablePan&&Ke(h)}function Kt(h){e.enableZoom&&We(h),e.enableRotate&&je(h)}function Xe(h){e.enabled!==!1&&(w.length===0&&(e.domElement.setPointerCapture(h.pointerId),e.domElement.addEventListener("pointermove",Te),e.domElement.addEventListener("pointerup",re)),Qt(h),h.pointerType==="touch"?Yt(h):Wt(h))}function Te(h){e.enabled!==!1&&(h.pointerType==="touch"?qt(h):Xt(h))}function re(h){Zt(h),w.length===0&&(e.domElement.releasePointerCapture(h.pointerId),e.domElement.removeEventListener("pointermove",Te),e.domElement.removeEventListener("pointerup",re)),e.dispatchEvent(pt),i=n.NONE}function Wt(h){let T;switch(h.button){case 0:T=e.mouseButtons.LEFT;break;case 1:T=e.mouseButtons.MIDDLE;break;case 2:T=e.mouseButtons.RIGHT;break;default:T=-1}switch(T){case te.DOLLY:if(e.enableZoom===!1)return;Vt(h),i=n.DOLLY;break;case te.ROTATE:if(h.ctrlKey||h.metaKey||h.shiftKey){if(e.enablePan===!1)return;He(h),i=n.PAN}else{if(e.enableRotate===!1)return;Fe(h),i=n.ROTATE}break;case te.PAN:if(h.ctrlKey||h.metaKey||h.shiftKey){if(e.enableRotate===!1)return;Fe(h),i=n.ROTATE}else{if(e.enablePan===!1)return;He(h),i=n.PAN}break;default:i=n.NONE}i!==n.NONE&&e.dispatchEvent(De)}function Xt(h){switch(i){case n.ROTATE:if(e.enableRotate===!1)return;Bt(h);break;case n.DOLLY:if(e.enableZoom===!1)return;vt(h);break;case n.PAN:if(e.enablePan===!1)return;Ft(h);break}}function Ye(h){e.enabled===!1||e.enableZoom===!1||i!==n.NONE||(h.preventDefault(),e.dispatchEvent(De),Ht(h),e.dispatchEvent(pt))}function be(h){e.enabled===!1||e.enablePan===!1||Ut(h)}function Yt(h){switch(Qe(h),w.length){case 1:switch(e.touches.ONE){case se.ROTATE:if(e.enableRotate===!1)return;Ue(),i=n.TOUCH_ROTATE;break;case se.PAN:if(e.enablePan===!1)return;Ge(),i=n.TOUCH_PAN;break;default:i=n.NONE}break;case 2:switch(e.touches.TWO){case se.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;Gt(),i=n.TOUCH_DOLLY_PAN;break;case se.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;zt(),i=n.TOUCH_DOLLY_ROTATE;break;default:i=n.NONE}break;default:i=n.NONE}i!==n.NONE&&e.dispatchEvent(De)}function qt(h){switch(Qe(h),i){case n.TOUCH_ROTATE:if(e.enableRotate===!1)return;je(h),e.update();break;case n.TOUCH_PAN:if(e.enablePan===!1)return;Ke(h),e.update();break;case n.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;jt(h),e.update();break;case n.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;Kt(h),e.update();break;default:i=n.NONE}}function qe(h){e.enabled!==!1&&h.preventDefault()}function Qt(h){w.push(h)}function Zt(h){delete V[h.pointerId];for(let T=0;T<w.length;T++)if(w[T].pointerId==h.pointerId){w.splice(T,1);return}}function Qe(h){let T=V[h.pointerId];T===void 0&&(T=new v,V[h.pointerId]=T),T.set(h.pageX,h.pageY)}function we(h){const T=h.pointerId===w[0].pointerId?w[1]:w[0];return V[T.pointerId]}e.domElement.addEventListener("contextmenu",qe),e.domElement.addEventListener("pointerdown",Xe),e.domElement.addEventListener("pointercancel",re),e.domElement.addEventListener("wheel",Ye,{passive:!1}),this.update()}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Xn{constructor(t,s){this.physics=t,this.ammo=s,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.impact=[],this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new Ot,this.tmpQuaternion=new K,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new ge,this.name=s.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){typeof this.eventEmitter>"u"&&(this.eventEmitter=new ge)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,s=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,s?this.eventEmitter.once("update",()=>{t()}):this.eventEmitter.on("update",()=>{t()})}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",s=>{const{bodies:e,event:n}=s;e[0].name===this.name?t(e[1],n):e[1].name===this.name&&t(e[0],n)})}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,s,e){const n=this.tmpEuler.set(t,s,e),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(n),this.tmpBtQuaternion.setValue(0,0,0,1);const o=this.tmpBtQuaternion;o.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(o)}get rotation(){let t,s,e;const i=this.physics.worldTransform.getRotation();let o=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());o.w>1&&(o=o.normalize());const a=2*Math.acos(o.w),r=Math.sqrt(1-o.w*o.w);return r<.001?(t=o.x,s=o.y,e=o.z):(t=o.x/r,s=o.y/r,e=o.z/r),{x:t*a,y:s*a,z:e*a}}get quaternion(){const s=this.physics.worldTransform.getRotation();return{x:s.x(),y:s.y(),z:s.z(),w:s.w()}}setPosition(t,s,e){this.physics.worldTransform.getOrigin().setValue(t,s,e)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,s){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(s.x||0,s.y||0,s.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,s){this.ammo.setDamping(t,s)}setGravity(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,s,e){this.tmpBtVector3.setValue(t,s,e),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Yn{constructor(t,s){this.factory=t,this.addExisting=s}addPlane(t={},s={}){const e=this.factory.add.plane(t,s);return this.addExisting(e,t),e}addSphere(t={},s={}){const e=this.factory.add.sphere(t,s);return this.addExisting(e,t),e}addBox(t={},s={}){const e=this.factory.add.box(t,s);return this.addExisting(e,t),e}addGround(t,s={}){const e=this.factory.add.ground(t,s),n={...t,mass:0,collisionFlags:1};return this.addExisting(e,n),e}addCapsule(t={},s={}){const e=this.factory.add.capsule(t,s);return this.addExisting(e,t),e}addCylinder(t={},s={}){const e=this.factory.add.cylinder(t,s);return this.addExisting(e,t),e}addCone(t={},s={}){const e=this.factory.add.cone(t,s);return this.addExisting(e,t),e}addTorus(t={},s={}){const e=this.factory.add.torus(t,s);return this.addExisting(e,t),e}addExtrude(t,s={}){const e=this.factory.add.extrude(t,s);return e.translateX(1),this.addExisting(e),e}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class qn{constructor(t,s){this.worldTransform=t,this.physicsWorld=s,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,s=0){return new Ammo.btVector3(typeof(t==null?void 0:t.x)<"u"?t.x:s,typeof(t==null?void 0:t.y)<"u"?t.y:s,typeof(t==null?void 0:t.z)<"u"?t.z:s)}get addConstraints(){return{lock:(t,s,e)=>this.lock(t,s,e),fixed:(t,s,e)=>this.fixed(t,s,e),pointToPoint:(t,s,e,n)=>this.pointToPoint(t,s,e,n),hinge:(t,s,e,n)=>this.hinge(t,s,e,n),slider:(t,s,e={},n)=>this.slider(t,s,e,n),spring:(t,s,e={},n)=>this.spring(t,s,e,n),coneTwist:(t,s,e={frameA:{},frameB:{}},n)=>this.coneTwist(t,s,e,n),dof:(t,s,e,n)=>this.dof(t,s,e,n)}}getTransform(t,s,e={x:0,y:0,z:0},n=!1){e={x:0,y:0,z:0,...e};const i=(a,r)=>{var c=(a.x()-r.x())/2+e.x,u=(a.y()-r.y())/2+e.y,l=(a.z()-r.z())/2+e.z;return new Ammo.btVector3(c,u,l)},o=new Ammo.btTransform;if(o.setIdentity(),n){const a=i(t.getWorldTransform().getOrigin(),s.getWorldTransform().getOrigin()),r=new Ammo.btTransform;r.setIdentity(),r.setOrigin(a);const c=t.getCenterOfMassTransform().inverse().op_mul(s.getWorldTransform());return c.op_mul(r),{transformA:c,transformB:r}}else return o.setOrigin(new Ammo.btVector3(e.x,e.y,e.z)),{transformA:t.getCenterOfMassTransform().inverse().op_mul(s.getWorldTransform()).op_mul(o),transformB:o}}lock(t,s,e=!0){const n={x:0,y:0,z:0};return this.dof(t,s,{angularLowerLimit:n,angularUpperLimit:n},e)}fixed(t,s,e=!0){const n=this.getTransform(t.ammo,s.ammo);n.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),n.transformB.setRotation(s.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(t.ammo,s.ammo,n.transformA,n.transformB);return this.physicsWorld.addConstraint(i,e),i}pointToPoint(t,s,e={},n=!0){const{pivotA:i,pivotB:o}=e,a=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),r=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),c=new Ammo.btPoint2PointConstraint(t.ammo,s.ammo,a,r);return this.physicsWorld.addConstraint(c,n),c}hinge(t,s,e={},n=!0){const{pivotA:i,pivotB:o,axisA:a,axisB:r}=e,c=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),u=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),l=new Ammo.btVector3((a==null?void 0:a.x)||0,(a==null?void 0:a.y)||0,(a==null?void 0:a.z)||0),d=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),p=new Ammo.btHingeConstraint(t.ammo,s.ammo,c,u,l,d,!0);return this.physicsWorld.addConstraint(p,n),p}slider(t,s,e={},n=!0){const i=this.getTransform(t.ammo,s.ammo),{frameA:o={},frameB:a={},linearLowerLimit:r=0,linearUpperLimit:c=0,angularLowerLimit:u=0,angularUpperLimit:l=0}=e,d=i.transformA.getRotation();d.setEulerZYX(o.x||0,o.y||0,o.z||0),i.transformA.setRotation(d);const p=i.transformB.getRotation();p.setEulerZYX(a.x||0,a.y||0,a.z||0),i.transformB.setRotation(p);const f=new Ammo.btSliderConstraint(t.ammo,s.ammo,i.transformA,i.transformB,!0);return f.setLowerLinLimit(r),f.setUpperLinLimit(c),f.setLowerAngLimit(u),f.setUpperAngLimit(l),this.physicsWorld.addConstraint(f,n),f}spring(t,s,e={},n=!0){const{stiffness:i=50,damping:o=.01,angularLock:a=!1,linearLowerLimit:r={},linearUpperLimit:c={},angularLowerLimit:u={},angularUpperLimit:l={},offset:d={},center:p=!1,enableSpring:f=!0}=e,y={x:0,y:0,z:0,...d},A=this.getTransform(t.ammo,s.ammo,y,p),g=new Ammo.btGeneric6DofSpringConstraint(t.ammo,s.ammo,A.transformA,A.transformB,!0);this.tmpBtVector3.setValue(r.x||0,r.y||0,r.z||0),g.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(c.x||0,c.y||0,c.z||0),g.setLinearUpperLimit(this.tmpBtVector3),a?(this.tmpBtVector3.setValue(0,0,0),g.setAngularLowerLimit(this.tmpBtVector3),g.setAngularUpperLimit(this.tmpBtVector3)):(console.log(u,l),g.setAngularLowerLimit(this.toAmmoV3(u,-Math.PI)),g.setAngularUpperLimit(this.toAmmoV3(l,Math.PI)));for(let b=0;b<3;b++)g.enableSpring(b,f),g.setStiffness(b,i),g.setDamping(b,o);return this.physicsWorld.addConstraint(g,n),g}coneTwist(t,s,e,n=!0){const{frameA:i,frameB:o}=e,a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0);const r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),this.getTransform(t.ammo,s.ammo);const c=new Ammo.btConeTwistConstraint(s.ammo,t.ammo,a,r);return c.setAngularOnly(!0),this.physicsWorld.addConstraint(c,n),c}dof(t,s,e={},n=!0){const{offset:i,center:o=!1}=e,a={x:0,y:0,z:0,...i},r=this.getTransform(t.ammo,s.ammo,a,o),c=new Ammo.btGeneric6DofConstraint(t.ammo,s.ammo,r.transformA,r.transformB,!0),{linearLowerLimit:u,linearUpperLimit:l,angularLowerLimit:d,angularUpperLimit:p}=e,f=this.toAmmoV3(u),y=this.toAmmoV3(l),A=this.toAmmoV3(d,-Math.PI),g=this.toAmmoV3(p,Math.PI);return c.setLinearLowerLimit(f),c.setLinearUpperLimit(y),c.setAngularLowerLimit(A),c.setAngularUpperLimit(g),Ammo.destroy(f),Ammo.destroy(y),Ammo.destroy(A),Ammo.destroy(g),this.physicsWorld.addConstraint(c,n),c}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */const Qn=(m,t)=>{const{radius:s=1,tube:e=.4,tubularSegments:n=8}=m,i=Math.PI,o=n,a=Math.sqrt(2*e*e-2*e*e*Math.cos(2*i/o)),r=new Ammo.btVector3(e,i/o+.5*a,e),c=new Ammo.btCylinderShape(r);c.setMargin(.05);const u=new Ammo.btCompoundShape,l=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),p=new Ammo.btQuaternion(t.x,t.y,t.z,t.w);for(let f=0;f<o;f++){const y=f*2*i/o,A=d.rotate(l,y),g=new Ammo.btTransform;p.setRotation(l,y+Math.PI/2),g.setIdentity(),g.setOrigin(A),g.setRotation(p),u.addChildShape(g,c)}return u};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Zn extends ge{addCollider(t,s,e){!t.body||!s.body||(t.body.checkCollisions=!0,s.body.checkCollisions=!0,this.on("collision",n=>{var a,r;const{bodies:i,event:o}=n;(a=i[0])!=null&&a.name&&((r=i[1])!=null&&r.name)&&(t!=null&&t.name)&&(s!=null&&s.name)&&(i[0].name===t.name&&i[1].name===s.name||i[1].name===t.name&&i[0].name===s.name)&&e(o)}))}}/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */const gt={NoDebug:0,DrawWireframe:1,DrawAabb:2,DrawFeaturesText:4,DrawContactPoints:8,NoDeactivation:16,NoHelpText:32,DrawText:64,ProfileTimings:128,EnableSatComparison:256,DisableBulletLCP:512,EnableCCD:1024,DrawConstraints:2048,DrawConstraintLimits:4096,FastWireframe:8192,DrawNormals:16384,DrawOnTop:32768,MAX_DEBUG_DRAW_MODE:4294967295};class $n{constructor(t,s,e={}){this.scene=t,this.world=s,this.options=e,this.debugDrawMode=e.debugDrawMode||gt.DrawWireframe;const n=this.debugDrawMode&gt.DrawOnTop||!1,i=e.maxBufferSize||1e6;this.geometry=new Be;const o=new Float32Array(i*3),a=new Float32Array(i*3);this.geometry.setAttribute("position",new he(o,3).setUsage(it)),this.geometry.setAttribute("color",new he(a,3).setUsage(it)),this.index=0;const r=new Ne({vertexColors:!0,depthTest:!n});this.mesh=new Rt(this.geometry,r),n&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(this.index!=0&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,s,e){const n=Ammo.HEAPF32,i=n[(e+0)/4],o=n[(e+4)/4],a=n[(e+8)/4],r=n[(t+0)/4],c=n[(t+4)/4],u=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,r,c,u),this.geometry.attributes.color.setXYZ(this.index++,i,o,a);const l=n[(s+0)/4],d=n[(s+4)/4],p=n[(s+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,d,p),this.geometry.attributes.color.setXYZ(this.index++,i,o,a)}drawContactPoint(t,s,e,n,i){const o=Ammo.HEAPF32,a=o[(i+0)/4],r=o[(i+4)/4],c=o[(i+8)/4],u=o[(t+0)/4],l=o[(t+4)/4],d=o[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,u,l,d),this.geometry.attributes.color.setXYZ(this.index++,a,r,c);const p=o[(s+0)/4]*e,f=o[(s+4)/4]*e,y=o[(s+8)/4]*e;this.geometry.attributes.position.setXYZ(this.index,u+p,l+f,d+y),this.geometry.attributes.color.setXYZ(this.index++,a,r,c)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,s){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}}const Jn=(m,t)=>{typeof window<"u"&&(window.__loadPhysics=!0),Xs(m,()=>{Ammo().then(()=>{t()})})};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class ei extends ge{constructor(t,s={}){super(),this.scene=t,this.config=s,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=s.gravity||{x:0,y:-9.81,z:0},this.isHeadless=t==="headless",this.tmpEuler=new Ot,this.tmpQuaternion=new K,this.tmpVector3=new L,this.tmpVector3a=new L,this.tmpMatrix4=new $,this.tmpMatrix4a=new $,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new L,this.impactPoint=new L,this.impactNormal=new L,t!=="headless"&&(this.defaultMaterial=new Nt),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var i;const s=Object.keys(t).includes("body")?t.body:t;if(typeof(s==null?void 0:s.ammo)>"u")return;let e=s.ammo.threeObject;const n=e.name;if(n&&e&&(i=e==null?void 0:e.body)!=null&&i.ammo){e.body.isSoftBody?this.physicsWorld.removeSoftBody(e.body.ammo):this.physicsWorld.removeRigidBody(e.body.ammo),e.body.destructor(),e.body=void 0,e.hasBody=!1,delete s.ammo.threeObject;for(let o=0;o<this.rigidBodies.length;o++)this.rigidBodies[o].name===n&&(this.rigidBodies.splice(o,1),o--)}this.scene==="headless"&&e&&(e=null)}setup(){if(this.worldTransform=new Ammo.btTransform,typeof this.config.setupPhysicsWorld=="function"?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),this.scene!=="headless"){this.convexBreaker=new Ys,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new Zn,this.factory=new jn(this.scene),this.shapes=new Yn(this.factory,(t,s)=>this.addExisting(t,s)),this.constraints=new qn(this.worldTransform,this.physicsWorld),this.scene!=="headless"&&(this.debugDrawer=new $n(this.scene,this.physicsWorld,{}))}updateDebugger(){this.scene!=="headless"&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:s=!1}=this.config;let e;if(!s){const n=new Ammo.btDefaultCollisionConfiguration,i=new Ammo.btCollisionDispatcher(n),o=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver;e=new Ammo.btDiscreteDynamicsWorld(i,o,a,n)}if(s){const n=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,i=new Ammo.btCollisionDispatcher(n),o=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver,r=new Ammo.btDefaultSoftBodySolver;e=new Ammo.btSoftRigidDynamicsWorld(i,o,a,n,r)}return e.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),e}createDebrisFromBreakableObject(t,s){this.scene!=="headless"&&(t.material=s.material,t.shape="hull",t.fragmentDepth=s.fragmentDepth+1,t.name=`${s.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=s.body.fractureImpulse,t.body.breakable=!1,setTimeout(()=>{t.body.breakable=!0},2500))}removeDebris(t){this.scene!=="headless"&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const s=t/1e3;this.physicsWorld.stepSimulation(s,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let e=0;e<this.rigidBodies.length;e++){const n=this.rigidBodies[e];n.body.impact=[];const o=n.body.ammo.getMotionState();if(o){if(o.getWorldTransform(this.worldTransform),n.body.didUpdate&&(n.body._emitUpdateEvents&&n.body.eventEmitter.emit("update"),n.body.didUpdate=!1),n.body.ammo.isKinematicObject()&&n.body.needUpdate)n.getWorldQuaternion(this.tmpQuaternion),n.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),o.setWorldTransform(this.worldTransform),n.body.needUpdate=!1;else if(!n.body.skipUpdate){if(!n.body.ammo.isStaticObject()){const a=this.worldTransform.getOrigin(),r=this.worldTransform.getRotation(),c=n.body.offset;if(n.body.ignoreScale)this.tmpVector3a.set(n.scale.x,n.scale.y,n.scale.z);else{const u=n.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(u.x(),u.y(),u.z())}this.tmpVector3.set(a.x()+c.x,a.y()+c.y,a.z()+c.z),this.tmpQuaternion.set(r.x(),r.y(),r.z(),r.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),n.parent?parseInt(Us)>=123?this.tmpMatrix4a.copy(n.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(n.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(n.position,n.quaternion,n.scale)}}}}}detectCollisions(){var n,i;const t=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const s=this.physicsWorld.getDispatcher(),e=s.getNumManifolds();for(let o=0;o<e;o++){const a=s.getManifoldByIndexInternal(o),r=a.getNumContacts(),c=Ammo.castObject(a.getBody0(),Ammo.btRigidBody),u=Ammo.castObject(a.getBody1(),Ammo.btRigidBody),l=c.threeObject,d=u.threeObject;if(!l||!d||c.name===""&&u.name==="")continue;const p=(n=l.body)==null?void 0:n.checkCollisions,f=(i=d.body)==null?void 0:i.checkCollisions,y=l.body.breakable,A=d.body.breakable,g=l.body.fractureImpulse,b=d.body.fractureImpulse,M=p||f,x=y||A;if(typeof l.fragmentDepth>"u"&&(l.fragmentDepth=0),typeof d.fragmentDepth>"u"&&(d.fragmentDepth=0),!M&&!x)continue;let R=!1,C=0,w="start";for(let E=0;E<r;E++){const _=a.getContactPoint(E);if(_.getDistance()<=0){R=!0;const k=_.getAppliedImpulse(),D=_.get_m_positionWorldOnB(),N=_.get_m_normalWorldOnB();if(p||f){const U=[l.uuid,d.uuid].sort(),Q=`${U[0]}__${U[1]}`;if(this.earlierDetectedCollisions.find(G=>G.combinedName===Q)&&(w="collision"),!t.find(G=>G.combinedName===Q)){t.push({combinedName:Q,collision:!0});const G={x:D.x(),y:D.y(),z:D.z()},oe={x:N.x(),y:N.y(),z:N.z()};l.body.impact.push({impulse:k,point:G,normal:oe,name:d.name}),d.body.impact.push({impulse:k,point:G,normal:oe,name:l.name}),this.collisionEvents.emit("collision",{bodies:[l,d],event:w})}}k>=C&&(C=k,(y||A)&&(this.impactPoint.set(D.x(),D.y(),D.z()),this.impactNormal.set(N.x(),N.y(),N.z())));break}}if(!R||!x)continue;const V=2;if(this.emptyV3.set(0,0,0),l.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:y,physicsBody:c},d.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:A,physicsBody:u},y&&C>g&&l.fragmentDepth<V){const E=this.convexBreaker.subdivideByImpact(l,this.impactPoint,this.impactNormal,1,2),_=E.length;for(let O=0;O<_;O++){const k=c.getLinearVelocity(),D=c.getAngularVelocity(),N=E[O];N.userData.ammoPhysicsData.velocity.set(k.x(),k.y(),k.z()),N.userData.ammoPhysicsData.angularVelocity.set(D.x(),D.y(),D.z()),this.createDebrisFromBreakableObject(N,l)}this.objectsToRemove[this.numObjectsToRemove++]=l}if(A&&C>b&&d.fragmentDepth<V){const E=this.convexBreaker.subdivideByImpact(d,this.impactPoint,this.impactNormal,1,2),_=E.length;for(let O=0;O<_;O++){const k=u.getLinearVelocity(),D=u.getAngularVelocity(),N=E[O];N.userData.ammoPhysicsData.velocity.set(k.x(),k.y(),k.z()),N.userData.ammoPhysicsData.angularVelocity.set(D.x(),D.y(),D.z()),this.createDebrisFromBreakableObject(N,d)}this.objectsToRemove[this.numObjectsToRemove++]=d}}for(let o=0;o<this.numObjectsToRemove;o++)this.removeDebris(this.objectsToRemove[o]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(o=>{const{combinedName:a}=o;if(!t.find(r=>r.combinedName===a)){const r=a.split("__"),c=this.rigidBodies.find(d=>d.uuid===r[0]),u=this.rigidBodies.find(d=>d.uuid===r[1]),l="end";c&&u&&this.collisionEvents.emit("collision",{bodies:[c,u],event:l})}}),this.earlierDetectedCollisions=[...t]}setGravity(t=0,s=-9.8,e=0){this.tmpBtVector3.setValue(t,s,e),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){if(typeof Ammo>"u"){fe("Are you sure you included ammo.js?");return}typeof Ammo=="function"?Ammo().then(()=>{this.setup()}):this.setup()}get add(){return{collider:(t,s,e)=>this.collisionEvents.addCollider(t,s,e),constraints:this.constraints.addConstraints,existing:(t,s)=>this.addExisting(t,s),plane:(t={},s={})=>this.shapes.addPlane(t,s),sphere:(t={},s={})=>this.shapes.addSphere(t,s),ground:(t={},s={})=>this.shapes.addGround(t,s),box:(t={},s={})=>this.shapes.addBox(t,s),capsule:(t={},s={})=>this.shapes.addCapsule(t,s),cylinder:(t={},s={})=>this.shapes.addCylinder(t,s),cone:(t={},s={})=>this.shapes.addCone(t,s),torus:(t={},s={})=>this.shapes.addTorus(t,s),extrude:(t,s={})=>this.shapes.addExtrude(t,s),raycaster:(t="closest")=>t==="closest"?new qs(this):new Qs(this)}}prepareThreeObjectForCollisionShape(t,s={}){var r,c;const{autoCenter:e=!1}=s,n={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let i="unknown";const o=((r=t.geometry)==null?void 0:r.type)||"unknown";/box/i.test(o)?i="box":/cone/i.test(o)?i="cone":/cylinder/i.test(o)?i="cylinder":/extrude/i.test(o)?i="extrude":/plane/i.test(o)?i="plane":/sphere/i.test(o)?i="sphere":/torus/i.test(o)&&(i="torus");let a={...n,...(c=t==null?void 0:t.geometry)==null?void 0:c.parameters};if(s.shape?(a={...n,...s},i=s.shape):t.shape&&(i=t.shape),Object.keys(a).forEach(u=>{typeof a[u]>"u"&&n[u]&&(a[u]=n[u])}),e){if(t.isMesh&&t.geometry)t.geometry.center();else if(t.isGroup){const u=new Dt,l=new L;u.setFromObject(t).getCenter(l),t.traverse(d=>{d.isMesh&&d.geometry.translate(-l.x,-l.y,-l.z)})}}return i==="cylinder"&&(a.radius=s.radius||a.radiusTop),i==="extrude"&&(i="hacd"),(i==="mesh"||i==="convex")&&(i="convexMesh"),i==="concave"&&(i="concaveMesh"),i==="unknown"&&(fe(`Shape for ${t==null?void 0:t.name} not recognized! Will fallback to box.`),i="box"),{shape:i,params:a,object:t}}createCollisionShape(t,s,e){const n=e!=null&&e.quaternion?e==null?void 0:e.quaternion:new K(0,0,0,1),{axis:i="y"}=s,o=new Ammo.btVector3,a=e==null?void 0:e.geometry;e&&(a!=null&&a.isGeometry)&&(e.geometry=new Be().fromGeometry(a));const r=f=>{const y=new $().elements,A=[],g=[],b=[];return en(f,{},(M,x,R)=>{A.push(M),g.push(x),b.push(R)}),{vertices:A,matrices:g,indexes:b,matrixWorld:y}};let c={};this.complexShapes.indexOf(t)!==-1&&(c=r(e));let u;switch(t){case"box":o.setValue(s.width/2,s.height/2,s.depth/2),u=new Ammo.btBoxShape(o);break;case"sphere":u=new Ammo.btSphereShape(s.radius);break;case"cylinder":switch(i){case"y":o.setValue(s.radius,s.height/2,s.radius),u=new Ammo.btCylinderShape(o);break;case"x":o.setValue(s.height/2,s.radius,s.radius),u=new Ammo.btCylinderShapeX(o);break;case"z":o.setValue(s.radius,s.radius,s.height/2),u=new Ammo.btCylinderShapeZ(o);break}break;case"cone":switch(i){case"y":u=new Ammo.btConeShape(s.radius,s.height);break;case"x":u=new Ammo.btConeShapeX(s.radius,s.height);break;case"z":u=new Ammo.btConeShapeZ(s.radius,s.height);break}break;case"capsule":switch(i){case"y":u=new Ammo.btCapsuleShape(s.radius,s.height);break;case"x":u=new Ammo.btCapsuleShapeX(s.radius,s.height);break;case"z":u=new Ammo.btCapsuleShapeZ(s.radius,s.height);break}break;case"torus":u=Qn(s,n);break;case"plane":u=Re(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...s,concave:!1});break;case"hull":u=Js(c.vertices,c.matrices,c.matrixWorld,s);break;case"hacd":u=$s(c.vertices,c.matrices,c.indexes,c.matrixWorld,s);break;case"vhacd":u=Zs(c.vertices,c.matrices,c.indexes,c.matrixWorld,s);break;case"convexMesh":u=Re(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...s,concave:!1});break;case"concaveMesh":u=Re(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...s,concave:!0});break}Ammo.destroy(o);const{x:l,y:d,z:p}=s;return(l||d||p)&&(u._compoundOffset={x:l||0,y:d||0,z:p||0}),Array.isArray(u)&&(u=this.mergeCollisionShapesToCompoundShape(u)),u}mergeCollisionShapesToCompoundShape(t){const s=new Ammo.btCompoundShape;return t.forEach(e=>{const{_childOffset:n,_compoundOffset:i}=e;if(n){const{pos:o,quat:a,scale:r,margin:c}=n,u=this.applyPosQuatScaleMargin(e,o,a,r,c);s.addChildShape(u,e)}else if(i){const o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),s.addChildShape(o,e)}else{const o=new Ammo.btTransform;o.setIdentity(),s.addChildShape(o,e)}}),s}addExisting(t,s={}){const{hasBody:e}=t;if(e){fe(`Object "${t.name}" already has a physical body!`);return}const n=new L,i=new K,o=new L;t.getWorldPosition(n),t.getWorldQuaternion(i),t.getWorldScale(o);const a=(s.collisionFlags||0).toString(2).slice(-1)==="1",r=(s.collisionFlags||0).toString(2).slice(-2,-1)==="1",{shape:c="unknown",compound:u=[],mass:l=a||r?0:1,collisionFlags:d=0,collisionGroup:p=1,collisionMask:f=-1,offset:y=void 0,breakable:A=!1,addChildren:g=!0,margin:b=.01,ignoreScale:M=!1,fractureImpulse:x=1}=s;if(M&&o.set(1,1,1),u.length>=1){const E=u.map(D=>this.createCollisionShape(D.shape,D)),_=this.mergeCollisionShapesToCompoundShape(E),O=this.applyPosQuatScaleMargin(_,n,i,o,b),k=this.collisionShapeToRigidBody(_,O,l,r);this.addRigidBodyToWorld(t,k,d,p,f,y),t.body.breakable=A,t.body.fractureImpulse=x,t.body.ignoreScale=M;return}const R=[];if(c!=="unknown"||t.isMesh){const E=this.prepareThreeObjectForCollisionShape(t,s),_=this.createCollisionShape(E.shape,E.params,E.object);R.push(_)}if(c==="unknown"&&g&&t.children.length>=1&&t.children.forEach(E=>{if(E.isMesh){const _=this.prepareThreeObjectForCollisionShape(E),O=this.createCollisionShape(_.shape,_.params,_.object);O._childOffset={pos:E.position.clone(),quat:E.quaternion.clone(),scale:E.scale.clone(),margin:b},R.push(O)}}),R.length===0){const E=this.prepareThreeObjectForCollisionShape(t,s),_=this.createCollisionShape(E.shape,E.params,E.object);R.push(_)}const C=R.length===1?R[0]:this.mergeCollisionShapesToCompoundShape(R),w=this.applyPosQuatScaleMargin(C,n,i,o,b),V=this.collisionShapeToRigidBody(C,w,l,r);this.addRigidBodyToWorld(t,V,d,p,f,y),t.body.breakable=A,t.body.fractureImpulse=x,t.body.ignoreScale=M}addRigidBodyToWorld(t,s,e,n,i,o){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(s,n,i);const a=Object.values(s)[0];t.name||(t.name=`object-${t.id}`),s.name=t.name,t.body=new Xn(this,s),t.hasBody=!0,t.ptr=a,s.threeObject=t,o&&(t.body.offset={x:0,y:0,z:0,...o}),t.body.setCollisionFlags(e)}applyPosQuatScaleMargin(t,s=new L,e=new K,n=new L,i=.01){t.setMargin(i);const o=new Ammo.btQuaternion(0,0,0,1);o.setValue(e.x,e.y,e.z,e.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(s.x,s.y,s.z),a.setRotation(o),Ammo.destroy(o);const r=new Ammo.btVector3(n.x,n.y,n.z);return t.setLocalScaling(r),Ammo.destroy(r),a}collisionShapeToRigidBody(t,s,e,n){const i=new Ammo.btDefaultMotionState(s),o=new Ammo.btVector3(0,0,0);e>0&&t.calculateLocalInertia(e,o);const a=new Ammo.btRigidBodyConstructionInfo(e,i,t,o),r=new Ammo.btRigidBody(a);return(e>0||n)&&r.setActivationState(4),r}}const ti={style:{position:"relative",height:"400px"}},si=ye("div",{style:{position:"absolute",top:"0",left:"0",width:"100%",height:"100%",display:"flex","align-items":"center","justify-content":"center"}},[ye("div",{style:{background:"#ffffff",padding:"10px 20px"}},"Loading")],-1),ni={style:{position:"absolute",bottom:"0",right:"0"}},ci={__name:"scene-gltf",props:{scene:{type:String,default:""},scripts:{type:Array,default:()=>[]}},setup(m){console.clear();const t=tn(null),s=m;let e={reactive:ot({ready:!1,width:0,height:0,frame:0}),global:ot({}),el:null,scene:!1,camera:!1,clock:!1,renderer:!1,scripts:{},events:[],THREE:!1,getScriptInstance(n,i={}){const o=new(e.scripts[n]?e.scripts[n]:class{});o.keyboard={},o.input={},o.motor=e;for(let a in i)o[a]=o[a]||i[a];return o},sceneTraverseMethod(n,i=null){e.scene.traverse(o=>{Array.isArray(o.userData.scripts)&&o.userData.scripts.map(a=>{typeof a[n]=="function"&&a[n](i)})})},onMounted(){Jn("/assets/ammo",()=>{e.el=t.value,e.reactive.width=e.el.offsetWidth,e.reactive.height=e.el.offsetHeight,e.scene=new Gs,e.camera=new _t(50,e.reactive.width/e.reactive.height,1,1e3),e.clock=new zs,e.physics=new ei(e.scene),e.physics.debug.enable(),e.physics.debug.mode(1),e.renderer=new js({antialias:!0}),e.reactive.frame=0,e.THREE=Ks,e.el.appendChild(e.renderer.domElement),e.renderer.setSize(e.reactive.width,e.reactive.height),e.events.push([window,"resize",n=>{e.reactive.width=e.el.offsetWidth,e.reactive.height=e.el.offsetHeight,e.renderer.setSize(e.reactive.width,e.reactive.height)}]),s.scripts.map(n=>{e.scripts[n.name]=n}),new ln().load(s.scene,n=>{if(e.scene.userData.scripts=[],e.scripts.SceneScript){const i=e.getScriptInstance("SceneScript",{orbitControls:!1,gridHelper:!1,physicsDebug:!1,scene:e.scene});if(i.orbitControls&&(i.orbitControls=new Wn(e.camera,e.renderer.domElement),e.camera.position.set(0,20,100)),i.gridHelper){const o=Array.isArray(i.gridHelper)?i.gridHelper:[10,10];i.gridHelper=new Ws(o[0],o[1]),e.scene.add(i.gridHelper)}i.physicsDebug&&e.physics.debug,e.scene.userData.scripts.push(i)}e.scene.add(n.scene),n.scene.traverse(i=>{["script0","script1","script2","script3","script4","script5","script6","script7","script8","script9"].map(o=>{if(i.userData[o]){i.userData.scripts=[];const a=e.getScriptInstance(i.userData[o],{object:i});i.userData.scripts.push(a),delete i.userData[o],e.events.push([document,"keydown",r=>{a.keyboard[r.key]=!0,typeof a.onInput=="function"&&(a.input=a.onInput(a.keyboard))}]),e.events.push([document,"keyup",r=>{delete a.keyboard[r.key],typeof a.onInput=="function"&&(a.input=a.onInput(a.keyboard))}])}})}),e.reactive.ready=!0,window.sceneInterval&&clearInterval(window.sceneInterval),e.sceneTraverseMethod("onCreate"),window.sceneInterval=setInterval(()=>{e.scene.userData.scripts.map(i=>{i.orbitControls&&i.orbitControls.update(),i.physicsDebug&&e.physics.updateDebugger()}),e.sceneTraverseMethod("onUpdate"),e.physics.update(e.clock.getDelta()*1e3),e.renderer.render(e.scene,e.camera),e.reactive.frame++},1e3/60),e.events.map(([i,o,a])=>{i.addEventListener(o,a)})})})},onUnmounted(){e.events.map(([n,i,o])=>{n.removeEventListener(i,o)})}};return sn(e.onMounted),nn(e.onUnmounted),(n,i)=>(on(),rn("div",ti,[ye("div",{ref_key:"gameRef",ref:t,style:{height:"100%"}},null,512),Me(e).reactive.ready?at("",!0):rt(n.$slots,"loading",{key:0},()=>[si]),Me(e).reactive.ready?rt(n.$slots,"content",{key:1},()=>[an("Content")]):at("",!0),ye("pre",ni,"motor.global: "+cn(Me(e).global),1)]))}};export{Jn as P,ci as _};
