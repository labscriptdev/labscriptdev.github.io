import{j as Ut,a as sn,f as nn,o as on}from"./entry.2c28750c.js";import an from"gpu.js";var Zt={exports:{}};(function(tt,Qt){(function(F,E){E(Qt,an)})(Ut,function(F,E){function et(r){return Math.max(0,r)}function it(r,t){return r<=0?0:t}var di=Object.freeze({__proto__:null,activate:et,measure:it});function _t(r){return 1/(1+Math.exp(-r))}function Tt(r,t){return r*(1-r)*t}var fi=Object.freeze({__proto__:null,activate:_t,measure:Tt});function ut(r){return Math.tanh(r)}function lt(r,t){return(1-r*r)*t}var gi=Object.freeze({__proto__:null,activate:ut,measure:lt});function ct(r){return r>0?r:.01*r}function pt(r,t){return r>0?t:.01*t}var wi=Object.freeze({__proto__:null,activate:ct,measure:pt}),yi=Object.freeze({__proto__:null,relu:di,sigmoid:fi,tanh:gi,leakyRelu:wi});class Y{constructor(t){this.json={avgs:{error:0,iterations:0,testTime:0,trainTime:0},stats:{total:0,testSize:0,trainSize:0},sets:[]},this.initClassifier=t}testPartition(t,e,i){const s=this.initClassifier(),n=Date.now(),o=s.train(e,t),a=Date.now(),h=s.test(i),u=Date.now();return{...h,trainTime:a-n,testTime:u-a,iterations:o.iterations,error:o.error,total:h.total,network:s.toJSON()}}shuffleArray(t){for(let e=t.length-1;e>0;e--){const i=Math.floor(Math.random()*(e+1)),s=t[e];t[e]=t[i],t[i]=s}return t}train(t,e={},i=4){if(t.length<i)throw new Error(`Training set size is too small for ${t.length} k folds of ${i}`);this.shuffleArray(t);const s=t.length/i,n={trainTime:0,testTime:0,iterations:0,error:0},o={total:0,testSize:0,trainSize:0},a={total:0,testSize:0,trainSize:0,truePos:0,trueNeg:0,falsePos:0,falseNeg:0,precision:0,recall:0,accuracy:0},h=[];let u=null;for(let l=0;l<i;l++){const c=t.slice(0),p=c.splice(l*s,s),d=c,f=this.testPartition(e,d,p);u===null&&(u=f.hasOwnProperty("falseNeg")&&f.hasOwnProperty("falsePos")&&f.hasOwnProperty("trueNeg")&&f.hasOwnProperty("truePos"),u&&Object.assign(o,a)),n.iterations+=f.iterations,n.testTime+=f.testTime,n.trainTime+=f.trainTime,n.error+=f.error,o.total+=f.total,Y.isBinaryStats(o)&&Y.isBinaryPartitionResults(f)&&(o.accuracy+=f.accuracy,o.falseNeg+=f.falseNeg,o.falsePos+=f.falsePos,o.precision+=f.precision,o.recall+=f.recall,o.trueNeg+=f.trueNeg,o.truePos+=f.truePos),h.push(f)}return n.error/=i,n.iterations/=i,n.testTime/=i,n.trainTime/=i,Y.isBinaryStats(o)&&(o.precision=o.truePos/(o.truePos+o.falsePos),o.recall=o.truePos/(o.truePos+o.falseNeg),o.accuracy=(o.trueNeg+o.truePos)/o.total),o.testSize=s,o.trainSize=t.length-s,this.json={avgs:n,stats:o,sets:h},this.json}toNeuralNetwork(){return this.fromJSON(this.json)}toJSON(){return this.json}fromJSON(t){const e=t.sets.reduce((i,s)=>i.error<s.error?i:s);return this.initClassifier().fromJSON(e.network)}}Y.isBinaryStats=r=>r.accuracy!==void 0,Y.isBinaryResults=r=>r.stats.accuracy!==void 0,Y.isBinaryPartitionResults=r=>r.accuracy!==void 0;let Ft=null;function te(r){Ft=r}function y(r,t){let e=Ft;return e===null&&(e=new E.GPU({mode:"gpu"}),te(e)),e.createKernel(r,t).setPipeline(!0)}function dt(r,t,e){let i=Ft;return i===null&&(i=new E.GPU({mode:"gpu"}),te(i)),i.createKernelMap(r,t,e).setPipeline(!0)}function mi(r,t){return new E.Input(r,t)}function w(r){r instanceof E.Texture&&r.delete()}function Li(r){if(r instanceof E.Texture){r.clear();return}if(Array.isArray(r)){if(typeof r[0]=="number")r.fill(0);else if(typeof r[0][0]=="number"){for(let t=0;t<r.length;t++)r[t].fill(0);return}else if(typeof r[0][0][0]=="number"){for(let t=0;t<r.length;t++){const e=r[t];for(let i=0;i<e.length;i++)e[i].fill(0)}return}}if(r instanceof Float32Array){r.fill(0);return}throw new Error("unhandled value")}function R(r){if(r instanceof E.Texture)return r.clone();if(r instanceof Float32Array)return r.slice(0);if(Array.isArray(r)){if(typeof r[0]=="number")return r.slice(0);if(typeof r[0][0]=="number"){const t=new Array(r.length);for(let e=0;e<r.length;e++)t[e]=r[e].slice(0);return t}else if(typeof r[0][0][0]=="number"){const t=new Array(r.length);for(let e=0;e<r.length;e++){const i=r[e],s=new Array(i.length);for(let n=0;n<i.length;n++)s[n]=i[n].slice(0)}return t}}throw new Error("unhandled value")}function bi(r){let t=0;for(let e=0;e<this.constants.height;e++)for(let i=0;i<this.constants.width;i++)t+=r[e][i]**2;return t/this.constants.length}class ki{constructor({width:t,height:e}){this.calculate=y(bi,{output:[1],constants:{width:t,height:e,length:t*e},immutable:!0}),this.addAbsolute=y(function(i,s){return i[0]+Math.abs(s[0][0])},{output:[1],immutable:!0}),this.add=y(function(i,s){return i[0]+s[0]},{output:[1],immutable:!0}),this.divide=y(function(i,s){const n=s[0];return n>0?n/i:0},{output:[1],immutable:!0})}}const ft={width:1,height:1,depth:null,weights:null,deltas:null,praxis:null,praxisOpts:null,cleanupDeltas:!0};class N{constructor(t){this.praxis=null,this.predictKernel=null,this.compareKernel=null,t?this.settings={...ft,...t}:this.settings={...ft},this.setupPraxis()}get width(){var t;return(t=this.settings.width)!==null&&t!==void 0?t:0}get height(){var t;return(t=this.settings.height)!==null&&t!==void 0?t:0}get depth(){var t;return(t=this.settings.depth)!==null&&t!==void 0?t:0}get weights(){return this.settings.weights}set weights(t){this.settings.weights=t,this.settings.cleanupDeltas&&this.deltas&&Li(this.deltas)}get deltas(){return this.settings.deltas}set deltas(t){this.settings.deltas=t}get id(){var t;return(t=this.settings.id)!==null&&t!==void 0?t:""}set id(t){this.settings.id=t}setupPraxis(){const{initPraxis:t,praxis:e,praxisOpts:i}=this.settings;this.praxis||(t?i?this.praxis=t(this,i):this.praxis=t(this):e&&(this.praxis=e))}validate(){if(Number.isNaN(this.height))throw new Error(`${this.constructor.name} layer height is not a number`);if(Number.isNaN(this.width))throw new Error(`${this.constructor.name} layer width is not a number`);if(this.height<1)throw new Error(`${this.constructor.name} layer height is less than 1`);if(this.width<1)throw new Error(`${this.constructor.name} layer width is less than 1`)}setupKernels(t){}reuseKernels(t){if(t.width!==this.width)throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);if(t.height!==this.height)throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);if(t.hasOwnProperty("predictKernel")&&t.predictKernel!==null){if(!t.predictKernel.immutable)throw new Error(`${t.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);this.predictKernel=t.predictKernel}if(t.hasOwnProperty("compareKernel")&&t.compareKernel!==null){if(!t.compareKernel.immutable)throw new Error(`${t.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);this.compareKernel=t.compareKernel}this.praxis=t.praxis}predict(t){}compare(t){}learn(t){}toArray(){return Array.isArray(this.weights)?this.weights:this.weights.toArray()}toJSON(){return N.toJSON(this)}static toJSON(t){const{weights:e}=t;return{width:t.width,height:t.height,depth:t.depth,weights:xi(e&&e instanceof E.Texture?e.toArray():e),type:t.constructor.name,praxisOpts:t.praxis?t.praxis.toJSON():null}}}function xi(r){if(r===null)return null;if(Array.isArray(r)){if(typeof r[0]=="number")return r;if(Array.isArray(r[0])&&typeof r[0][0]=="number")return r;if(Array.isArray(r[0][0])&&typeof r[0][0][0]=="number")return r;if(r[0]instanceof Float32Array)return r.map(e=>Array.from(e));if(r[0][0]instanceof Float32Array)return r.map(e=>e.map(i=>Array.from(i)))}else if(r)return Array.from(r);throw new Error("unexpected value")}function M(r){return new Float32Array(r)}function z(r,t){const e=new Array(t);for(let i=0;i<t;i++)e[i]=M(r);return e}function J(r,t,e){const i=new Array(e);for(let s=0;s<e;s++)i[s]=z(r,t);return i}class rt extends N{constructor(t,e){super(e),this.inputLayer=t;const{width:i,height:s,depth:n}=this;this.predictKernel=null,this.compareKernel=null,this.validate(),n>0?(this.weights=J(i,s,n),this.deltas=J(i,s,n)):s>0&&(this.weights=z(i,s),this.deltas=z(i,s)),this.setupPraxis()}get width(){return this.inputLayer.width}get height(){return this.inputLayer.height}get depth(){return this.inputLayer.depth}}class st extends N{constructor(t,e){super(),this.settings=t,this.inputLayer=e}get width(){return this.inputLayer.width}get height(){return this.inputLayer.height}get depth(){return this.inputLayer.depth}get filterCount(){return this.settings.filterCount}get filterWidth(){return this.settings.filterWidth}get filterHeight(){return this.settings.filterHeight}get filters(){return this.settings.filters}set filters(t){this.settings.filters=t}get filterDeltas(){return this.settings.filterDeltas}set filterDeltas(t){this.settings.filterDeltas=t}}class gt{constructor(){this.predictKernel=null,this.compareKernel=null,this.praxis=null}get width(){return this.settings.width}get height(){return this.settings.height}get depth(){return this.settings.depth}get weights(){return this.settings.weights}set weights(t){this.settings.weights=t}get deltas(){return this.settings.deltas}set deltas(t){this.settings.deltas=t}toJSON(){return N.toJSON(this)}}class wt extends N{constructor(t,e){super({...e,width:t.width,height:t.height,depth:t.depth}),this.inputLayer=t}validate(){var t;if(super.validate(),this.width!==this.inputLayer.width)throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);if(this.height!==this.inputLayer.height)throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);if(this.depth!==((t=this.inputLayer.depth)!==null&&t!==void 0?t:0))throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`)}}class yt extends N{constructor(t,e,i){super(i),this.inputLayer1=t,this.inputLayer2=e,this.validate(),this.weights=z(this.width,this.height),this.deltas=z(this.width,this.height),this.setupPraxis()}}function Oi(r,t){return r[this.thread.y][this.thread.x]-t[this.thread.x]}function Si(r,t){return r[this.thread.y][this.thread.x]-t[this.thread.y][this.thread.x]}class mt extends N{constructor(t,e){if(super(t),this.inputLayer=e,this.validate(),this.depth)throw new Error("Target layer not implemented for depth");this.height?(this.weights=z(this.width,this.height),this.deltas=z(this.width,this.height),this.errors=z(this.width,this.height)):(this.weights=M(this.width),this.deltas=M(this.width),this.errors=M(this.width))}setupKernels(){this.width===1?this.compareKernel=y(Oi,{output:[this.width,this.height],immutable:!0}):this.compareKernel=y(Si,{output:[this.width,this.height],immutable:!0})}predict(){w(this.weights),this.weights=R(this.inputLayer.weights)}compare(t){w(this.deltas),w(this.errors),w(this.inputLayer.deltas),this.deltas=this.compareKernel(this.weights,t),this.inputLayer.deltas=R(this.deltas),this.errors=R(this.deltas)}setupPraxis(){}}function ee(r,t){return new mt(r,t)}class Kt{}class Nt extends N{}class V extends N{learn(t){const{weights:e}=this;if(!this.praxis)throw new Error("this.praxis not defined");this.weights=this.praxis.run(this,t),w(e)}}const k={toTable(r){const t=r.reduce((e,i)=>Object.assign(e,i),{});return k.toHash(t)},toTable2D(r){const t={};let e=0;for(let i=0;i<r.length;i++){const s=r[i];for(let n=0;n<s.length;n++){const o=s[n];for(const a in o)o.hasOwnProperty(a)&&!t.hasOwnProperty(a)&&(t[a]=e++)}}return t},toInputTable2D(r){const t={};let e=0;for(let i=0;i<r.length;i++){const s=r[i].input;for(let n=0;n<s.length;n++){const o=s[n];for(const a in o)!o.hasOwnProperty(a)||t.hasOwnProperty(a)||(t[a]=e++)}}return t},toOutputTable2D(r){const t={};let e=0;for(let i=0;i<r.length;i++){const s=r[i].output;for(let n=0;n<s.length;n++){const o=s[n];for(const a in o)!o.hasOwnProperty(a)||t.hasOwnProperty(a)||(t[a]=e++)}}return t},toHash(r){const t={};let e=0;const i=Object.keys(r);for(let s=0;s<i.length;s++)t[i[s]]=e++;return t},toArray(r,t,e){const i=new Float32Array(e);for(const s in r)!r.hasOwnProperty(s)||(i[r[s]]=t.hasOwnProperty(s)?t[s]:0);return i},toArrayShort(r,t){const e=[];for(const i in r)if(!!r.hasOwnProperty(i)){if(!t.hasOwnProperty(i))break;e[r[i]]=t[i]}return Float32Array.from(e)},toArrays(r,t,e){const i=[];for(let s=0;s<t.length;s++)i.push(this.toArray(r,t[s],e));return i},toObject(r,t){const e={};for(const i in r)!r.hasOwnProperty(i)||(e[i]=t[r[i]]);return e},toObjectPartial(r,t,e=0,i=0){const s={};let n=0;for(const o in r)!r.hasOwnProperty(o)||e>0&&n++<e||i>0&&n++>=i||(s[o]=t[r[o]-e]);return s},dataShape(r){const t=[];let e;r.hasOwnProperty("input")?(t.push("datum"),e=r.input):Array.isArray(r)?r[0]&&r[0].input?(t.push("array","datum"),e=r[0].input):Array.isArray(r[0])?(t.push("array"),e=r[0]):e=r:e=r;let i;for(;e;)if(i=Object.keys(e)[0],Array.isArray(e)||typeof e.buffer=="object"){t.push("array");const s=e[parseInt(i)];if(typeof s=="number"){t.push("number");break}else e=s}else if(typeof e=="object"&&typeof e.buffer!="object"){t.push("object");const s=e[i];if(typeof s=="number"){t.push("number");break}else e=s}else throw new Error("unhandled signature");return t},addKeys(r,t){if(Array.isArray(r))return t;let e=Object.keys(t).length;for(const i in r)!r.hasOwnProperty(i)||t.hasOwnProperty(i)||(t[i]=e++);return t}};class Ct{constructor(t,e={}){this.layerTemplate=t,this.settings={...e},this.kernel=null}get width(){return this.layerTemplate.width}get height(){return this.layerTemplate.height}get depth(){return this.layerTemplate.depth}setupKernels(){}reuseKernels(t){if(t.width!==this.width)throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);if(t.height!==this.height)throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);t.hasOwnProperty("kernel")&&(this.kernel=t.kernel)}toJSON(){return{...this.settings}}}function vi(r,t){return r[this.thread.y][this.thread.x]+this.constants.learningRate*t[this.thread.y][this.thread.x]}const Ai={learningRate:.3};class ie extends Ct{constructor(t,e){super(t),this.settings={...Ai,...e},this.kernel=null}run(t){return this.kernel(t.weights,t.deltas)}setupKernels(){this.kernel=y(vi,{output:[this.width,this.height],constants:{learningRate:this.settings.learningRate}})}}function re(r,t){return new ie(r,t)}function $i(r){return r}function Ii(r,t,e,i){const s=r[this.thread.y][this.thread.x],n=i[this.thread.y][0],o=t[this.thread.y][this.thread.x],a=e[this.thread.x][0],h=this.constants.learningRate*n*a+this.constants.momentum*s;return o+h}const Ei={learningRate:.3,momentum:.1,weightsLayer:null,incomingLayer:null,deltaLayer:null};class se extends Ct{constructor(t,e){super(t),this.kernelMap=null,this.settings={...Ei,...e},this.changes=z(t.width,t.height)}get learningRate(){return this.settings.learningRate}get momentum(){return this.settings.momentum}get weightsLayer(){return this.settings.weightsLayer}set weightsLayer(t){this.settings.weightsLayer=t}get deltaLayer(){return this.settings.deltaLayer}set deltaLayer(t){this.settings.deltaLayer=t}get incomingLayer(){return this.settings.incomingLayer}set incomingLayer(t){this.settings.incomingLayer=t}run(){const t=this.kernelMap(this.changes,this.weightsLayer.weights,this.incomingLayer.weights,this.deltaLayer.deltas);return this.changes=t.changes,t.result}setupKernels(){this.kernelMap=dt({changes:$i},Ii,{output:[this.width,this.height],constants:{learningRate:this.learningRate,momentum:this.momentum}})}}function ne(r,t){return new se(r,t)}function oe(r,t,e){return e*t+(1-t)*r*r}function ae(r,t,e){return r>t?t:r<e?e:r}function zi(r,t,e){const i=t[this.thread.y][this.thread.x],s=ae(i,this.constants.clipValue,-this.constants.clipValue),n=r[this.thread.y][this.thread.x],o=e[this.thread.y][this.thread.x],a=oe(i,this.constants.decayRate,o);return n+-this.constants.learningRate*s/Math.sqrt(a+this.constants.smoothEps)-this.constants.regularizationStrength*n}const Di={decayRate:.999,regularizationStrength:1e-6,learningRate:.01,smoothEps:1e-8,clipValue:5};class Rt extends Ct{constructor(t,e={}){super(t),this.kernelMap=null,this.settings={...Di,...e},this.momenta=z(t.width,t.height)}get clipValue(){return this.settings.clipValue}get decayRate(){return this.settings.decayRate}get learningRate(){return this.settings.learningRate}get regularizationStrength(){return this.settings.regularizationStrength}get smoothEps(){return this.settings.smoothEps}run(t){const{momenta:e,result:i}=this.kernelMap(t.weights,t.deltas,this.momenta);return w(this.momenta),this.momenta=e,i}setupKernels(){this.kernelMap=dt({momenta:oe},zi,{output:[this.width,this.height],constants:{clipValue:this.clipValue,decayRate:this.decayRate,learningRate:this.learningRate,regularizationStrength:this.regularizationStrength,smoothEps:this.smoothEps},functions:[ae],immutable:!0})}}function jt(r,t){return new Rt(r,t)}var Pi=Object.freeze({__proto__:null,ArthurDeviationBiases:ie,arthurDeviationBiases:re,ArthurDeviationWeights:se,arthurDeviationWeights:ne,MomentumRootMeanSquaredPropagation:Rt,momentumRootMeanSquaredPropagation:jt,MRmsProp:Rt,mRmsProp:jt});function vt(r,t){r.hasOwnProperty("inputLayer")?vt(r.inputLayer,t):(r.hasOwnProperty("inputLayer1")&&vt(r.inputLayer1,t),r.hasOwnProperty("inputLayer2")&&vt(r.inputLayer2,t)),t(r)}function he(r){const t=r.slice(0);for(let e=0;e<t.length;e++){let i=0;vt(t[e],s=>{t.includes(s)||(t.splice(e+i,0,s),i++)})}return t}function ue(r,t){if(r.width!==t.width)throw new Error(`Layer width mismatch of ${r.width} and ${t.width}`);if(r.height!==t.height)throw new Error(`Layer height mismatch of ${r.height} and ${t.height}`)}function Mi(r,t){return r[this.thread.y][this.thread.x]+t[this.thread.y][this.thread.x]}class le extends yt{get width(){return this.inputLayer1.width}get height(){return this.inputLayer1.height}get depth(){return this.inputLayer1.depth}validate(){super.validate(),ue(this.inputLayer1,this.inputLayer2)}setupKernels(){this.predictKernel=y(Mi,{output:[this.width,this.height],immutable:!0})}predict(){w(this.weights),this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){w(this.inputLayer1.deltas),w(this.inputLayer2.deltas),this.inputLayer1.deltas=R(this.deltas),this.inputLayer2.deltas=R(this.deltas)}}function A(r,t,e){return new le(r,t,e)}function ce(){return Math.random()*.4-.2}function nt(r,t){return Math.random()*(t-r)+r}function H(){if(H.returnV)return H.returnV=!1,H.vVal;const r=2*Math.random()-1,t=2*Math.random()-1,e=r*r+t*t;if(e===0||e>1)return H();const i=Math.sqrt(-2*Math.log(e)/e);return H.vVal=t*i,H.returnV=!0,r*i}function _i(r,t){return Math.floor(Math.random()*(t-r)+r)}function Ti(r,t){return r+H()*t}H.returnV=!1,H.vVal=0;var Fi=Object.freeze({__proto__:null,randomFloat:nt,gaussRandom:H,randomInteger:_i,randomN:Ti});function ot(r,t=null){const e=new Float32Array(r);if(t===null)for(let i=0;i<r;i++)e[i]=ce();else for(let i=0;i<r;i++)e[i]=nt(-t,t);return e}function Lt(r,t,e){const i=new Array(t);for(let s=0;s<t;s++)i[s]=ot(r,e);return i}function at(r,t,e,i){const s=new Array(e);for(let n=0;n<e;n++)s[n]=Lt(r,t,i);return s}const Ki={...ft,std:null};class pe extends V{constructor(t){super(),this.settings={...Ki,...t},this.setupPraxis(),this.validate(),this.weights||(this.weights=Lt(this.width,this.height,t.std)),this.deltas||(this.deltas=z(this.width,this.height))}predict(){}compare(){}}function $(r){return new pe(r)}function Ni(r,t){let e=0;for(let i=0;i<this.constants.size;i++)e+=r[this.thread.y][i]*t[i][this.thread.x];return e}function Ci(r,t,e){let i=t[this.thread.y][this.thread.x];for(let s=0;s<this.constants.size;s++)i+=r[this.thread.y][s]*e[this.thread.x][s];return i}function Ri(r,t,e){let i=t[this.thread.y][this.thread.x];for(let s=0;s<this.constants.size;s++)i+=r[s][this.thread.x]*e[s][this.thread.y];return i}class de extends yt{constructor(){super(...arguments),this.compareKernel1=null,this.compareKernel2=null}get width(){return this.inputLayer2.width}set width(t){throw new Error("Cannot set width on Multiply")}get height(){return this.inputLayer1.height}set height(t){throw new Error("Cannot set height on Multiply")}get depth(){return this.inputLayer1.depth}set depth(t){throw new Error("Cannot set depth on Multiply")}validate(){if(super.validate(),this.inputLayer1.width!==this.inputLayer2.height)throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`)}setupKernels(){this.predictKernel=y(Ni,{output:[this.width,this.height],constants:{size:this.inputLayer2.height},immutable:!0}),this.compareKernel1=y(Ci,{output:[this.inputLayer1.width,this.inputLayer1.height],constants:{size:this.inputLayer2.width},immutable:!0}),this.compareKernel2=y(Ri,{output:[this.inputLayer2.width,this.inputLayer2.height],constants:{size:this.inputLayer1.height},immutable:!0})}reuseKernels(t){super.reuseKernels(t),this.compareKernel1=t.compareKernel1,this.compareKernel2=t.compareKernel2}predict(){if(w(this.weights),!this.predictKernel)throw new Error("this.predictKernel is not set");this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){if(!this.compareKernel1)throw new Error("this.compareKernel1 not set");if(!this.compareKernel2)throw new Error("this.compareKernel2 not set");const t=this.inputLayer1.deltas,e=this.inputLayer2.deltas,i=this.compareKernel1(this.deltas,this.inputLayer1.deltas,this.inputLayer2.weights),s=this.compareKernel2(this.deltas,this.inputLayer2.deltas,this.inputLayer1.weights);this.inputLayer2.deltas=s,this.inputLayer1.deltas=i,w(t),w(e)}setupPraxis(){}toJSON(){return{...super.toJSON(),width:this.width,height:this.height}}}function D(r,t,e){return new de(r,t,e)}function ji(r){return 1/(1+Math.exp(-r[this.thread.y][this.thread.x]))}function Wi(r){return 1/(1+Math.exp(-r[this.thread.z][this.thread.y][this.thread.x]))}function Hi(r,t){const e=r[this.thread.y][this.thread.x],i=t[this.thread.y][this.thread.x];return e*(1-e)*i}function Bi(r,t){const e=r[this.thread.z][this.thread.y][this.thread.x],i=t[this.thread.z][this.thread.y][this.thread.x];return e*(1-e)*i}class fe extends rt{setupKernels(){this.depth>0?(this.predictKernel=y(Wi,{output:[this.width,this.height,this.depth],functions:[_t],immutable:!0}),this.compareKernel=y(Bi,{output:[this.width,this.height,this.depth],functions:[Tt],immutable:!0})):(this.predictKernel=y(ji,{output:[this.width,this.height],functions:[_t],immutable:!0}),this.compareKernel=y(Hi,{output:[this.width,this.height],functions:[Tt],immutable:!0}))}predict(){w(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){w(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}learn(t){}}function U(r,t){return new fe(r,t)}function qi(r,t){const{height:e}=r;function i(c,p){const d=ne(c,p);return d.setupKernels(),d}function s(c,p){const d=re(c,p);return d.setupKernels(),d}const n=$({id:"weights",height:e,width:t.height,initPraxis:i}),o=$({id:"biases",height:e,initPraxis:s}),a=D(n,t),h=A(a,o),u=U(h),l=n.praxis;return l.weightsLayer=n,l.incomingLayer=t,l.deltaLayer=u,u}function ge(r,t){if(typeof r.stride=="number")return{strideX:r.stride,strideY:r.stride};{let e=t.stride,i=t.stride;return typeof r.strideX=="number"&&(e=r.strideX),typeof r.strideY=="number"&&(i=r.strideY),{strideX:e,strideY:i}}}function we(r,t){if(typeof r.padding=="number")return{paddingX:r.padding,paddingY:r.padding};{let e=t.padding,i=t.padding;return typeof r.paddingX=="number"&&(e=r.paddingX),typeof r.paddingY=="number"&&(i=r.paddingY),{paddingX:e,paddingY:i}}}function ye(r,t){return new Float32Array(r).fill(t)}function Gi(r,t,e){const i=this.constants.paddingX-this.thread.x*this.constants.strideX,s=this.thread.x*this.constants.strideX-this.constants.paddingX,n=Math.min(this.constants.filterWidth,i+this.constants.inputWidth),o=this.constants.paddingY-this.thread.y*this.constants.strideY,a=this.thread.y*this.constants.strideY-this.constants.paddingY,h=Math.min(this.constants.filterHeight,o+this.constants.inputHeight);let u=0;for(let l=0;l<this.constants.inputDepth;l++)for(let c=Math.max(0,o),p=Math.max(0,a);c<h;c++,p++)for(let d=Math.max(0,i),f=Math.max(0,s);d<n;d++,f++)u+=t[l][c][d]*r[l][p][f];return u+e[this.thread.z]}function Xi(r,t,e){const i=Math.max(0,Math.ceil((this.constants.paddingX-this.thread.x)/this.constants.strideX)),s=i*this.constants.strideX+this.thread.x-this.constants.paddingX,n=Math.min(this.constants.deltaWidth,Math.floor((this.constants.inputWidth-1-this.thread.x+this.constants.paddingX)/this.constants.strideX)+1),o=Math.max(0,Math.ceil((this.constants.paddingY-this.thread.y)/this.constants.strideY)),a=o*this.constants.strideY+this.thread.y-this.constants.paddingY,h=Math.min(this.constants.deltaHeight,Math.floor((this.constants.inputHeight-1-this.thread.y+this.constants.paddingY)/this.constants.strideY)+1);let u=r[this.thread.z][this.thread.y][this.thread.x];for(let l=o,c=a;l<h;l++,c+=this.constants.strideY)for(let p=i,d=s;p<n;p++,d+=this.constants.strideX)u+=t[this.thread.z][c][d]*e[this.constants.deltaZ][l][p];return u}function Yi(r,t,e){const i=this.thread.x+this.constants.paddingX,s=i<this.constants.filterWidth?0:Math.floor((i-this.constants.filterWidth+this.constants.strideX)/this.constants.strideX),n=i-s*this.constants.strideX,o=Math.min(s+Math.floor(n/this.constants.strideX)+1,this.constants.deltaWidth),a=this.thread.y+this.constants.paddingY,h=a<this.constants.filterHeight?0:Math.floor((a-this.constants.filterHeight+this.constants.strideY)/this.constants.strideY),u=a-h*this.constants.strideY,l=Math.min(h+Math.floor(u/this.constants.strideY)+1,this.constants.deltaHeight);let c=r[this.thread.z][this.thread.y][this.thread.x],p=h;for(let d=u;p<l;d-=this.constants.strideY,p++){let f=s;for(let x=n;f<o;x-=this.constants.strideX,f++)c+=t[this.thread.z][d][x]*e[this.constants.deltaZ][p][f]}return c}function Ji(r,t){let e=0;for(let i=0;i<this.constants.deltaHeight;i++)for(let s=0;s<this.constants.deltaWidth;s++)e+=t[this.thread.z][i][s];return r[this.thread.z][this.thread.y][this.thread.x]+e}const Wt={stride:0,padding:0,bias:.1,filterCount:1,filterWidth:0,filterHeight:0};class me extends st{constructor(t,e){var i,s,n;super(t,e),this.compareFilterDeltasKernel=null,this.compareInputDeltasKernel=null,this.compareBiasesKernel=null,this.settings={...Wt,...t,...we(t,Wt),...ge(t,Wt)},this.weights=(i=t.weights)!==null&&i!==void 0?i:at(this.width,this.height,this.depth),this.deltas=J(this.width,this.height,this.depth),this.biases=ye(this.depth,this.bias),this.biasDeltas=(s=t.biasDeltas)!==null&&s!==void 0?s:ot(this.depth),this.filters=(n=t.filters)!==null&&n!==void 0?n:at(this.filterWidth,this.filterHeight,this.filterCount),this.filterDeltas=J(this.filterWidth,this.filterHeight,this.filterCount),this.validate()}get strideX(){return this.settings.strideX}get strideY(){return this.settings.strideY}get paddingX(){return this.settings.paddingX}get paddingY(){return this.settings.paddingX}get width(){return Math.floor((this.inputLayer.width+this.paddingX*2-this.filterWidth)/this.strideX+1)}get height(){return Math.floor((this.inputLayer.height+this.paddingY*2-this.filterHeight)/this.strideY+1)}get bias(){return this.settings.bias}get depth(){return this.filterCount}get biases(){return this.settings.biases}set biases(t){this.settings.biases=t}get biasDeltas(){return this.settings.biasDeltas}set biasDeltas(t){this.settings.biasDeltas=t}get filters(){return this.settings.filters}set filters(t){this.settings.filters=t}get filterDeltas(){return this.settings.filterDeltas}set filterDeltas(t){this.settings.filterDeltas=t}setupKernels(){this.predictKernel=y(Gi,{constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,inputDepth:this.inputLayer.depth,strideX:this.strideX,strideY:this.strideY,paddingX:this.paddingX,paddingY:this.paddingY,filterWidth:this.filterWidth,filterHeight:this.filterHeight},output:[this.width,this.height,this.depth],immutable:!0}),this.compareFilterDeltasKernel=y(Xi,{constants:{deltasWidth:this.width,deltasHeight:this.height,deltasDepth:this.depth,inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,inputDepth:this.inputLayer.depth,strideX:this.strideX,strideY:this.strideY,paddingX:this.paddingX,paddingY:this.paddingY,filterWidth:this.filterWidth,filterHeight:this.filterHeight},output:[this.width,this.height,this.depth],immutable:!0}),this.compareInputDeltasKernel=y(Yi,{constants:{filterCount:this.filterCount},output:[this.inputLayer.width,this.inputLayer.height,this.inputLayer.depth],immutable:!0}),this.compareBiasesKernel=y(Ji,{output:[1,1,this.depth],constants:{deltaWidth:this.width,deltaHeight:this.height},immutable:!0})}predict(){this.weights=this.predictKernel(this.inputLayer.weights,this.filters,this.biases)}compare(){const{filterDeltas:t,biasDeltas:e}=this;this.filterDeltas=this.compareFilterDeltasKernel(t,this.inputLayer.weights,this.deltas),w(t),this.biasDeltas=this.compareBiasesKernel(e,this.deltas),w(e),w(this.deltas),this.deltas=this.compareInputDeltasKernel(this.filters,this.inputLayer.deltas),w(this.inputLayer.deltas),this.inputLayer.deltas=R(this.deltas)}learn(t){const{weights:e}=this;this.weights=this.praxis.run(this,t),w(e)}}function Vi(r,t){return new me(r,t)}function Ui(r){return r}function Zi(r){return Math.random()<this.constants.probability?0:r[this.thread.y][this.thread.x]}function Qi(r){return r[this.thread.y][this.thread.x]*this.constants.probability}function tr(r,t){return r[this.thread.y][this.thread.x]===0?0:t[this.thread.y][this.thread.x]}const er={...ft,probability:.5};class Le extends st{constructor(t,e){super(e,t),this.predictKernelMap=null,this.settings={...er,...e},this.dropouts=null,this.validate()}setupKernels(t){const e=[this.width,this.height];t?(this.predictKernelMap=dt({dropouts:Ui},Zi,{output:e,immutable:!0}),this.compareKernel=y(tr,{output:e,immutable:!0})):this.predictKernelMap=dt({},Qi,{output:e,immutable:!0})}predict(){w(this.weights),this.dropouts&&w(this.dropouts);const{result:t,dropouts:e}=this.predictKernelMap(this.inputLayer.weights);this.weights=t,this.dropouts=e}compare(){w(this.deltas),this.deltas=this.compareKernel(this.dropouts,this.inputLayer.deltas)}}function ir(r,t){return new Le(r,t)}function rr(r,t){const{height:e,praxisOpts:i=null}=r,s=$({id:"weights",height:e,width:t.height,praxisOpts:i}),n=$({id:"biases",height:e,praxisOpts:i});return U(A(D(s,t,{praxisOpts:i}),n,{praxisOpts:i}),{praxisOpts:i})}function sr(r,t,e){let i=0,s=0;for(let n=0;n<this.constants.inputHeight;n++)for(let o=0;o<this.constants.inputWidth;o++)i+=r[n][o]*t[this.thread.x][s],s++;return i+e[this.thread.x]}function nr(r,t,e){let i=0,s=0;for(let n=0;n<this.constants.inputDepth;n++)for(let o=0;o<this.constants.inputHeight;o++)for(let a=0;a<this.constants.inputWidth;a++)i+=r[n][o][a]*t[this.thread.x][s],s++;return i+e[this.thread.x]}function or(r,t,e){let i=0;const s=this.thread.x+this.thread.y*this.output.x;for(let n=0;n<this.constants.filterCount;n++)i+=e[n][s]*t[0][n];return i+r[this.thread.y][this.thread.x]}function ar(r,t,e){let i=0;const s=this.thread.x+this.thread.y*this.output.x;for(let n=0;n<this.constants.filterCount;n++)i+=e[n][s]*t[0][n];return i+r[this.thread.z][this.thread.y][this.thread.x]}function hr(r,t){return r[this.thread.x]+t[this.thread.y][this.thread.x]}function ur(r,t,e){return r[this.thread.y][this.thread.x]+t[this.thread.y][this.thread.x]*e[this.constants.deltaY][this.constants.deltaX]}function lr(r,t,e){const i=Math.floor(this.thread.x/(this.constants.inputWidth*this.constants.inputHeight)),s=Math.floor((this.thread.x-i*this.constants.inputWidth*this.constants.inputHeight)/this.constants.inputWidth),n=this.thread.x-this.constants.inputWidth*(s+this.constants.inputHeight*i);return r[this.thread.y][this.thread.x]+t[i][s][n]*e[0][this.thread.y]}class be extends st{constructor(t,e){super(t,e),this.compareFilterDeltasKernel=null,this.compareInputDeltasKernel=null,this.compareBiasesKernel=null,this.settings={...t},this.validate();const i=e.width*e.height*e.depth;this.biases=ye(this.height,this.bias),this.biasDeltas=M(this.height),this.filters=Lt(i,this.height),this.filterDeltas=z(i,this.height),this.depth>0?(this.weights=at(this.width,this.height,this.depth),this.deltas=J(this.width,this.height,this.depth)):this.height>0&&(this.weights=Lt(this.width,this.height),this.deltas=z(this.width,this.height))}get bias(){return this.settings.bias}get biases(){return this.settings.biases}set biases(t){this.settings.biases=t}get biasDeltas(){return this.settings.biases}set biasDeltas(t){this.settings.biasDeltas=t}validate(){if(super.validate(),this.depth>0)throw new Error("depth not supported")}setupKernels(){const{inputLayer:t}=this,e=t.width*t.height*t.depth;t.depth>0?(this.predictKernel=y(nr,{output:[this.width,this.height],constants:{inputHeight:t.height,inputWidth:t.width,inputDepth:t.depth}}),this.compareFilterDeltasKernel=y(lr,{output:[e,this.height],constants:{inputWidth:t.width,inputHeight:t.height},immutable:!0}),this.compareInputDeltasKernel=y(ar,{output:[t.width,t.height,t.depth],constants:{filterCount:this.height},immutable:!0})):(this.predictKernel=y(sr,{output:[this.width,this.height],constants:{inputHeight:t.height,inputWidth:t.width}}),this.compareFilterDeltasKernel=y(ur,{output:[e,this.height],constants:{inputWidth:t.width}}),this.compareInputDeltasKernel=y(or,{output:[t.width,t.height],constants:{filterCount:this.height}})),this.compareBiasesKernel=y(hr,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights,this.filters,this.biases)}compare(){const t=this.inputLayer.deltas;this.inputLayer.deltas=this.compareInputDeltasKernel(t,this.deltas,this.filters),w(t);const{biasDeltas:e,filterDeltas:i}=this;this.biasDeltas=this.compareBiasesKernel(this.biases,this.deltas),this.filterDeltas=this.compareFilterDeltasKernel(i,this.inputLayer.weights,this.deltas),w(e),w(i)}}function cr(r,t){return new be(r,t)}function pr(r){return-r[this.thread.y][this.thread.x]}class ke extends wt{constructor(t,e){super(t,e),this.validate()}setupKernels(){this.predictKernel=y(pr,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights)}}function xe(r,t){return new ke(r,t)}function dr(r,t){return r[this.thread.y][this.thread.x]*t[this.thread.y][this.thread.x]}function fr(r,t){return r[this.thread.y][this.thread.x]*t[this.thread.y][this.thread.x]}class Oe extends yt{get width(){return this.inputLayer1.width}get height(){return this.inputLayer1.height}get depth(){return this.inputLayer1.depth}validate(){super.validate(),ue(this.inputLayer1,this.inputLayer2)}setupKernels(){this.predictKernel=y(dr,{output:[this.width,this.height],immutable:!0}),this.compareKernel=y(fr,{output:[this.width,this.height],immutable:!0})}predict(){w(this.weights),this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){w(this.inputLayer1.deltas),w(this.inputLayer2.deltas),this.inputLayer1.deltas=this.compareKernel(this.inputLayer2.weights,this.deltas),this.inputLayer2.deltas=this.compareKernel(this.inputLayer1.weights,this.deltas)}}function Q(r,t,e){return new Oe(r,t,e)}function Se(r){return new Float32Array(r).fill(1)}function ve(r,t){const e=new Array(t);for(let i=0;i<t;i++)e[i]=Se(r);return e}class Ae extends V{constructor(t){super(t),this.validate(),this.weights=ve(this.width,this.height),this.deltas=z(this.width,this.height)}}function $e(r){return new Ae(r)}function gr(r){return ut(r[this.thread.y][this.thread.x])}function wr(r){return ut(r[this.thread.z][this.thread.y][this.thread.x])}function yr(r,t){return lt(r[this.thread.y][this.thread.x],t[this.thread.y][this.thread.x])}function mr(r,t){return lt(r[this.thread.z][this.thread.y][this.thread.x],t[this.thread.z][this.thread.y][this.thread.x])}class Ie extends rt{setupKernels(){this.depth>0?(this.predictKernel=y(wr,{output:[this.width,this.height,this.depth],functions:[ut],immutable:!0}),this.compareKernel=y(mr,{output:[this.width,this.height,this.depth],functions:[lt],immutable:!0})):(this.predictKernel=y(gr,{output:[this.width,this.height],functions:[ut],immutable:!0}),this.compareKernel=y(yr,{output:[this.width,this.height],functions:[lt],immutable:!0}))}predict(){w(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){w(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}}function At(r,t){return new Ie(r,t)}class Ee extends V{constructor(t){super(t),this.validate(),this.weights=z(this.width,this.height),this.deltas=z(this.width,this.height)}predict(){}compare(){}}function G(r){return new Ee(r)}function Lr(r,t,e){const{height:i}=r,s=$({height:i,width:e.height}),n=$({width:i,height:i}),o=G({height:i}),a=U(A(A(D(s,e),D(n,t)),o)),h=$({height:i,width:e.height}),u=$({width:i,height:i}),l=G({height:i}),c=U(A(A(D(h,e),D(u,t)),l)),p=$({height:i,width:e.height}),d=$({width:i,height:i}),f=G({height:i}),x=At(A(A(D(p,e),D(d,Q(c,t))),f));return A(Q(A($e({width:a.width,height:a.height}),xe(a)),x),Q(t,a))}const br={weights:null};class ze extends Nt{constructor(t){super({...br,...t}),this.reshapeInput=null,this.validate(),this.reshapeInput=null,this.deltas=z(this.width,this.height)}setupKernels(){this.width===1&&(this.predict=this.predict1D,this.reshapeInput=y(function(t){return t[this.thread.y]},{output:[1,this.height],immutable:!0}))}reuseKernels(t){this.reshapeInput=t.reshapeInput}predict(t){if((Array.isArray(t)||t instanceof Float32Array)&&typeof t[0]=="number"&&t.length===this.height*this.width)w(this.weights),this.weights=mi(t,[this.width,this.height]);else if(Array.isArray(t)&&t.length===this.height&&(Array.isArray(t[0])||t[0]instanceof Float32Array)&&t[0].length===this.width)this.weights=R(t);else throw new Error("Inputs are not of sized correctly")}predict1D(t){this.weights&&w(this.weights),this.reshapeInput?this.weights=this.reshapeInput(t):this.weights=t}compare(){}learn(){}}function kr(r){return new ze(r)}function xr(r){return ct(r[this.thread.y][this.thread.x])}function Or(r){return ct(r[this.thread.z][this.thread.y][this.thread.x])}function Sr(r,t){return pt(r[this.thread.y][this.thread.x],t[this.thread.y][this.thread.x])}function vr(r,t){return pt(r[this.thread.z][this.thread.y][this.thread.x],t[this.thread.z][this.thread.y][this.thread.x])}class De extends rt{setupKernels(){const{width:t,height:e,depth:i}=this.inputLayer;this.depth>0?(this.predictKernel=y(Or,{output:[t,e,i],functions:[ct],immutable:!0}),this.compareKernel=y(vr,{output:[t,e,i],functions:[pt],immutable:!0})):(this.predictKernel=y(xr,{output:[t,e],functions:[ct],immutable:!0}),this.compareKernel=y(Sr,{output:[t,e],functions:[pt],immutable:!0}))}predict(){w(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){const{deltas:t}=this;this.deltas=this.compareKernel(this.weights,t),w(t)}}function Ar(r,t){return new De(r,t)}function $r(r,t,e){const{height:i}=r;if(typeof i!="number")throw new Error("no settings.height given");e.setDimensions&&e.setDimensions(1,i);const s=$({width:t.height,height:i,std:.08,id:"inputGateWeights"}),n=$({width:i,height:i,std:.08,id:"inputGatePeepholes"}),o=G({width:1,height:i,id:"inputGateBias"}),a=U(A(A(D(s,t),D(n,e)),o),{id:"inputGate"}),h=$({width:t.height,height:i,std:.08,id:"forgetGateWeights"}),u=$({width:i,height:i,std:.08,id:"forgetGatePeepholes"}),l=G({width:1,height:i,id:"forgetGateBias"}),c=U(A(A(D(h,t),D(u,e)),l),{id:"forgetGate"}),p=$({width:t.height,height:i,std:.08,id:"outputGateWeights"}),d=$({width:i,height:i,std:.08,id:"outputGatePeepholes"}),f=G({width:1,height:i,id:"outputGateBias"}),x=U(A(A(D(p,t),D(d,e)),f),{id:"outputGate"}),g=$({width:t.height,height:i,std:.08,id:"memoryWeights"}),O=$({width:i,height:i,std:.08,id:"memoryPeepholes"}),m=G({width:1,height:i,id:"memoryBias"}),v=At(A(A(D(g,t),D(O,e)),m),{id:"memory"}),_=Q(c,e,{id:"retainCell"}),T=Q(a,v,{id:"writeCell"}),St=A(_,T,{id:"cell"});return Q(x,At(St),{id:"activations"})}function Ir(r,t){const{height:e}=r,i=$({height:e,width:t.height,id:"outputGate",std:.08}),s=$({height:e,id:"output",std:.08}),n=D(i,t,{id:"outputGateConnected"});return ee({id:"target",...r},A(n,s))}function Er(r){return r}function zr(r){return r}function Dr(r){const t=this.constants.paddingX-this.thread.x*this.constants.strideX,e=this.thread.x*this.constants.strideX-this.constants.paddingX,i=Math.min(this.constants.filterWidth,t+this.constants.inputWidth),s=this.constants.paddingY-this.thread.y*this.constants.strideY,n=this.thread.y*this.constants.strideY-this.constants.paddingY,o=Math.min(this.constants.filterHeight,s+this.constants.inputHeight);let a=-99999;for(let h=Math.max(0,s),u=Math.max(0,n);h<o;h++,u++)for(let l=Math.max(0,t),c=Math.max(0,e);l<i;l++,c++)if(u>=0&&u<this.constants.inputHeight&&c>=0&&c<this.constants.inputWidth){const p=r[this.thread.z][u][c];p>a&&(a=p)}return a}function Pr(r,t,e){const i=Math.floor(this.thread.x/this.output.x*this.constants.outputWidth),s=Math.floor(this.thread.y/this.output.y*this.constants.outputHeight);let n=0;for(let o=0;o<this.constants.inputHeight;o++)for(let a=0;a<this.constants.inputWidth;a++){const h=e[o][a],u=t[o][a];h===i&&u===s&&(n+=r[o][a])}return n}const Pe={padding:0,stride:0,filterWidth:0,filterHeight:0,filterCount:0};class Me extends st{constructor(t,e){super(t,e),this.predictKernelMap=null,this.settings={...t,...ge(t,Pe),...we(t,Pe)},this.weights=at(this.width,this.height,this.depth),this.deltas=J(this.width,this.height,this.depth),this.filters=at(this.filterWidth,this.filterHeight,this.filterCount),this.filterDeltas=J(this.filterWidth,this.filterHeight,this.filterCount),this.validate()}get strideX(){return this.settings.strideX}get strideY(){return this.settings.strideY}get paddingX(){return this.settings.paddingX}get paddingY(){return this.settings.paddingY}get width(){return Math.floor((this.inputLayer.width+this.paddingX*2-this.filterWidth)/this.strideX+1)}get height(){return Math.floor((this.inputLayer.height+this.paddingY*2-this.filterHeight)/this.strideY+1)}get depth(){return this.settings.filterCount}get filterCount(){return this.settings.filterCount}get switchX(){return this.settings.switchX}set switchX(t){this.settings.switchX=t}get switchY(){return this.settings.switchY}set switchY(t){this.settings.switchY=t}setupKernels(){this.predictKernelMap=dt({switchX:zr,switchY:Er},Dr,{output:[this.width,this.height,this.depth],constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,paddingX:this.paddingX,paddingY:this.paddingY,filterHeight:this.filterHeight,filterWidth:this.filterWidth}}),this.compareKernel=y(Pr,{output:[this.inputLayer.width,this.inputLayer.height,this.inputLayer.depth],constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,outputWidth:this.width,outputHeight:this.height}})}predict(){const{result:t,switchX:e,switchY:i}=this.predictKernelMap(this.inputLayer.weights);this.switchX=e,this.switchY=i,this.weights=t}compare(){const t=this.inputLayer.deltas;this.inputLayer.deltas=this.compareKernel(this.deltas,this.switchX,this.switchY),w(t)}}function Mr(r,t){return new Me(r,t)}class $t extends gt{constructor(t){super(),this.praxis=null,this.predictKernel=null,this.compareKernel=null,this.settings={},this.recurrentInput=t,this.validate()}get width(){return this.recurrentInput.width}get height(){return this.recurrentInput.height}get depth(){return this.recurrentInput.depth}get deltas(){return this.recurrentInput.deltas}set deltas(t){const e=this.recurrentInput.deltas;this.recurrentInput.deltas=t,w(e)}get weights(){return this.recurrentInput.weights}set weights(t){const e=this.recurrentInput.weights;this.recurrentInput.weights=t,w(e)}validate(){if(N.prototype.validate.call(this),this.width!==this.recurrentInput.width)throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);if(this.height!==this.recurrentInput.height)throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`)}setDimensions(t,e){this.recurrentInput.width=t,this.recurrentInput.height=e}predict(){}compare(){}learn(){}setupKernels(){}reuseKernels(){}}class It extends gt{constructor(t){super(),this.praxis=null,this.settings={},this.predictKernel=null,this.compareKernel=null,t&&(this.settings={...t})}setDimensions(t,e){this.praxis=null,this.settings={...this.settings,width:t,height:e,weights:z(t,e),deltas:z(t,e)}}setupKernels(){}reuseKernels(){}predict(){}compare(){}learn(t){const{weights:e}=this;this.weights=this.praxis.run(this,t),w(e)}}function _e(){return new It}function _r(r){return et(r[this.thread.y][this.thread.x])}function Tr(r,t){return it(r[this.thread.y][this.thread.x],t[this.thread.y][this.thread.x])}function Fr(r){return et(r[this.thread.z][this.thread.y][this.thread.x])}function Kr(r,t){return it(r[this.thread.z][this.thread.y][this.thread.x],t[this.thread.z][this.thread.y][this.thread.x])}class Te extends rt{setupKernels(){const{width:t,height:e,depth:i}=this.inputLayer;i>0?(this.predictKernel=y(Fr,{output:[t,e,i],functions:[et],immutable:!0}),this.compareKernel=y(Kr,{output:[t,e,i],functions:[it],immutable:!0})):(this.predictKernel=y(_r,{output:[t,e],functions:[et],immutable:!0}),this.compareKernel=y(Tr,{output:[t,e],functions:[it],immutable:!0}))}predict(){w(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){w(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}}function Fe(r,t){return new Te(r,t)}function Nr(r,t,e){const{height:i}=r;if(typeof i!="number")throw new Error("height not set");e.setDimensions&&e.setDimensions(1,i);const s=$({id:"weight",height:i,width:t.height,std:.08}),n=$({id:"transition",height:i,width:i,std:.08}),o=G({id:"bias",height:i});return Fe(A(A(D(s,t),D(n,e)),o))}class Ke extends N{constructor(t,e){super(t),this.inputLayer=e,this.validate()}predict(){w(this.weights),this.weights=R(this.inputLayer.weights)}learn(){}}function Cr(r,t){return new Ke(r,t)}function Rr(r){let t=-1/0;for(let e=0;e<this.constants.inputHeight;e++)for(let i=0;i<this.constants.inputWidth;i++){const s=r[e][i];s>t&&(t=s)}return t}function jr(r){let t=-1/0;for(let e=0;e<this.constants.inputDepth;e++)for(let i=0;i<this.constants.inputHeight;i++)for(let s=0;s<this.constants.inputWidth;s++){const n=r[e][i][s];n>t&&(t=n)}return t}function Wr(r){let t=0;for(let e=0;e<this.constants.inputHeight;e++)for(let i=0;i<this.constants.inputWidth;i++)t+=r[e][i];return t}function Hr(r){let t=0;for(let e=0;e<this.constants.inputDepth;e++)for(let i=0;i<this.constants.inputHeight;i++)for(let s=0;s<this.constants.inputWidth;s++)t+=r[e][i][s];return t}function Br(r,t){return Math.exp(r[this.thread.x]-t[0])}function qr(r,t){return Math.exp(r[this.thread.z][this.thread.y][this.thread.x]-t[0])}function Gr(r,t){return r[this.thread.y][this.thread.x]/t[0]}function Xr(r,t){return r[this.thread.z][this.thread.y][this.thread.x]/t[0]}function Yr(r,t){let e=0;return this.thread.x+this.thread.y*this.output.x===r&&(e=1),-(e-t[this.thread.y][this.thread.x])}function Jr(r,t){let e=0;return this.thread.x+this.thread.y*this.output.x+this.thread.z*this.output.x*this.output.y===r&&(e=1),-(e-t[this.thread.z][this.thread.y][this.thread.x])}class Ne extends wt{constructor(t,e){super(t,e),this.errors=null,this.getExponentialsKernel=null,this.getMaxValueKernel=null,this.getSumKernel=null,this.validate(),this.depth>0?(this.weights=at(this.width,this.height,this.depth),this.deltas=J(this.width,this.height,this.depth)):this.height>0?(this.weights=Lt(this.width,this.height),this.deltas=z(this.width,this.height)):(this.weights=ot(this.width),this.deltas=M(this.width))}setupKernels(){const{width:t,height:e,depth:i}=this;i>0?(this.getExponentialsKernel=y(qr,{output:[t,e,i]}),this.getMaxValueKernel=y(jr,{output:[1,1,1],constants:{inputWidth:t,inputHeight:e,inputDepth:i}}),this.getSumKernel=y(Hr,{output:[1,1,1],constants:{inputWidth:t,inputHeight:e,inputDepth:i}}),this.predictKernel=y(Xr,{output:[t,e,i]}),this.compareKernel=y(Jr,{output:[t,e,i],immutable:!0})):(this.getExponentialsKernel=y(Br,{output:[t,e]}),this.getMaxValueKernel=y(Rr,{output:[1,1],constants:{inputWidth:t,inputHeight:e}}),this.getSumKernel=y(Wr,{output:[1,1],constants:{inputWidth:t,inputHeight:e}}),this.predictKernel=y(Gr,{output:[t,e]}),this.compareKernel=y(Yr,{output:[t,e],immutable:!0}))}predict(){const t=this.getMaxValueKernel(this.inputLayer.weights),e=this.getExponentialsKernel(this.inputLayer.weights,t),i=this.getSumKernel(e);this.weights=this.predictKernel(e,i)}compare(t){const{deltas:e,errors:i}=this;this.errors=this.compareKernel(t[0],e),this.deltas=R(this.errors),w(e),w(i);const s=this.inputLayer.deltas;this.inputLayer.deltas=R(this.deltas),w(s)}}function Vr(r,t){return new Ne(r,t)}class Ce extends N{constructor(t,e){super(e),this.inputLayer=t}predict(){w(this.weights),this.weights=R(this.inputLayer.weights),this.validate()}learn(){}}function Ur(r,t){return new Ce(r,t)}function Re(r){return r[this.thread.x][this.thread.y]}const Zr=Re;class je extends wt{get width(){return this.inputLayer.height}get height(){return this.inputLayer.width}constructor(t){super(t),this.validate()}setupKernels(){this.predictKernel=y(Re,{output:[this.height,this.width]}),this.compareKernel=y(Zr,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights)}compare(){this.inputLayer.deltas=this.compareKernel(this.deltas)}}function Qr(r){return new je(r)}const B={Activation:rt,Internal:gt,InternalModel:Kt,EntryPoint:Nt,Filter:st,Model:V,Modifier:wt,Operator:yt,Target:mt};var Ht=Object.freeze({__proto__:null,layerTypes:B,Add:le,add:A,arthurFeedForward:qi,BaseLayer:N,baseLayerDefaultSettings:ft,Convolution:me,convolution:Vi,Dropout:Le,dropout:ir,feedForward:rr,FullyConnected:be,fullyConnected:cr,gru:Lr,Input:ze,input:kr,LeakyRelu:De,leakyRelu:Ar,lstmCell:$r,Multiply:de,multiply:D,MultiplyElement:Oe,multiplyElement:Q,Negative:ke,negative:xe,Ones:Ae,ones:$e,output:Ir,Pool:Me,pool:Mr,Random:pe,random:$,RecurrentInput:$t,RecurrentZeros:It,rnnCell:Nr,Regression:Ke,regression:Cr,Relu:Te,relu:Fe,Sigmoid:fe,sigmoid:U,SoftMax:Ne,softMax:Vr,SVM:Ce,svm:Ur,Tanh:Ie,tanh:At,Target:mt,target:ee,Transpose:je,transpose:Qr,Zeros:Ee,zeros:G});const ts=Object.keys(Ht);function Z(r,t,e){if(!ts.find(s=>s===r.type))return null;const i=Ht[r.type];if(i.prototype instanceof B.Filter){if(!t)throw new Error("inputLayer missing");return new i(r,t)}else if(i.prototype instanceof B.Activation||i.prototype instanceof B.Modifier){if(!t)throw new Error("inputLayer missing");return new i(t,r)}else{if(i.prototype instanceof B.Internal)return new i(r);if(i.prototype instanceof B.Operator){if(!t)throw new Error("inputLayer1 missing");if(!e)throw new Error("inputLayer2 missing");return new i(t,e,r)}else{if(i.prototype instanceof B.InternalModel||i.prototype instanceof B.EntryPoint||i.prototype instanceof B.Model)return new i(r);if(i===mt){if(!t)throw new Error("inputLayer missing");return new i(r,t)}}}return null}class X{constructor(t,e){this.prop=null,this.table={},this.length=0;const i=this.table;if(e){this.prop=e;for(let s=0;s<t.length;s++){const o=t[s][e];for(const a in o)!o.hasOwnProperty(a)||i.hasOwnProperty(a)||(i[a]=this.length++)}}else if(Array.isArray(t)&&Array.isArray(t[0]))for(let s=0;s<t.length;s++){const n=t[s];for(let o=0;o<n.length;o++){const a=n[o];for(const h in a)!a.hasOwnProperty(h)||i.hasOwnProperty(h)||(i[h]=this.length++)}}else for(let s=0;s<t.length;s++){const n=t[s];for(const o in n)!n.hasOwnProperty(o)||i.hasOwnProperty(o)||(i[o]=this.length++)}}}var We=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof Ut<"u"?Ut:typeof self<"u"?self:{};function es(r,t,e){return e={path:t,exports:{},require:function(i,s){return is(i,s==null?e.path:s)}},r(e,e.exports),e.exports}function is(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var He=es(function(r,t){var e=We&&We.__assign||function(){return e=Object.assign||function(o){for(var a,h=1,u=arguments.length;h<u;h++){a=arguments[h];for(var l in a)Object.prototype.hasOwnProperty.call(a,l)&&(o[l]=a[l])}return o},e.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.thaw=t.Block=t.Thaw=void 0;var i=function(){function o(a,h){var u=this;h===void 0&&(h={});var l=e(e({},o.defaultSettings),h),c=l.each,p=l.done;this.i=0,this.isStopped=!1,this.items=a,this.options=h,this.tick=function(){if(!u.isStopped&&(u.timeout=setTimeout(u.tick,0),!o.thawing)){var d=u.items[u.i];if(u.i>=u.items.length){p!==null&&(o.thawing=!0,p(),o.thawing=!1),u.isStopped=!0,clearTimeout(u.timeout);return}c!==null?(o.thawing=!0,c(d,u.i),o.thawing=!1):d!==void 0&&d(),u.i++}},o.thaws.push(this),h.delay||this.tick()}return Object.defineProperty(o,"isThawing",{get:function(){return o.thawing},enumerable:!1,configurable:!0}),o.stopAll=function(){for(var a=0;a<o.thaws.length;a++)o.thaws[a].stop()},o.prototype.makeReady=function(){return this.isStopped?(this.isStopped=!1,!0):!1},o.prototype.add=function(a){return this.items.push(a),this.makeReady()&&this.tick(),this},o.prototype.insert=function(a){return this.items.splice(this.i,0,a),this.makeReady()&&this.tick(),this},o.prototype.addArray=function(a){return this.items=this.items.concat(a),this.makeReady()&&this.tick(),this},o.prototype.insertArray=function(a){var h=this.items.splice(0,this.i),u=this.items;return this.items=h.concat(a,u),this.makeReady()&&this.tick(),this},o.prototype.stop=function(){return this.isStopped=!0,clearTimeout(this.timeout),this.options.done&&this.options.done(),this},o.thawing=!1,o.thaws=[],o.defaultSettings={each:null,done:null},o}();t.Thaw=i;function s(o,a){return new i(o,a)}t.thaw=s;var n=function(){function o(a,h){h===void 0&&(h=200),this.index=0,this.thaws=[],this.count=h,this.options=a}return o.prototype.add=function(a){var h=this.next();return h.add(a),this},o.prototype.addArray=function(a){var h=this.next();return h.addArray(a),this},o.prototype.insert=function(a){var h=this.next();return h.insert(a),this},o.prototype.insertArray=function(a){var h=this.next();return h.insertArray(a),this},o.prototype.stop=function(){for(var a=0;a<this.thaws.length;a++)this.thaws[a].stop();return this},o.prototype.next=function(){var a,h=this.thaws;return h.length<this.count?(a=new i([],this.options),h.push(a)):a=h[this.index]||null,this.index++,this.index>=this.count&&(this.index=0),a},o}();t.Block=n,typeof window<"u"&&(window.Thaw=i,window.thaw=s,window.Thaw.Block=n)});const rs={learningRate:.3,binaryThresh:.5,initPraxis:(r,t)=>{var e;return jt(r,(e=r.settings.praxisOpts)!==null&&e!==void 0?e:t)}},Bt={iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,learningRate:.3,callbackPeriod:10,errorCheckInterval:100,timeout:1/0};class bt{constructor(t={}){this.trainOpts={},this.layers=null,this._inputLayer=null,this._hiddenLayers=null,this._outputLayer=null,this._model=null,this.meanSquaredError=null,this.inputLookup=null,this.inputLookupLength=null,this.outputLookup=null,this.outputLookupLength=null,this.options={...rs,...t},this._updateTrainingOptions({...Bt,...t})}static _validateTrainingOptions(t){const{iterations:e,errorThresh:i,log:s,logPeriod:n,learningRate:o,callback:a,callbackPeriod:h,timeout:u}=t,l={iterations:()=>typeof e=="number"&&e>0,errorThresh:()=>typeof i=="number"&&i>0&&i<1,log:()=>typeof s=="function"||typeof s=="boolean",logPeriod:()=>typeof n=="number"&&n>0,learningRate:()=>typeof o=="number"&&o>0&&o<1,callback:()=>typeof a=="function"||a===null,callbackPeriod:()=>typeof h=="number"&&h>0,timeout:()=>typeof u=="number"&&u>0};Object.keys(Bt).forEach(c=>{if(l.hasOwnProperty(c)&&!l[c]()){const p=t[c];throw new Error(`[${c}, ${(p!=null?p:"undefined").toString()}] is out of normal training range, your network will probably not train.`)}})}_setLogMethod(t){typeof t=="function"?this.trainOpts.log=t:t?this.trainOpts.log=console.log:this.trainOpts.log=!1}_updateTrainingOptions(t){var e;this.trainOpts={...Bt,...this.trainOpts,...t},bt._validateTrainingOptions(this.trainOpts),this._setLogMethod((e=t.log)!==null&&e!==void 0?e:this.trainOpts.log);const{callback:i,callbackPeriod:s,errorCheckInterval:n}=this.trainOpts;i&&s!==n&&console.warn(`options.callbackPeriod with value of ${(s!=null?s:"undefined").toString()} does not match options.errorCheckInterval with value of ${(n!=null?n:"undefined").toString()}, if logging error, it will repeat.  These values may need to match`)}_connectOptionsLayers(){const{inputLayerIndex:t,outputLayerIndex:e,layers:i}=this.options;if(!i)throw new Error("this.options.layers in unexpected state");if(typeof t!="number")throw new Error("inputLayerIndex not a number");if(typeof e!="number")throw new Error("inputLayerIndex not a number");const s=i[t];if(!s)throw new Error("inputLayer not found in this.options.layers");const n=i[e];if(!n)throw new Error("outputLayer not found in this.options.layers");return this._inputLayer=s,this._hiddenLayers=i.slice(t,e-t),this._outputLayer=n,i}_connectNewLayers(){const{inputLayer:t,outputLayer:e}=this.options;if(!t)throw new Error("inputLayer not defined");const i=[];this._inputLayer=t();const s=this._connectHiddenLayers(this._inputLayer);if(!e)throw new Error("outputLayer not defined");return this._outputLayer=e(s[s.length-1],s.length),i.push(this._inputLayer),i.push(...s),i.push(this._outputLayer),he(i)}_connectHiddenLayers(t){this._hiddenLayers=[];const e=[],{hiddenLayers:i}=this.options;if(!i)throw new Error("hiddenLayers not defined");for(let s=0;s<i.length;s++){const n=i[s](t,s);e.push(n),this._hiddenLayers.push(n),t=n}return e}initialize(){this.layers=this.options.layers?this._connectOptionsLayers():this._connectNewLayers(),this.initializeLayers(this.layers),this._model=this.layers.filter(t=>t instanceof V)}initializeLayers(t){var e,i;for(let n=0;n<t.length;n++){const o=t[n];o.setupKernels(!0),o instanceof V&&o.praxis===null&&typeof this.options.initPraxis=="function"&&(o.praxis=this.options.initPraxis(o,(i=(e=o.settings.praxisOpts)!==null&&e!==void 0?e:this.options.praxisOpts)!==null&&i!==void 0?i:{}),o.praxis.setupKernels())}const s=t[t.length-1];this.meanSquaredError=new ki({width:s.width,height:s.height})}run(t){let e;if(Array.isArray(t)||t.buffer)e=t;else if(this.inputLookup)e=k.toArray(this.inputLookup,t,this.inputLookupLength);else throw new Error("input is incompatible with net");let i=this.runInput(e);return i instanceof E.Texture&&(i=i.toArray()),this.outputLookup?k.toObject(this.outputLookup,i):i}runInput(t){if(!this.layers)throw new Error("not initialized");this.layers[0].predict(t);for(let e=1;e<this.layers.length;e++)this.layers[e].predict();return this.layers[this.layers.length-1].weights}train(t,e={}){const{preparedData:i,status:s,endTime:n}=this._prepTraining(t,e);let o=!0;const a=()=>this._calculateTrainingError(i),h=()=>this._trainPatterns(i);for(;o;)o=this._trainingTick(s,n,a,h);return s}async trainAsync(t,e={}){const{preparedData:i,status:s,endTime:n}=this._prepTraining(t,e);return await new Promise((o,a)=>{try{const h=()=>this._calculateTrainingError(i),u=()=>this._trainPatterns(i),l=new He.Thaw(new Array(this.trainOpts.iterations),{delay:!0,each:()=>this._trainingTick(s,n,h,u)||l.stop(),done:()=>o(s)});l.tick()}catch(h){a(h)}})}_trainingTick(t,e,i,s){const{trainOpts:n}=this;return t.iterations>=n.iterations||t.error<=n.errorThresh||Date.now()>=e?!1:(typeof n.log=="function"&&t.iterations%n.logPeriod===0?(t.error=i(),n.log(`iterations: ${t.iterations}, training error: ${t.error}`)):t.iterations%n.errorCheckInterval===0?t.error=i():s(),n.callback&&t.iterations%n.callbackPeriod===0&&n.callback(Object.assign(t)),t.iterations++,!0)}_prepTraining(t,e){this._updateTrainingOptions(e);const i=this.formatData(t),s=this.trainOpts.timeout?Date.now()+this.trainOpts.timeout:0,n={error:1,iterations:0};return this.verifyIsInitialized(),{preparedData:this.transferData(i),status:n,endTime:s}}verifyIsInitialized(){this._model||this.initialize()}_calculateTrainingError(t){let e=new Float32Array([0]);const i=this.meanSquaredError;for(let n=0;n<t.length;++n){const o=e,a=this._trainPattern(t[n].input,t[n].output,!0);e=i.add(e,a),w(a),w(o)}const s=i.divide(t.length,e);if(w(e),s instanceof E.Texture){const n=s.toArray();return w(s),n[0]}return s[0]}_trainPatterns(t){for(let e=0;e<t.length;++e)this._trainPattern(t[e].input,t[e].output,!1)}_trainPattern(t,e,i){var s;if(this.runInput(t),this._calculateDeltas(e),this.adjustWeights(),i){if(!(!((s=this._outputLayer)===null||s===void 0)&&s.errors))throw new Error("outputLayer.errors not defined");return this.meanSquaredError.calculate(this._outputLayer.errors)}return null}_calculateDeltas(t){const e=this.layers;for(let i=e.length-1;i>-1;i--)e[i].compare(t)}adjustWeights(){const t=this._model;for(let e=0;e<t.length;e++)t[e].learn(this.trainOpts.learningRate)}formatData(t){if(!Array.isArray(t)){const n=[];n.push(t),t=n}const e=t[0].input;let i;if(Array.isArray(t)&&!Array.isArray(e)&&!(e instanceof Float32Array)){if(!this.inputLookup){const n=new X(t,"input");this.inputLookup=n.table,this.inputLookupLength=n.length}i=t.map(n=>({input:k.toArray(this.inputLookup,n.input,this.inputLookupLength)}),this)}else i=t;const s=t[0].output;if(!Array.isArray(s)&&!(s instanceof Float32Array)){if(!this.outputLookup){const n=new X(t,"output");this.outputLookup=n.table,this.outputLookupLength=n.length}i=t.map((n,o)=>{const a=k.toArray(this.outputLookup,n.output,this.inputLookupLength);return{input:i[o].input,output:a}},this)}return i}transferData(t){const e=new Array(t.length),i=y(function(n){return n[this.thread.x]},{output:[t[0].input.length],immutable:!0}),s=y(function(n){return n[this.thread.x]},{output:[t[0].output.length],immutable:!0});for(let n=0;n<t.length;n++){const o=t[n];e[n]={input:i(o.input),output:s(o.output)}}return e}test(){throw new Error(`${this.constructor.name}-test is not yet implemented`)}toJSON(){var t;if(this.layers||this.initialize(),!this._model||!this.layers||!this._inputLayer||!this._hiddenLayers||!this._outputLayer)throw new Error("network is not initialized");const e=[];for(let i=0;i<this.layers.length;i++){const s=this.layers[i],n=s.toJSON();s.hasOwnProperty("inputLayer")?n.inputLayerIndex=this.layers.indexOf(s.inputLayer):s.hasOwnProperty("inputLayer1")&&s.hasOwnProperty("inputLayer2")&&(n.inputLayer1Index=this.layers.indexOf(s.inputLayer1),n.inputLayer2Index=this.layers.indexOf(s.inputLayer2)),e.push(n)}return{type:this.constructor.name,sizes:(t=this.options.sizes)!==null&&t!==void 0?t:[this._inputLayer.height].concat(this._hiddenLayers.map(i=>i.height)).concat([this._outputLayer.height]),outputLayerIndex:this.layers.indexOf(this._outputLayer),layers:e,inputLayerIndex:this.layers.indexOf(this._inputLayer)}}static fromJSON(t,e){var i,s,n,o;const a=t.layers,h=[],u=e?(i=Z(a[0]))!==null&&i!==void 0?i:e(a[0]):Z(a[0]);if(!u)throw new Error("unable to find layer");h.push(u);for(let l=1;l<a.length;l++){const c=a[l];if(typeof c.inputLayerIndex>"u"&&typeof c.inputLayer1Index>"u"&&typeof c.inputLayer2Index>"u"){const p=e?(s=Z(c))!==null&&s!==void 0?s:e(c):Z(c);if(!p)throw new Error("unable to find layer");h.push(p)}else if(typeof c.inputLayerIndex=="number"){const p=h[c.inputLayerIndex];if(!p)throw new Error("inputLayer1 not found");const d=e?(n=Z(c,p))!==null&&n!==void 0?n:e(c,p):Z(c,p);if(!d)throw new Error("unable to find layer");h.push(d)}else{if(typeof c.inputLayer1Index!="number")throw new Error("Cannot create network from provided JSON. inputLayer1Index not defined.");if(typeof c.inputLayer2Index!="number")throw new Error("Cannot create network from provided JSON. inputLayer2Index not defined.");const p=h[c.inputLayer1Index],d=h[c.inputLayer2Index];if(p===void 0)throw new Error(`Cannot create network from provided JSON. layer of index ${c.inputLayer1Index} not found.`);if(d===void 0)throw new Error(`Cannot create network from provided JSON. layer of index ${c.inputLayer2Index} not found.`);const f=e?(o=Z(c,p,d))!==null&&o!==void 0?o:e(c,p,d):Z(c,p,d);if(!f)throw new Error("unable to find layer");h.push(f)}}return new this({...t,layers:h})}toFunction(){throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)}createTrainStream(){throw new Error(`${this.constructor.name}-createTrainStream is not yet implemented`)}}function ss(r,t){if(!t)throw new TypeError(`Required parameter 'net' is of type ${typeof t}. Must be of type 'brain.NeuralNetwork'`);const e=t.run(r);let i=null,s=-1;return Object.entries(e).forEach(([n,o])=>{typeof o<"u"&&typeof o=="number"&&o>s&&(i=n,s=o)}),i}function ns(r){const t=[];for(let e=0;e<r.length;e++)t.push(Float32Array.from(r[e]));return t}function os(r,t){const e=[];for(let i=0;i<r.length;i++)e.push(Float32Array.from(r[i]));for(let i=0;i<t.length;i++)e.push(Float32Array.from(t[i]));return e}function as(r){const t=[];for(let e=0;e<r.length;e++)t.push(Float32Array.from([r[e]]));return t}function hs(r,t){const e=[];for(let i=0;i<r.length;i++)e.push(Float32Array.from([r[i]]));for(let i=0;i<t.length;i++)e.push(Float32Array.from([t[i]]));return e}function us(r){return Float32Array.from(r)}function ls(r,t,e,i,s,n){const o=[];for(let a=0;a<r.length;a++){const h=r[a],u=new Float32Array(s);for(const l in h)h.hasOwnProperty(l)&&(u[e[l]]=h[l]);o.push(u)}for(let a=0;a<t.length;a++){const h=t[a],u=new Float32Array(n);for(const l in h)h.hasOwnProperty(l)&&(u[i[l]]=h[l]);o.push(u)}return o}function cs(r){const t=[];for(const e in r)!r.hasOwnProperty(e)||t.push(Float32Array.from([r[e]]));return t}function ps(r,t){const e=[];for(const i in r)!r.hasOwnProperty(i)||e.push(Float32Array.from([r[i]]));for(const i in t)!t.hasOwnProperty(i)||e.push(Float32Array.from([t[i]]));return e}function Be(r,t,e){const i=new Float32Array(e);for(const s in r)r.hasOwnProperty(s)&&(i[t[s]]=r[s]);return i}function qt(r){return Array.isArray(r)||r instanceof Float32Array?Math.max(...r):Math.max(...Object.values(r))}function Et(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e]**2;return t/r.length}function qe(r,t){if(r.buffer instanceof ArrayBuffer)return null;if(Array.isArray(r))return us;if(!t)throw new Error("table is not Object");const{length:e}=Object.keys(t);return i=>{const s=new Float32Array(e);for(const n in t)!t.hasOwnProperty(n)||typeof i[n]=="number"&&(s[t[n]]=i[n]||0);return s}}function Ge(){return{inputSize:0,outputSize:0,binaryThresh:.5}}function ds(){return{activation:"sigmoid",iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,leakyReluAlpha:.01,learningRate:.3,momentum:.1,callbackPeriod:10,timeout:1/0,beta1:.9,beta2:.999,epsilon:1e-8}}class Gt{constructor(t={}){this.options=Ge(),this.trainOpts=ds(),this.sizes=[],this.outputLayer=-1,this.biases=[],this.weights=[],this.outputs=[],this.deltas=[],this.changes=[],this.errors=[],this.errorCheckInterval=1,this.inputLookup=null,this.inputLookupLength=0,this.outputLookup=null,this.outputLookupLength=0,this._formatInput=null,this._formatOutput=null,this.runInput=n=>(this.setActivation(),this.runInput(n)),this.calculateDeltas=n=>(this.setActivation(),this.calculateDeltas(n)),this.biasChangesLow=[],this.biasChangesHigh=[],this.changesLow=[],this.changesHigh=[],this.iterations=0,this.options={...this.options,...t},this.updateTrainingOptions(t);const{inputSize:e,hiddenLayers:i,outputSize:s}=this.options;e&&s&&(this.sizes=[e].concat(i!=null?i:[]).concat([s]))}initialize(){if(!this.sizes.length)throw new Error("Sizes must be set before initializing");this.outputLayer=this.sizes.length-1,this.biases=new Array(this.outputLayer),this.weights=new Array(this.outputLayer),this.outputs=new Array(this.outputLayer),this.deltas=new Array(this.outputLayer),this.changes=new Array(this.outputLayer),this.errors=new Array(this.outputLayer);for(let t=0;t<=this.outputLayer;t++){const e=this.sizes[t];if(this.deltas[t]=M(e),this.errors[t]=M(e),this.outputs[t]=M(e),t>0){this.biases[t]=ot(e),this.weights[t]=new Array(e),this.changes[t]=new Array(e);for(let i=0;i<e;i++){const s=this.sizes[t-1];this.weights[t][i]=ot(s),this.changes[t][i]=M(s)}}}this.setActivation(),this.trainOpts.praxis==="adam"&&this._setupAdam()}setActivation(t){const e=t!=null?t:this.trainOpts.activation;switch(e){case"sigmoid":this.runInput=this._runInputSigmoid,this.calculateDeltas=this._calculateDeltasSigmoid;break;case"relu":this.runInput=this._runInputRelu,this.calculateDeltas=this._calculateDeltasRelu;break;case"leaky-relu":this.runInput=this._runInputLeakyRelu,this.calculateDeltas=this._calculateDeltasLeakyRelu;break;case"tanh":this.runInput=this._runInputTanh,this.calculateDeltas=this._calculateDeltasTanh;break;default:throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}}get isRunnable(){return this.sizes.length>0}run(t){if(!this.isRunnable)throw new Error("network not runnable");let e;this.inputLookup?e=k.toArray(this.inputLookup,t,this.inputLookupLength):e=t,this.validateInput(e);const i=this.runInput(e).slice(0);return this.outputLookup?k.toObject(this.outputLookup,i):i}_runInputSigmoid(t){this.outputs[0]=t;let e=null;for(let i=1;i<=this.outputLayer;i++){const s=this.sizes[i],n=this.weights[i],o=this.biases[i],a=this.outputs[i];for(let h=0;h<s;h++){const u=n[h];let l=o[h];for(let c=0;c<u.length;c++)l+=u[c]*t[c];a[h]=1/(1+Math.exp(-l))}e=t=a}if(!e)throw new Error("output was empty");return e}_runInputRelu(t){this.outputs[0]=t;let e=null;for(let i=1;i<=this.outputLayer;i++){const s=this.sizes[i],n=this.weights[i],o=this.biases[i],a=this.outputs[i];for(let h=0;h<s;h++){const u=n[h];let l=o[h];for(let c=0;c<u.length;c++)l+=u[c]*t[c];a[h]=l<0?0:l}e=t=a}if(!e)throw new Error("output was empty");return e}_runInputLeakyRelu(t){this.outputs[0]=t;const{leakyReluAlpha:e}=this.trainOpts;let i=null;for(let s=1;s<=this.outputLayer;s++){const n=this.sizes[s],o=this.weights[s],a=this.biases[s],h=this.outputs[s];for(let u=0;u<n;u++){const l=o[u];let c=a[u];for(let p=0;p<l.length;p++)c+=l[p]*t[p];h[u]=Math.max(c,e*c)}i=t=h}if(!i)throw new Error("output was empty");return i}_runInputTanh(t){this.outputs[0]=t;let e=null;for(let i=1;i<=this.outputLayer;i++){const s=this.sizes[i],n=this.weights[i],o=this.biases[i],a=this.outputs[i];for(let h=0;h<s;h++){const u=n[h];let l=o[h];for(let c=0;c<u.length;c++)l+=u[c]*t[c];a[h]=Math.tanh(l)}e=t=a}if(!e)throw new Error("output was empty");return e}verifyIsInitialized(t){this.sizes.length&&this.outputLayer>0||(this.sizes=[],this.sizes.push(t[0].input.length),this.options.hiddenLayers?this.options.hiddenLayers.forEach(e=>{this.sizes.push(e)}):this.sizes.push(Math.max(3,Math.floor(t[0].input.length/2))),this.sizes.push(t[0].output.length),this.initialize())}updateTrainingOptions(t){const e={...this.trainOpts,...t};this.validateTrainingOptions(e),this.trainOpts=e,this.setLogMethod(this.trainOpts.log)}validateTrainingOptions(t){const e={activation:()=>["sigmoid","relu","leaky-relu","tanh"].includes(t.activation),iterations:()=>{const i=t.iterations;return typeof i=="number"&&i>0},errorThresh:()=>{const i=t.errorThresh;return typeof i=="number"&&i>0&&i<1},log:()=>{const i=t.log;return typeof i=="function"||typeof i=="boolean"},logPeriod:()=>{const i=t.logPeriod;return typeof i=="number"&&i>0},leakyReluAlpha:()=>{const i=t.leakyReluAlpha;return typeof i=="number"&&i>0&&i<1},learningRate:()=>{const i=t.learningRate;return typeof i=="number"&&i>0&&i<1},momentum:()=>{const i=t.momentum;return typeof i=="number"&&i>0&&i<1},callback:()=>{const i=t.callback;return typeof i=="function"||i===void 0},callbackPeriod:()=>{const i=t.callbackPeriod;return typeof i=="number"&&i>0},timeout:()=>{const i=t.timeout;return typeof i=="number"&&i>0},praxis:()=>{const i=t.praxis;return!i||i==="adam"},beta1:()=>{const i=t.beta1;return i>0&&i<1},beta2:()=>{const i=t.beta2;return i>0&&i<1},epsilon:()=>{const i=t.epsilon;return i>0&&i<1}};for(const i in e){const s=t;if(!e[i]())throw new Error(`[${i}, ${s[i]}] is out of normal training range, your network will probably not train.`)}}getTrainOptsJSON(){const{activation:t,iterations:e,errorThresh:i,log:s,logPeriod:n,leakyReluAlpha:o,learningRate:a,momentum:h,callbackPeriod:u,timeout:l,praxis:c,beta1:p,beta2:d,epsilon:f}=this.trainOpts;return{activation:t,iterations:e,errorThresh:i,log:typeof s=="function"?!0:typeof s=="boolean"?s:!1,logPeriod:n,leakyReluAlpha:o,learningRate:a,momentum:h,callbackPeriod:u,timeout:l===1/0?"Infinity":l,praxis:c,beta1:p,beta2:d,epsilon:f}}setLogMethod(t){typeof t=="function"?this.trainOpts.log=t:t?this.trainOpts.log=this.logTrainingStatus:this.trainOpts.log=!1}logTrainingStatus(t){console.log(`iterations: ${t.iterations}, training error: ${t.error}`)}calculateTrainingError(t){let e=0;for(let i=0;i<t.length;++i)e+=this.trainPattern(t[i],!0);return e/t.length}trainPatterns(t){for(let e=0;e<t.length;++e)this.trainPattern(t[e])}trainingTick(t,e,i){const{callback:s,callbackPeriod:n,errorThresh:o,iterations:a,log:h,logPeriod:u}=this.trainOpts;return e.iterations>=a||e.error<=o||Date.now()>=i?!1:(e.iterations++,h&&e.iterations%u===0?(e.error=this.calculateTrainingError(t),h(e)):e.iterations%this.errorCheckInterval===0?e.error=this.calculateTrainingError(t):this.trainPatterns(t),s&&e.iterations%n===0&&s({iterations:e.iterations,error:e.error}),!0)}prepTraining(t,e={}){this.updateTrainingOptions(e);const i=this.formatData(t),s=Date.now()+this.trainOpts.timeout,n={error:1,iterations:0};return this.verifyIsInitialized(i),this.validateData(i),{preparedData:i,status:n,endTime:s}}train(t,e={}){const{preparedData:i,status:s,endTime:n}=this.prepTraining(t,e);for(;this.trainingTick(i,s,n););return s}async trainAsync(t,e={}){const{preparedData:i,status:s,endTime:n}=this.prepTraining(t,e);return await new Promise((o,a)=>{try{const h=new He.Thaw(new Array(this.trainOpts.iterations),{delay:!0,each:()=>this.trainingTick(i,s,n)||h.stop(),done:()=>o(s)});h.tick()}catch(h){a(h)}})}trainPattern(t,e){return this.runInput(t.input),this.calculateDeltas(t.output),this.adjustWeights(),e?Et(this.errors[this.outputLayer]):null}_calculateDeltasSigmoid(t){for(let e=this.outputLayer;e>=0;e--){const i=this.sizes[e],s=this.outputs[e],n=this.errors[e],o=this.deltas[e],a=this.weights[e+1];for(let h=0;h<i;h++){const u=s[h];let l=0;if(e===this.outputLayer)l=t[h]-u;else{const c=this.deltas[e+1];for(let p=0;p<c.length;p++)l+=c[p]*a[p][h]}n[h]=l,o[h]=l*u*(1-u)}}}_calculateDeltasRelu(t){for(let e=this.outputLayer;e>=0;e--){const i=this.sizes[e],s=this.outputs[e],n=this.weights[e+1],o=this.deltas[e+1],a=this.errors[e],h=this.deltas[e];for(let u=0;u<i;u++){const l=s[u];let c=0;if(e===this.outputLayer)c=t[u]-l;else for(let p=0;p<o.length;p++)c+=o[p]*n[p][u];a[u]=c,h[u]=l>0?c:0}}}_calculateDeltasLeakyRelu(t){const e=this.trainOpts.leakyReluAlpha;for(let i=this.outputLayer;i>=0;i--){const s=this.sizes[i],n=this.outputs[i],o=this.deltas[i+1],a=this.weights[i+1],h=this.errors[i],u=this.deltas[i];for(let l=0;l<s;l++){const c=n[l];let p=0;if(i===this.outputLayer)p=t[l]-c;else for(let d=0;d<o.length;d++)p+=o[d]*a[d][l];h[l]=p,u[l]=c>0?p:e*p}}}_calculateDeltasTanh(t){for(let e=this.outputLayer;e>=0;e--){const i=this.sizes[e],s=this.outputs[e],n=this.deltas[e+1],o=this.weights[e+1],a=this.errors[e],h=this.deltas[e];for(let u=0;u<i;u++){const l=s[u];let c=0;if(e===this.outputLayer)c=t[u]-l;else for(let p=0;p<n.length;p++)c+=n[p]*o[p][u];a[u]=c,h[u]=(1-l*l)*c}}}adjustWeights(){const{learningRate:t,momentum:e}=this.trainOpts;for(let i=1;i<=this.outputLayer;i++){const s=this.outputs[i-1],n=this.sizes[i],o=this.deltas[i],a=this.changes[i],h=this.weights[i],u=this.biases[i];for(let l=0;l<n;l++){const c=o[l];for(let p=0;p<s.length;p++){let d=a[l][p];d=t*c*s[p]+e*d,a[l][p]=d,h[l][p]+=d}u[l]+=t*c}}}_setupAdam(){this.biasChangesLow=[],this.biasChangesHigh=[],this.changesLow=[],this.changesHigh=[],this.iterations=0;for(let t=0;t<=this.outputLayer;t++){const e=this.sizes[t];if(t>0){this.biasChangesLow[t]=M(e),this.biasChangesHigh[t]=M(e),this.changesLow[t]=new Array(e),this.changesHigh[t]=new Array(e);for(let i=0;i<e;i++){const s=this.sizes[t-1];this.changesLow[t][i]=M(s),this.changesHigh[t][i]=M(s)}}}this.adjustWeights=this._adjustWeightsAdam}_adjustWeightsAdam(){this.iterations++;const{iterations:t}=this,{beta1:e,beta2:i,epsilon:s,learningRate:n}=this.trainOpts;for(let o=1;o<=this.outputLayer;o++){const a=this.outputs[o-1],h=this.sizes[o],u=this.deltas[o],l=this.changesLow[o],c=this.changesHigh[o],p=this.weights[o],d=this.biases[o],f=this.biasChangesLow[o],x=this.biasChangesHigh[o];for(let g=0;g<h;g++){const O=u[g];for(let W=0;W<a.length;W++){const b=O*a[W],K=l[g][W]*e+(1-e)*b,S=c[g][W]*i+(1-i)*b*b,P=K/(1-Math.pow(e,t)),C=S/(1-Math.pow(i,t));l[g][W]=K,c[g][W]=S,p[g][W]+=n*P/(Math.sqrt(C)+s)}const m=u[g],v=f[g]*e+(1-e)*m,_=x[g]*i+(1-i)*m*m,T=f[g]/(1-Math.pow(e,t)),St=x[g]/(1-Math.pow(i,t));f[g]=v,x[g]=_,d[g]+=n*T/(Math.sqrt(St)+s)}}}validateData(t){const e=this.sizes[0],i=this.sizes[this.sizes.length-1],{length:s}=t;for(let n=0;n<s;n++){const{input:o,output:a}=t[n];if(o.length!==e)throw new Error(`input at index ${n} length ${o.length} must be ${e}`);if(t[n].output.length!==i)throw new Error(`output at index ${n} length ${a.length} must be ${i}`)}}validateInput(t){const e=this.sizes[0];if(t.length!==e)throw new Error(`input length ${t.length} must match options.inputSize of ${e}`)}formatData(t){if(!Array.isArray(t[0].input))if(this.inputLookup)this.inputLookupLength=Object.keys(this.inputLookup).length;else{const e=new X(t,"input");this.inputLookup=e.table,this.inputLookupLength=e.length}if(!Array.isArray(t[0].output))if(this.outputLookup)this.outputLookupLength=Object.keys(this.outputLookup).length;else{const e=new X(t,"output");this.outputLookup=e.table,this.outputLookupLength=e.length}if(this._formatInput||(this._formatInput=qe(t[0].input,this.inputLookup)),this._formatOutput||(this._formatOutput=qe(t[0].output,this.outputLookup)),this._formatInput&&this._formatOutput){const e=[];for(let i=0;i<t.length;i++)e.push({input:this._formatInput(t[i].input),output:this._formatOutput(t[i].output)});return e}if(this._formatInput){const e=[];for(let i=0;i<t.length;i++)e.push({input:this._formatInput(t[i].input),output:t[i].output});return e}if(this._formatOutput){const e=[];for(let i=0;i<t.length;i++)e.push({input:t[i].input,output:this._formatOutput(t[i].output)});return e}return t}addFormat(t){var e,i;(!Array.isArray(t.input)||typeof t.input[0]!="number")&&(this.inputLookup=k.addKeys(t.input,(e=this.inputLookup)!==null&&e!==void 0?e:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length)),(!Array.isArray(t.output)||typeof t.output[0]!="number")&&(this.outputLookup=k.addKeys(t.output,(i=this.outputLookup)!==null&&i!==void 0?i:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length))}test(t){const{preparedData:e}=this.prepTraining(t),i=e[0].output.length===1,s=[];let n=0;if(i){let o=0,a=0,h=0,u=0;for(let l=0;l<e.length;l++){const c=this.runInput(e[l].input),p=e[l].output,d=c[0]>this.options.binaryThresh?1:0,f=p[0];if(d!==f){const x=e[l];s.push({input:x.input,output:x.output,actual:d,expected:f})}d===0&&f===0?u++:d===1&&f===1?h++:d===0&&f===1?a++:d===1&&f===0&&o++,n+=Et(c.map((x,g)=>p[g]-x))}return{error:n/e.length,misclasses:s,total:e.length,trueNeg:u,truePos:h,falseNeg:a,falsePos:o,precision:h>0?h/(h+o):0,recall:h>0?h/(h+a):0,accuracy:(u+h)/e.length}}for(let o=0;o<e.length;o++){const a=this.runInput(e[o].input),h=e[o].output,u=a.indexOf(qt(a)),l=h.indexOf(qt(h));if(u!==l){const c=e[o];s.push({input:c.input,output:c.output,actual:u,expected:l})}n+=Et(a.map((c,p)=>h[p]-c))}return{error:n/e.length,misclasses:s,total:e.length}}toJSON(){var t,e;this.isRunnable||this.initialize();const i=this.weights.map(a=>a.map(h=>Array.from(h))),s=this.biases.map(a=>Array.from(a)),n=[],o=this.sizes.length-1;for(let a=0;a<=o;a++)n.push({weights:(t=i[a])!==null&&t!==void 0?t:[],biases:(e=s[a])!==null&&e!==void 0?e:[]});return{type:"NeuralNetwork",sizes:[...this.sizes],layers:n,inputLookup:this.inputLookup?{...this.inputLookup}:null,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup?{...this.outputLookup}:null,outputLookupLength:this.outputLookupLength,options:{...this.options},trainOpts:this.getTrainOptsJSON()}}fromJSON(t){if(this.options={...Ge(),...t.options},t.hasOwnProperty("trainOpts")){const n={...t.trainOpts,timeout:t.trainOpts.timeout==="Infinity"?1/0:t.trainOpts.timeout};this.updateTrainingOptions(n)}this.sizes=t.sizes,this.initialize(),this.inputLookup=t.inputLookup?{...t.inputLookup}:null,this.inputLookupLength=t.inputLookupLength,this.outputLookup=t.outputLookup?{...t.outputLookup}:null,this.outputLookupLength=t.outputLookupLength;const e=t.layers,i=this.weights.map((n,o)=>e[o].weights.map(a=>Float32Array.from(a))),s=this.biases.map((n,o)=>Float32Array.from(e[o].biases));for(let n=0;n<=this.outputLayer;n++)this.weights[n]=i[n]||[],this.biases[n]=s[n]||[];return this}toFunction(t){const{activation:e,leakyReluAlpha:i}=this.trainOpts;let s=!1;const n=(c,p)=>{if(c===0)return`(input[${p}]||0)`;const d=this.weights[c][p],f=this.biases[c][p];if(!d)throw new Error(`weights at layerIndex ${c} & nodeIndex ${p} not found`);if(!f)throw new Error(`bias as layerIndex ${c} & nodeIndex ${p} not found`);const x=[];d.forEach((O,m)=>{O<0?x.push(`${O}*${n(c-1,m)}`):x.push(`+${O}*${n(c-1,m)}`)});const g=`(${f.toString()}${x.join("")})`;switch(e){case"sigmoid":return`1/(1+1/Math.exp(${g}))`;case"relu":return s=!0,`((v=${g})<0?0:v)`;case"leaky-relu":return s=!0,`Math.max((v=${g}),${i}*v)`;case"tanh":return`Math.tanh(${g})`;default:throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}};function o(c){if(c.find(p=>p.includes('"')))throw new Error(`key contains '"', which is not compatible`)}const a=[];let h,u="";if(this.inputLookup){const c=Object.keys(this.inputLookup);o(c),u=`input = new Float32Array([${Object.keys(this.inputLookup).map(p=>`input["${p}"]`).join(",")}]);`}if(this.sizes.length<1)throw new Error("No layers");for(let c=0;c<this.sizes[this.outputLayer];c++)a.push(n(this.outputLayer,c));if(this.outputLookup){const c=Object.keys(this.outputLookup);o(c),h=`{${c.map((d,f)=>`"${d}":${a[f]}`).join(",")}}`}else h=`[${a.join(",")}]`;const l=`${u}${s?"var v;":""}return ${h};`;return new Function("input",t?t(l):l)}}function fs(r,t,e){let i=t[this.thread.x];for(let s=0;s<this.constants.size;s++)i+=r[this.thread.x][s]*e[s];return 1/(1+Math.exp(-i))}function gs(r,t,e){let i=t[this.thread.x];for(let s=0;s<this.constants.size;s++)i+=r[this.thread.x][s]*e[s];return i<0?0:i}function ws(r,t,e){let i=t[this.thread.x];for(let s=0;s<this.constants.size;s++)i+=r[this.thread.x][s]*e[s];return i<0?0:.01*i}function ys(r,t,e){let i=t[this.thread.x];for(let s=0;s<this.constants.size;s++)i+=r[this.thread.x][s]*e[s];return Math.tanh(i)}function Xe(r,t){return t-r}function ms(r,t){return r*t*(1-t)}function Ls(r,t){return t>0?r:0}function bs(r,t){return t>0?r:.01*r}function ks(r,t){return(1-t*t)*r}function Ye(r,t,e,i){let s=0;for(let n=0;n<t;n++)s+=i[n]*e[n][r];return s}function Je(r,t,e,i,s){return r*i*s+t*e}function Ve(r,t){return r+t}function xs(r,t){return r[this.thread.x]+t[this.thread.x]*this.constants.learningRate}function Os(r){let t=0;for(let e=0;e<this.constants.size;e++)t+=r[e]**2;return t/this.constants.size}class Ue extends Gt{constructor(t={}){super(t),this.texturizeInputData=()=>{throw new Error("not yet setup")},this.forwardPropagate=[],this.backwardPropagate=[],this.changesPropagate=[],this.biasesPropagate=[],this.getMSE=()=>{throw new Error("not yet setup")},this._addMSE=()=>{throw new Error("not yet setup")},this._divideMSESum=()=>{throw new Error("not yet setup")},this.outputs=[],this.deltas=[],this.errors=[],this.weights=[],this.changes=[],this.biases=[],this.runInput=e=>{let i;this.outputs[0]=e;for(let s=1;s<=this.outputLayer;s++)w(this.outputs[s]),this.outputs[s]=this.forwardPropagate[s](this.weights[s],this.biases[s],e),i=e=this.outputs[s];return i},this.calculateDeltas=e=>{for(let i=this.outputLayer;i>0;i--){w(this.deltas[i]),w(this.errors[i]);let s;i===this.outputLayer?s=this.backwardPropagate[i](this.outputs[i],e):s=this.backwardPropagate[i](this.weights[i+1],this.outputs[i],this.deltas[i+1]),this.deltas[i]=s.result,this.errors[i]=s.error}},this.errorCheckInterval=100,this.gpu=new E.GPU({mode:t.mode})}initialize(){super.initialize(),this.buildRunInput(),this.buildCalculateDeltas(),this.buildGetChanges(),this.buildChangeBiases(),this.buildGetMSE()}setActivation(){}trainPattern(t,e){return this.runInput(t.input),this.calculateDeltas(t.output),this.adjustWeights(),e?this.getMSE(this.errors[this.outputLayer]):null}calculateTrainingError(t){let e=new Float32Array([0]);for(let s=0;s<t.length;++s){const n=e,o=this.trainPattern(t[s],!0);e=this._addMSE(e,o),w(o),w(n)}const i=this._divideMSESum(t.length,e);return w(e),(i instanceof E.Texture?i.toArray():i)[0]}adjustWeights(){this.getChanges(),this.changeBiases()}buildRunInput(){let t=null;switch(this.trainOpts.activation){case"sigmoid":t=fs;break;case"relu":t=gs;break;case"leaky-relu":t=ws;break;case"tanh":t=ys;break;default:throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}for(let e=1;e<=this.outputLayer;e++)this.forwardPropagate[e]=this.gpu.createKernel(t,{output:[this.sizes[e]],pipeline:!0,constants:{size:this.sizes[e-1]},immutable:!0});this.texturizeInputData=this.gpu.createKernel(function(e){return e[this.thread.x]},{output:[this.sizes[1]],pipeline:!0,immutable:!0})}buildCalculateDeltas(){let t;switch(this.trainOpts.activation){case"sigmoid":t=ms;break;case"relu":t=Ls;break;case"leaky-relu":t=bs;break;case"tanh":t=ks;break;default:throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}t=E.alias(E.utils.getMinifySafeName(()=>t),t),this.gpu.addFunction(t);for(let e=this.outputLayer;e>0;e--)e===this.outputLayer?this.backwardPropagate[this.outputLayer]=this.gpu.createKernelMap({error:Xe},function(i,s){const n=i[this.thread.x],o=s[this.thread.x];return t(Xe(n,o),n)},{output:[this.sizes[this.outputLayer]],pipeline:!0,immutable:!0}):this.backwardPropagate[e]=this.gpu.createKernelMap({error:Ye},function(i,s,n){const o=s[this.thread.x];return t(Ye(this.thread.x,this.constants.size,i,n),o)},{output:[this.sizes[e]],pipeline:!0,constants:{size:this.sizes[e+1]},immutable:!0})}buildGetChanges(){for(let t=1;t<=this.outputLayer;t++)this.changesPropagate[t]=this.gpu.createKernelMap({weights:Ve,changes:Je},function(e,i,s,n){const o=Je(this.constants.learningRate,this.constants.momentum,n[this.thread.y][this.thread.x],i[this.thread.y],e[this.thread.x]);return Ve(o,s[this.thread.y][this.thread.x])},{output:[this.sizes[t-1],this.sizes[t]],pipeline:!0,constants:{size:this.sizes[t-1],learningRate:this.trainOpts.learningRate,momentum:this.trainOpts.momentum},immutable:!0})}getChanges(){for(let t=1;t<=this.outputLayer;t++){const e=this.weights[t],i=this.changes[t],s=this.changesPropagate[t](this.outputs[t-1],this.deltas[t],e,i);w(e),w(i),this.weights[t]=s.weights,this.changes[t]=s.changes,w(s.result)}}buildChangeBiases(){for(let t=1;t<=this.outputLayer;t++)this.biasesPropagate[t]=this.gpu.createKernel(xs,{output:[this.sizes[t]],pipeline:!0,constants:{learningRate:this.trainOpts.learningRate},immutable:!0})}changeBiases(){for(let t=1;t<=this.outputLayer;t++){const e=this.biases[t];this.biases[t]=this.biasesPropagate[t](e,this.deltas[t]),w(e)}}buildGetMSE(){this.getMSE=this.gpu.createKernel(Os,{output:[1],constants:{size:this.sizes[this.outputLayer]},pipeline:!0,immutable:!0}),this._addMSE=this.gpu.createKernel(function(t,e){return t[0]+e[0]},{output:[1],pipeline:!0,immutable:!0}),this._divideMSESum=this.gpu.createKernel(function(t,e){const i=e[0];return i>0?i/t:0},{output:[1]})}run(t){if(!this.isRunnable)throw new Error("network not runnable");let e;this.inputLookup?e=k.toArray(this.inputLookup,t,this.inputLookupLength):e=t,this.validateInput(e);const i=this.runInput(e),s=i instanceof E.Texture?i.toArray():i;return this.outputLookup?k.toObject(this.outputLookup,s):s}prepTraining(t,e={}){this.updateTrainingOptions(e);const i=this.formatData(t),s=Date.now()+this.trainOpts.timeout,n={error:1,iterations:0};this.verifyIsInitialized(i);const o=this.gpu.createKernel(function(a){return a[this.thread.x]},{output:[i[0].output.length],pipeline:!0,immutable:!0});return{preparedData:i.map(a=>({input:this.texturizeInputData(a.input),output:o(a.output)})),status:n,endTime:s}}toFunction(){throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)}toJSON(){var t,e;this.sizes===null&&this.initialize();const i=this.weights.map(o=>(o instanceof E.Texture?o.toArray():o).map(a=>Array.from(a))),s=this.biases.map(o=>Array.from(o instanceof E.Texture?o.toArray():o)),n=[];for(let o=0;o<=this.outputLayer;o++)n.push({weights:(t=i[o])!==null&&t!==void 0?t:[],biases:(e=s[o])!==null&&e!==void 0?e:[]});return{type:"NeuralNetworkGPU",sizes:[...this.sizes],layers:n,inputLookup:this.inputLookup?{...this.inputLookup}:null,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup?{...this.outputLookup}:null,outputLookupLength:this.outputLookupLength,options:{...this.options},trainOpts:this.getTrainOptsJSON()}}}class Ze extends gt{constructor(){super(...arguments),this.settings={},this.layer=null}setLayer(t){this.layer=t}get width(){if(!this.layer)throw new Error("layer not set");return this.layer.width}set width(t){throw new Error(`${this.constructor.name}-width is not yet implemented`)}get height(){if(!this.layer)throw new Error("layer not set");return this.layer.height}set height(t){throw new Error(`${this.constructor.name}-height is not yet implemented`)}get deltas(){if(!this.layer)throw new Error("layer not set");return this.layer.deltas}set deltas(t){if(!this.layer)throw new Error("layer not set");w(this.layer.deltas),this.layer.deltas=t}get weights(){if(!this.layer)throw new Error("layer not set");return this.layer.weights}set weights(t){if(!this.layer)throw new Error("layer not set");w(this.layer.weights),this.layer.weights=t}predict(){}compare(){}learn(){throw new Error("no longer using")}setupKernels(){}reuseKernels(){}}class Qe extends bt{constructor(t={}){super(t),this.trainOpts={},this._outputConnection=null,this._layerSets=[],this._hiddenLayerOutputIndices=[],this._model=null}_connectLayers(){if(!this.options.inputLayer)throw new Error("inputLayer not found");if(!this.options.outputLayer)throw new Error("outputLayer not found");const t=this.options.inputLayer(),e=this._connectHiddenLayers(t),i=this.options.outputLayer(e[e.length-1],-1);return{inputLayer:t,hiddenLayers:e,outputLayer:i}}_connectLayersDeep(){const t=[],e=this._layerSets[this._layerSets.length-1];let i=0;function s(o){const a=e.indexOf(o);if(a<0)throw new Error("unable to find layer");return t[a]}function n(o){return{...o.settings,weights:null,deltas:null,praxis:null}}for(let o=0;o<e.length;o++){const a=e[o];let h;if(a instanceof rt)h=new a.constructor(s(a.inputLayer),n(a));else if(a instanceof Nt)h=new a.constructor(n(a));else if(a instanceof st)h=new a.constructor(n(a.inputLayer),s(a.inputLayer));else if(a instanceof gt){const u=e[this._hiddenLayerOutputIndices[i++]];if(a instanceof Ze)throw new Error("unfinished");if(a instanceof $t)h=new $t(u);else if(a instanceof It)h=new $t(u);else throw new Error(`hidden layer ${a.constructor.name} extends unknown hidden layer`)}else if(a instanceof Kt||a instanceof V)h=a;else if(a instanceof wt)h=new a.constructor(s(a.inputLayer),n(a.inputLayer));else if(a instanceof yt)h=new a.constructor(s(a.inputLayer1),s(a.inputLayer2),n(a));else if(a instanceof mt)h=new a.constructor(n(a),s(a.inputLayer));else throw new Error(`hidden layer ${a.constructor.name} extends unknown hidden layer`);t.push(h)}return t}_connectHiddenLayers(t){const e=[];if(!this.options.hiddenLayers)throw new Error("hiddenLayers not defined");for(let i=0;i<this.options.hiddenLayers.length;i++){const s=new It,n=this.options.hiddenLayers[i](t,s,i);t=n,e.push(n)}return e}initialize(){this._outputConnection=new Ze;let t;if(this.options.layers)t=this._connectOptionsLayers();else{const{inputLayer:e,hiddenLayers:i,outputLayer:s}=this._connectLayers();t=he([e,...i,s]),this._hiddenLayerOutputIndices=i.map(n=>t.indexOf(n)),this._inputLayer=e,this._hiddenLayers=i,this._outputLayer=s}this.layers=t,this._layerSets=[t],this._model=t.filter(e=>e instanceof V||e instanceof Kt),this.initializeLayers(t)}initializeDeep(){const t=this._connectLayersDeep();for(let e=0;e<t.length;e++){const i=t[e];i.setupKernels(!0),i.reuseKernels(this._layerSets[0][e])}this._layerSets.push(t)}run(t){for(;this._layerSets.length<=t.length;)this.initializeDeep();const e=this.runInputs(t);return e instanceof E.Texture?e.toArray():e}runInput(t){throw new Error("use .runInputs()")}runInputs(t){for(;this._layerSets.length<t.length;)this.initializeDeep();const e=t.length-1;for(let n=0;n<=e;n++){const o=this._layerSets[n];o[0].predict(t[n]);for(let a=1;a<o.length;a++)o[a].predict()}const i=this._layerSets[e],s=i[i.length-1].weights;return this.end(),s}train(t,e={}){const{preparedData:i,status:s,endTime:n}=this._prepTraining(t,e);let o=!0;const a=()=>this._calculateTrainingError(i),h=()=>this._trainPatterns(i);for(;o;)o=this._trainingTick(s,n,a,h);return s}end(){const t=this._layerSets.length-1,e=this._layerSets[t];e[0].predict([new Float32Array([0])]);for(let i=1;i<e.length;i++)e[i].predict()}transferData(t){return t}_prepTraining(t,e){this._updateTrainingOptions(e);const i=this.trainOpts.timeout?Date.now()+this.trainOpts.timeout:0,s={error:1,iterations:0};return this.verifyIsInitialized(),{preparedData:this.transferData(t),status:s,endTime:i}}_calculateTrainingError(t){if(!this.meanSquaredError)throw new Error("this.meanSquaredError not setup");let e=new Float32Array(1);for(let s=0;s<t.length;++s){const n=e,o=this._trainPattern(t[s],!0);e=this.meanSquaredError.add(e,o),w(o),w(n)}const i=this.meanSquaredError.divide(t.length,e);return w(e),i instanceof E.Texture?i.toArray()[0]:i[0]}formatData(t){return t}_calculateDeltas(t){const e=this._layerSets[this._layerSets.length-1];for(let i=e.length-2;i>=0;i--)e[i].compare();for(let i=t.length-2;i>=0;i--){const s=this._layerSets[i];s[s.length-1].compare(t[i+1]);for(let n=s.length-2;n>=0;n--)s[n].compare()}}adjustWeights(){var t;const e=this._model;for(let i=0;i<e.length;i++)e[i].learn((t=this.options.learningRate)!==null&&t!==void 0?t:0)}_trainPatterns(t){for(let e=0;e<t.length;++e)this._trainPattern(t[e],!1)}_trainPattern(t,e){if(this.runInputs(t),this._calculateDeltas(t),this.adjustWeights(),e){if(!this.meanSquaredError)throw new Error("this.meanSquaredError not setup");let i=new Float32Array(1);for(let s=0,n=t.length-2;s<=n;s++){const o=this._layerSets[s],a=o[o.length-1],h=i;i=this.meanSquaredError.addAbsolute(h,a.errors),w(h)}return R(this.meanSquaredError.divide(t.length,i))}return null}}class L{constructor(t,e){this.rows=0,this.columns=0,t&&(this.rows=t),e&&(this.columns=e),this.weights=M(this.rows*this.columns),this.deltas=M(this.rows*this.columns)}getWeight(t,e){const i=this.columns*t+e;if(i<0||i>=this.weights.length)throw new Error("get accessor is skewed");return this.weights[i]}setWeight(t,e,i){const s=this.columns*t+e;if(s<0||s>=this.weights.length)throw new Error("set accessor is skewed");return this.weights[s]=i,this}getDelta(t,e){const i=this.columns*t+e;if(i<0||i>=this.deltas.length)throw new Error("get accessor is skewed");return this.deltas[i]}setDelta(t,e,i){const s=this.columns*t+e;if(s<0||s>=this.weights.length)throw new Error("set accessor is skewed");return this.deltas[s]=i,this}toJSON(){return{rows:this.rows,columns:this.columns,weights:Array.from(this.weights.slice(0))}}static fromJSON(t){const e=new L(t.rows,t.columns);for(let i=0,s=t.rows*t.columns;i<s;i++)e.weights[i]=t.weights[i];return e}static fromArray(t){const e=new L(t.length,t[0].length);return e.fromArray(t),e}deltasToArray(){return this.toArray("deltas")}weightsToArray(){return this.toArray("weights")}toArray(t="weights"){const e=new Array(this.rows);return this.iterate({row:i=>{e[i]=new Array(this.columns)},column:(i,s)=>{t==="weights"?e[i][s]=this.getWeight(i,s):t==="deltas"&&(e[i][s]=this.getDelta(i,s))}}),e}fromArray(t,e="weights"){if(t.length!==this.rows)throw new Error("rows do not match");if(t[0].length!==this.columns)throw new Error("columns do not match");return this.iterate({column:(i,s)=>{const n=t[i][s];if(typeof n!="number")throw new Error("value not number");e==="weights"?this.setWeight(i,s,n):e==="deltas"&&this.setDelta(i,s,n)}}),this}iterate(t){const e=this.rows,i=this.columns;for(let s=0;s<e;s++){t.row&&t.row(s);for(let n=0;n<i;n++)t.column&&t.column(s,n)}return this}}class I extends L{constructor(t,e,i){super(t,e),this.std=i;for(let s=0,n=this.weights.length;s<n;s++)this.weights[s]=nt(-i,i)}}class j{constructor(t,e=0){this.values=t,this.indexTable={},this.characterTable={},this.characters=[],this.specialIndexes=[],this.isSetup=!1,t!==void 0&&this.setup(t,e)}setup(t,e=0){if(this.isSetup)throw new Error("DataFormatter is already setup");this.values=t,this.buildCharactersFromIterable(t),this.buildTables(e),t[0].input&&this.addInputOutput(),this.addUnrecognized(),this.isSetup=!0}buildCharactersFromIterable(t){const e={};for(let i=0,s=t.length;i<s;i++){const n=t[i];if(n.hasOwnProperty("length")){const o=n;for(let a=0,h=o.length;a<h;a++){const u=o[a];e.hasOwnProperty(u)||(e[u]=!0,this.characters.push(u))}}else if(typeof n=="number"){if(e.hasOwnProperty(n))continue;e[n]=!0,this.characters.push(n)}else if(typeof n=="boolean"){const o=n.toString();if(e.hasOwnProperty(o))continue;e[o]=!0,this.characters.push(o)}else if(Array.isArray(n)&&typeof n[0]=="string")for(let o=0;o<n.length;o++){const a=n[o];e.hasOwnProperty(a)||(e[a]=!0,this.characters.push(a))}else if(Array.isArray(n)&&(typeof n[0]=="number"||typeof n[0]=="boolean"))for(let o=0;o<n.length;o++){const a=n[o].toString();e.hasOwnProperty(i)||(e[a]=!0,this.characters.push(a))}else if(n.hasOwnProperty("input")&&n.hasOwnProperty("output")){const{input:o,output:a}=n;Array.isArray(o)?this.addCharacters(o,e):this.addCharacters(o.toString(),e),Array.isArray(a)?this.addCharacters(a,e):this.addCharacters(a.toString(),e)}else throw new Error("Unhandled value")}}addCharacters(t,e){for(let i=0;i<t.length;i++){const s=t[i].toString();e.hasOwnProperty(s)||(e[s]=!0,this.characters.push(s))}}buildTables(t){const e=this.characters.length;for(let i=0;i<e;i++){const s=this.characters[i];i>=t&&(this.indexTable[s]=i,this.characterTable[i]=s)}}toIndexes(t,e=0){const i=[],{indexTable:s}=this;switch(typeof t){case"number":case"boolean":t=t.toString()}for(let n=0,o=t.length;n<o;n++){const a=t[n].toString();let h=s[a];if(h===void 0)if(s.unrecognized)h=s.unrecognized;else throw new Error(`unrecognized character "${a}"`);h<e||i.push(h)}return i}toIndexesInputOutput(t,e,i=0){const s=this.toIndexesValue(t,i,!0);return typeof e>"u"?s:s.concat(this.toIndexesValue(e,i,!1))}toIndexesValue(t,e,i){if(typeof t=="string")t=t.split("");else if(typeof t=="number"||typeof t=="boolean")t=t.toString().split("");else if(Array.isArray(t)&&(typeof t[0]=="number"||typeof t[0]=="boolean"||typeof t[0]=="string"))t=t.map(s=>s.toString());else throw new Error("unrecognized value");return i&&(t=t.concat(["stop-input","start-output"])),this.toIndexes(t,e)}toCharacters(t,e=0){const i=[],{indexTable:s,characterTable:n}=this;for(let o=0,a=t.length;o<a;o++){const h=t[o];if(h<e)continue;let u=n[h];if(u===void 0)if(s.unrecognized)u=n[s.unrecognized];else throw new Error(`unrecognized index "${h}"`);else u!==null&&i.push(u.toString())}return i}toString(t,e){return this.toCharacters(t,e).join("")}addInputOutput(){this.addSpecial("stop-input"),this.addSpecial("start-output")}addUnrecognized(){this.addSpecial("unrecognized")}static fromAllPrintable(t,e=[`
`]){for(let i=32;i<=126;i++)e.push(String.fromCharCode(i));return new j(e,t)}static fromAllPrintableInputOutput(t,e=[`
`]){const i=j.fromAllPrintable(t,e);return i.addInputOutput(),i.addUnrecognized(),i}static fromStringInputOutput(t,e){const i=Array.from(new Set(t)).join(""),s=new j(i.split(""),e);return s.addInputOutput(),s.addUnrecognized(),s.isSetup=!0,s}static fromArrayInputOutput(t,e){const i=[];for(let o=0;o<t.length;o++){const a=t[o];i.push(kt(a.input),kt(a.output))}const s=Array.isArray(i)?i.flat():i,n=new j(Array.from(new Set(s)),e);return n.addInputOutput(),n.addUnrecognized(),n.isSetup=!0,n}static fromString(t,e=0){const i=Array.from(new Set(t)).join("");return new j(i.split(""),e)}toJSON(){return{indexTable:this.indexTable,characterTable:this.characterTable,values:this.values,characters:this.characters,specialIndexes:this.specialIndexes}}static fromJSON(t){const e=new j;return e.indexTable=t.indexTable,e.characterTable=t.characterTable,e.values=t.values,e.characters=t.characters,e.specialIndexes=t.specialIndexes,e.isSetup=!0,e}addSpecial(t,e=null){const i=this.indexTable[t]=this.characters.length;this.characterTable[i]=e,this.specialIndexes.push(this.characters.length),this.characters.push(t)}toFunctionString(){return`
var characterTable = ${JSON.stringify(this.characterTable)};
var indexTable = ${JSON.stringify(this.indexTable)};
var characters = ${JSON.stringify(this.characters)};
var dataFormatter = {
  toIndexes: function ${this.toIndexes.toString()},
  toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},
  toCharacters: function ${this.toCharacters.toString()},
  toIndexesValue: function ${this.toIndexesValue.toString()},
};`}formatDataIn(t,e){var i;return t===void 0?[]:Array.isArray(t)&&typeof t[0]=="number"?t:!((i=this.indexTable)===null||i===void 0)&&i.hasOwnProperty("stop-input")?this.toIndexesInputOutput(t,e):this.toIndexes(t)}formatDataOut(t,e){return this.toCharacters(e).join("")}format(t){if(typeof t[0]=="number"&&!Array.isArray(t[0])&&(!t[0].hasOwnProperty("input")||!t[0].hasOwnProperty("output")))return t;const e=[];if(typeof t[0]=="string"||typeof t[0]=="number"||Array.isArray(t[0]))if(this.isSetup)for(let i=0,s=t.length;i<s;i++)e.push(this.formatDataIn(t[i]));else{this.setup(t);for(let i=0;i<t.length;i++)e.push(this.formatDataIn(kt(t[i])))}else if(t[0].input&&t[0].output){this.isSetup||this.setup(t);for(let i=0,s=t.length;i<s;i++)e.push(this.formatDataIn(kt(t[i].input),kt(t[i].output)))}else throw new Error("unrecognized data");return e}}function kt(r){if(typeof r=="string")return r;if(typeof r=="number"||typeof r=="boolean")return r.toString();if(Array.isArray(r)&&typeof r[0]=="string")return r;if(typeof r[0]=="boolean")return r.map(t=>t.toString());if(typeof r[0]=="number")return r.map(t=>t.toString());throw new Error("unrecognized value, expected string[], string, number[], number, boolean[], or boolean")}function Ss(r,t){r.rows=t.rows,r.columns=t.columns,r.weights=t.weights.slice(0),r.deltas=t.deltas.slice(0)}function vs(r,t,e){for(let i=0;i<t.weights.length;i++)r.weights[i]=t.weights[i]+e.weights[i],r.deltas[i]=0}function As(r,t,e){for(let i=0;i<r.deltas.length;i++)t.deltas[i]=r.deltas[i],e.deltas[i]=r.deltas[i]}function $s(r){for(let t=0;t<r.weights.length;t++)r.weights[t]=1,r.deltas[t]=0}function Is(r,t){r.rows=t.rows,r.columns=t.columns,r.weights=t.weights.slice(0),r.deltas=t.deltas.slice(0);for(let e=0;e<t.weights.length;e++)r.weights[e]=-t.weights[e],r.deltas[e]=0}function Es(r,t,e){const i=t.rows,s=t.columns,n=e.columns;for(let o=0;o<i;o++){const a=s*o,h=n*o;for(let u=0;u<n;u++){let l=0;for(let c=0;c<s;c++){const p=n*c,d=a+c,f=p+u;l+=t.weights[d]*e.weights[f],t.deltas[d]=0,e.deltas[f]=0}r.weights[h+u]=l}}}function zs(r,t,e){const i=t.rows,s=t.columns,n=e.columns;for(let o=0;o<i;o++){const a=s*o,h=n*o;for(let u=0;u<n;u++)for(let l=0;l<s;l++){const c=n*l,p=a+l,d=c+u,f=r.deltas[h+u];t.deltas[p]+=e.weights[d]*f,e.deltas[d]+=t.weights[p]*f}}}function Ds(r,t,e){const{weights:i}=t;for(let s=0;s<i.length;s++)r.weights[s]=t.weights[s]*e.weights[s],r.deltas[s]=0}function Ps(r,t,e){for(let i=0;i<t.weights.length;i++)t.deltas[i]=e.weights[i]*r.deltas[i],e.deltas[i]=t.weights[i]*r.deltas[i]}function Ms(r,t){for(let e=0;e<t.weights.length;e++)r.weights[e]=Math.max(0,t.weights[e]),r.deltas[e]=0}function _s(r,t){for(let e=0;e<r.deltas.length;e++)t.deltas[e]=t.weights[e]>0?r.deltas[e]:0}function Ts(r,t,e){const{columns:i}=t,s=i*e;for(let n=0;n<i;n++)r.weights[n]=t.weights[s+n],r.deltas[n]=0}function Fs(r,t,e){const{columns:i}=t,s=i*e;for(let n=0;n<i;n++)t.deltas[s+n]=r.deltas[n]}function Ks(r,t){for(let e=0;e<t.weights.length;e++)r.weights[e]=1/(1+Math.exp(-t.weights[e])),r.deltas[e]=0}function Ns(r,t){for(let e=0;e<r.deltas.length;e++){const i=r.weights[e];t.deltas[e]=i*(1-i)*r.deltas[e]}}function zt(r){const t=new L(r.rows,r.columns);let e=-999999;for(let s=0;s<r.weights.length;s++)r.weights[s]>e&&(e=r.weights[s]);let i=0;for(let s=0;s<r.weights.length;s++)t.weights[s]=Math.exp(r.weights[s]-e),i+=t.weights[s];for(let s=0;s<r.weights.length;s++)t.weights[s]/=i;return t}function Cs(r,t){for(let e=0;e<t.weights.length;e++)r.weights[e]=Math.tanh(t.weights[e]),r.deltas[e]=0}function Rs(r,t){for(let e=0;e<r.deltas.length;e++){const i=r.weights[e];t.deltas[e]=(1-i*i)*r.deltas[e]}}class ti{constructor(){this.states=[],this.inputRow=0}add(t,e){if(t.weights.length!==e.weights.length)throw new Error("misaligned matrices");const i=new L(t.rows,t.columns);return this.states.push({name:"add",product:i,left:t,right:e,forwardFn:vs,backpropagationFn:As}),i}allOnes(t,e){const i=new L(t,e);return this.states.push({name:"allOnes",product:i,left:i,forwardFn:$s,backpropagationFn:()=>{}}),i}cloneNegative(t){const e=new L(t.rows,t.columns);return this.states.push({name:"cloneNegative",product:e,left:t,forwardFn:Is,backpropagationFn:()=>{}}),e}subtract(t,e){if(t.weights.length!==e.weights.length)throw new Error("misaligned matrices");return this.add(this.add(this.allOnes(t.rows,t.columns),this.cloneNegative(t)),e)}multiply(t,e){if(t.columns!==e.rows)throw new Error("misaligned matrices");const i=new L(t.rows,e.columns);return this.states.push({name:"multiply",product:i,left:t,right:e,forwardFn:Es,backpropagationFn:zs}),i}multiplyElement(t,e){if(t.weights.length!==e.weights.length)throw new Error("misaligned matrices");const i=new L(t.rows,t.columns);return this.states.push({name:"multiplyElement",product:i,left:t,right:e,forwardFn:Ds,backpropagationFn:Ps}),i}relu(t){const e=new L(t.rows,t.columns);return this.states.push({name:"relu",product:e,left:t,forwardFn:Ms,backpropagationFn:_s}),e}input(t){return this.states.push({name:"input",product:t,forwardFn:e=>{if(!!this.inputValue){if(this.inputValue.length!==e.weights.length)throw new Error("this.inputValue is of wrong dimensions");e.weights=t.weights=this.inputValue}},backpropagationFn:()=>{}}),t}inputMatrixToRow(t){const e=this,i=new L(t.columns,1);return this.states.push({name:"inputMatrixToRow",product:i,left:t,get right(){return e.inputRow},forwardFn:Ts,backpropagationFn:Fs}),i}sigmoid(t){const e=new L(t.rows,t.columns);return this.states.push({name:"sigmoid",product:e,left:t,forwardFn:Ks,backpropagationFn:Ns}),e}tanh(t){const e=new L(t.rows,t.columns);return this.states.push({name:"tanh",product:e,left:t,forwardFn:Cs,backpropagationFn:Rs}),e}observe(t){return this.states.push({name:"observe",product:new L,forwardFn:()=>{},backpropagationFn:()=>{}}),t}runIndex(t=0){this.inputRow=t;let e=this.states[0];for(let i=0,s=this.states.length;i<s;i++)e=this.states[i],e.hasOwnProperty("forwardFn")&&e.forwardFn(e.product,e.left,e.right);return e.product}runInput(t){this.inputValue=t;let e=this.states[0];for(let i=0,s=this.states.length;i<s;i++)e=this.states[i],e.hasOwnProperty("forwardFn")&&e.forwardFn(e.product,e.left,e.right);return e.product}backpropagate(){let t=this.states.length,e=this.states[0];for(;t-- >0;)e=this.states[t],e.hasOwnProperty("backpropagationFn")&&e.backpropagationFn(e.product,e.left,e.right);return e.product}backpropagateIndex(t=0){this.inputRow=t;let e=this.states.length,i=this.states[0];for(;e-- >0;)i=this.states[e],i.hasOwnProperty("backpropagationFn")&&i.backpropagationFn(i.product,i.left,i.right);return i.product}predictTarget(t,e){let i=0;const s=this.runInput(t);for(let n=0;n<s.weights.length;n++){const o=s.weights[n]-e[n];i+=Math.abs(o),s.deltas[n]=o}return i}predictTargetIndex(t,e){const i=this.runIndex(t),s=i,n=zt(i);return s.deltas=n.weights.slice(0),s.deltas[e]-=1,-Math.log2(n.weights[e])}}function Xt(r){const{weights:t}=r;let e=t[0],i=0;for(let s=1;s<t.length;s++){const n=t[s];n<e||(i=s,e=n)}return i}function Yt(r){const t=nt(0,1),e=r.weights;let i=0,s=0;for(;;){if(i+=e[s],i>t)return s;s++}}const ht={iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,learningRate:.01,callbackPeriod:10,timeout:1/0},xt=()=>({inputSize:20,inputRange:20,hiddenLayers:[20,20],outputSize:20,decayRate:.999,smoothEps:1e-8,regc:1e-6,clipval:5,maxPredictionLength:100,dataFormatter:new j});class Ot{constructor(t={}){this.options={...xt()},this.trainOpts={...ht},this.stepCache={},this.runs=0,this.ratioClipped=0,this.model=Object.seal({isInitialized:!1,input:new L(0,0),hiddenLayers:[],output:new L(0,0),equations:[],allMatrices:[],equationConnections:[],outputConnector:new I(0,0,.08)}),this.initialLayerInputs=[],this.options={...this.options,...t},this.updateTrainingOptions({...ht}),t.json&&this.fromJSON(t.json)}initialize(){const{dataFormatter:t}=this.options;t!=null&&t.characters.length&&(this.options.inputSize=this.options.inputRange=this.options.outputSize=t.characters.length),this.model=this.mapModel()}createHiddenLayers(){const{hiddenLayers:t,inputSize:e}=this.options,i=[];i.push(this.getHiddenLayer(t[0],e));let s=t[0];for(let n=1;n<t.length;n++){const o=t[n];i.push(this.getHiddenLayer(o,s)),s=o}return i}getHiddenLayer(t,e){return{weight:new I(t,e,.08),transition:new I(t,t,.08),bias:new L(t,1)}}getEquation(t,e,i,s){if(!s.weight||!s.transition||!s.bias)throw new Error("hiddenLayer does not have expected properties");const n=t.relu.bind(t),o=t.add.bind(t),a=t.multiply.bind(t);return n(o(o(a(s.weight,e),a(s.transition,i)),s.bias))}createInputMatrix(){const{inputRange:t,inputSize:e}=this.options;if(t<1)throw new Error("this.options.inputRange not an expected number");if(e<1)throw new Error("this.options.inputSize not an expected number");return new I(t+1,e,.08)}createOutputMatrices(){const{outputSize:t,hiddenLayers:e}=this.options,i=Jt(e);return{outputConnector:new I(t+1,i,.08),output:new L(t+1,1)}}bindEquation(){const{model:t}=this,{hiddenLayers:e}=this.options,i=new ti,s=[],n=t.equationConnections.length>0?Jt(t.equationConnections):this.initialLayerInputs;let o=this.getEquation(i,i.inputMatrixToRow(t.input),n[0],t.hiddenLayers[0]);s.push(o);for(let a=1,h=e.length;a<h;a++){if(!n[a])throw new Error(`Cannot find equation at index ${a}`);o=this.getEquation(i,o,n[a],t.hiddenLayers[a]),s.push(o)}t.equationConnections.push(s),i.add(i.multiply(t.outputConnector,o),t.output),t.equations.push(i)}mapModel(){const t=[];this.initialLayerInputs=this.options.hiddenLayers.map(o=>new L(o,1));const e=this.createInputMatrix();t.push(e);const i=this.createHiddenLayers();if(!i.length)throw new Error("net.hiddenLayers not set");for(let o=0,a=i.length;o<a;o++){const h=i[o];for(const u in h)!h.hasOwnProperty(u)||t.push(h[u])}const{output:s,outputConnector:n}=this.createOutputMatrices();return t.push(n),t.push(s),Object.seal({isInitialized:!0,input:e,hiddenLayers:i,output:s,equations:[],allMatrices:t,equationConnections:[],outputConnector:n})}trainInput(t){this.runs++;const{model:e}=this,i=t.length;let s=0,n;for(;e.equations.length<=t.length+1;)this.bindEquation();for(let o=-1,a=t.length;o<a;o++){const h=o+1;n=e.equations[h];const u=o===-1?0:t[o]+1,l=o===i-1?0:t[o+1]+1;s+=n.predictTargetIndex(u,l)}return Math.pow(2,s/(i-1))/100}backpropagate(t){let e=t.length;const{model:i}=this,{equations:s}=i;for(;e>0;)s[e].backpropagateIndex(t[e-1]+1),e--;s[0].backpropagateIndex(0)}adjustWeights(){const{regc:t,clipval:e,decayRate:i,smoothEps:s}=this.options,{trainOpts:n,model:o,stepCache:a}=this,{learningRate:h}=n,{allMatrices:u}=o;let l=0,c=0;for(let p=0;p<u.length;p++){const d=u[p],{weights:f,deltas:x}=d;p in a||(a[p]=M(d.rows*d.columns));const g=a[p];for(let O=0;O<f.length;O++){let m=x[O];const v=f[O];g[O]=g[O]*i+(1-i)*m*m,m>e?(m=e,l++):m<-e&&(m=-e,l++),c++,f[O]=v+-h*m/Math.sqrt(g[O]+s)-t*v}}this.ratioClipped=l/c}get isRunnable(){return this.model&&this.model.equations.length===0?(console.error("No equations bound, did you run train()?"),!1):!0}checkRunnable(){if(!this.isRunnable)throw new Error("Network not runnable")}run(t=[],e=!1,i=1){const s=this.options.maxPredictionLength+(t!==null?t.length:0)+(this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0);this.checkRunnable();const n=this.options.dataFormatter&&t.length>0?this.options.dataFormatter.formatDataIn(t):t,{model:o}=this,a=[];let h=0;for(;;){const u=h===0?0:h<n.length?n[h-1]+1:a[h-1];for(;o.equations.length<=h;)this.bindEquation();const c=o.equations[h].runIndex(u),p=new L(o.output.rows,o.output.columns);if(Ss(p,c),i!==1&&e)for(let x=0,g=p.weights.length;x<g;x++)p.weights[x]/=i;const d=zt(p),f=e?Yt(d):Xt(d);if(h++,f===0||h>=s)break;a.push(f)}return this.options.dataFormatter.formatDataOut(n,a.slice(n.length).map(u=>u-1))}verifyIsInitialized(){this.model.isInitialized||this.initialize()}updateTrainingOptions(t){var e;this.trainOpts={...ht,...t},this.validateTrainingOptions(this.trainOpts),this.setLogMethod((e=t.log)!==null&&e!==void 0?e:this.trainOpts.log)}validateTrainingOptions(t){const e={iterations:()=>{const i=t.iterations;return typeof i=="number"&&i>0},errorThresh:()=>{const i=t.errorThresh;return typeof i=="number"&&i>0&&i<1},log:()=>{const i=t.log;return typeof i=="function"||typeof i=="boolean"},logPeriod:()=>{const i=t.logPeriod;return typeof i=="number"&&i>0},learningRate:()=>{const i=t.learningRate;return typeof i=="number"&&i>0&&i<1},callback:()=>{const i=t.callback;return typeof i=="function"||i===void 0},callbackPeriod:()=>{const i=t.callbackPeriod;return typeof i=="number"&&i>0},timeout:()=>{const i=t.timeout;return typeof i=="number"&&i>0}};for(const i in e){const s=t;if(!e[i]())throw new Error(`[${i}, ${s[i]}] is out of normal training range, your network will probably not train.`)}}setLogMethod(t){typeof t=="function"?this.trainOpts.log=t:t?this.trainOpts.log=console.log:this.trainOpts.log=!1}prepTraining(t,e){var i;this.updateTrainingOptions(e);const s=this.options.dataFormatter.format(t),n=Date.now()+((i=this.trainOpts.timeout)!==null&&i!==void 0?i:0),o={error:1,iterations:0};return this.verifyIsInitialized(),{preparedData:s,status:o,endTime:n}}train(t,e={}){var i;this.trainOpts=e={...ht,...e};const{iterations:s,errorThresh:n,logPeriod:o,callback:a,callbackPeriod:h}=this.trainOpts,u=e.log===!0?console.log:e.log;let l=1/0,c,p;if(!((i=this.options)===null||i===void 0)&&i.dataFormatter)p=this.options.dataFormatter.format(t);else if(Array.isArray(t)&&Array.isArray(t[0])&&typeof t[0][0]=="number")p=t;else throw new Error("training not in expected format of number[][]");for(this.verifyIsInitialized(),c=0;c<s&&l>n;c++){let d=0;for(let f=0;f<p.length;f++){const x=this.trainPattern(p[f],!0);d+=x}if(l=d/t.length,isNaN(l))throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");u&&c%o===0&&u(`iterations: ${c}, training error: ${l}`),a&&c%h===0&&a({error:l,iterations:c})}return{error:l,iterations:c}}addFormat(t){}formatData(t){const e=[];for(let i=0;i<t.length;i++)e.push(this.options.dataFormatter.formatDataIn(t[i]));return e}toJSON(){this.model.isInitialized||this.initialize();const{model:t,options:e}=this;return{type:this.constructor.name,options:{...e,dataFormatter:e.dataFormatter.toJSON()},trainOpts:{...this.trainOpts,timeout:this.trainOpts.timeout===1/0?"Infinity":this.trainOpts.timeout},input:t.input.toJSON(),hiddenLayers:t.hiddenLayers.map(i=>{const s={};for(const n in i)!i.hasOwnProperty(n)||(s[n]=i[n].toJSON());return s}),outputConnector:this.model.outputConnector.toJSON(),output:this.model.output.toJSON()}}fromJSON(t){const{options:e}=t,i=[],s=L.fromJSON(t.input);i.push(s);const n=[];t.hiddenLayers.forEach(h=>{const u={};for(const l in h)u[l]=L.fromJSON(h[l]),i.push(u[l]);n.push(u)});const o=L.fromJSON(t.outputConnector);i.push(o);const a=L.fromJSON(t.output);return i.push(a),e.dataFormatter?this.options={...xt(),...e,dataFormatter:j.fromJSON(e.dataFormatter)}:this.options={...xt(),...e,dataFormatter:new j},this.model=Object.seal({isInitialized:!0,input:s,hiddenLayers:n,output:a,allMatrices:i,outputConnector:o,equations:[],equationConnections:[]}),this.initialLayerInputs=this.options.hiddenLayers.map(h=>new L(h,1)),this.bindEquation(),this}toFunction(t){const{model:e}=this,{equations:i}=this.model,s=i[1],{states:n}=s,o=JSON.stringify(this.toJSON());function a(g){const O=e.equationConnections[0],{states:m}=i[0];for(let v=0,_=m.length;v<_;v++)if(m[v].product===g)return v;return O.indexOf(g)}function h(g,O){for(let m=0,v=n.length;m<v;m++){const _=n[m];if(m===O){const T=a(g);return T>-1&&(g===_.left||g===_.right)?`typeof prevStates[${T}] === 'object' ? prevStates[${T}].product : new Matrix(${g.rows}, ${g.columns})`:`new Matrix(${g.rows}, ${g.columns})`}if(g===_.product)return`states[${m}].product`;if(g===_.right)return`states[${m}].right`;if(g===_.left)return`states[${m}].left`}return""}function u(g,O){if(!g||!g.rows||!g.columns)return"null";if(g===e.input)return"json.input";if(g===e.outputConnector)return"json.outputConnector";if(g===e.output)return"json.output";for(let m=0,v=e.hiddenLayers.length;m<v;m++){const _=e.hiddenLayers[m];for(const T in _)if(!!_.hasOwnProperty(T)&&_[T]===g)return`json.hiddenLayers[${m}].${T}`}return h(g,O)}function l(g){const O=g.toString().split("{");O.shift();const v=O.join("{").split("}");return v.pop(),v.join("}").split(`
`).join(`
        `).replace("product.deltas[i] = 0;","").replace("product.deltas[column] = 0;","").replace("left.deltas[leftIndex] = 0;","").replace("right.deltas[rightIndex] = 0;","").replace("product.deltas = left.deltas.slice(0);","")}function c(g){return`src/recurrent/matrix/${g.replace(/[A-Z]/g,function(O){return`-${O.toLowerCase()}`})}.js`}const p=[],d={},f=[];for(let g=0,O=n.length;g<O;g++){const m=n[g];p.push(`states[${g}] = {
      name: '${m.forwardFn.name}',
      left: ${m.left?u(m.left,g):"undefined"},
      right: ${m.right?u(m.right,g):"undefined"},
      product: ${u(m.product,g)}
    }`);const v=m.forwardFn.name;d[v]||(d[v]=!0,f.push(`        case '${v}': //compiled from ${c(v)}
          ${l(m.forwardFn.toString())}
          break;`))}const x=`
  if (typeof rawInput === 'undefined') rawInput = [];
  if (typeof isSampleI === 'undefined') isSampleI = false;
  if (typeof temperature === 'undefined') temperature = 1;
  var json = ${o};
  ${this.options.dataFormatter?`${this.options.dataFormatter.toFunctionString()};
  Object.assign(dataFormatter, json.options.dataFormatter);`:""}
  ${this.options.dataFormatter&&typeof this.options.dataFormatter.formatDataIn=="function"?`const formatDataIn = function (input, output) { ${l(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);`:""}
  ${this.options.dataFormatter!==null&&typeof this.options.dataFormatter.formatDataOut=="function"?`const formatDataOut = function formatDataOut(input, output) { ${l(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);`:""}
  var maxPredictionLength =
    ${this.options.maxPredictionLength} +
    rawInput.length +
    ${this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0};
  var input = ${this.options.dataFormatter&&typeof this.options.dataFormatter.formatDataIn=="function"?"formatDataIn(rawInput)":"rawInput"};
  var _i = 0;
  var output = [];
  var states = [];
  var prevStates;
  while (true) {
    var previousIndex = (_i === 0
        ? 0
        : _i < input.length
          ? input[_i - 1] + 1
          : output[_i - 1])
          ;
    var rowPluckIndex = previousIndex;
    prevStates = states;
    states = [];
    ${p.join(`;
    `)};
    for (var stateIndex = 0, stateMax = ${p.length}; stateIndex < stateMax; stateIndex++) {
      var state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;
      switch (state.name) {
${f.join(`
`)}
      }
    }

    var logProbabilities = state.product;
    if (temperature !== 1 && isSampleI) {
      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {
        logProbabilities.weights[q] /= temperature;
      }
    }

    var probs = softmax(logProbabilities);
    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);

    _i++;
    if (nextIndex === 0) {
      break;
    }
    if (_i >= maxPredictionLength) {
      break;
    }

    output.push(nextIndex);
  }
  ${this.options.dataFormatter&&typeof this.options.dataFormatter.formatDataOut=="function"?"return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))":"return output.slice(input.length).map(function(value) { return value - 1; })"};
  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = zeros(rows * columns);
  }
  ${M.toString()}
  ${zt.toString().replace("_1.Matrix","Matrix")}
  ${nt.toString()}
  ${Yt.toString()}
  ${Xt.toString()}`;return new Function("rawInput","isSampleI","temperature",t?t(x):x)}trainPattern(t,e){const i=this.trainInput(t);return this.backpropagate(t),this.adjustWeights(),e?i:0}}function Jt(r){return r[r.length-1]}class ei extends Ot{getHiddenLayer(t,e){return ii(t,e)}getEquation(t,e,i,s){return ri(t,e,i,s)}}function ii(r,t){return{updateGateInputMatrix:new I(r,t,.08),updateGateHiddenMatrix:new I(r,r,.08),updateGateBias:new L(r,1),resetGateInputMatrix:new I(r,t,.08),resetGateHiddenMatrix:new I(r,r,.08),resetGateBias:new L(r,1),cellWriteInputMatrix:new I(r,t,.08),cellWriteHiddenMatrix:new I(r,r,.08),cellWriteBias:new L(r,1)}}function ri(r,t,e,i){if(!i.updateGateInputMatrix||!i.updateGateHiddenMatrix||!i.updateGateBias||!i.resetGateInputMatrix||!i.resetGateHiddenMatrix||!i.resetGateBias||!i.cellWriteInputMatrix||!i.cellWriteHiddenMatrix||!i.cellWriteBias)throw new Error("hiddenLayer does not have expected properties");const s=r.sigmoid.bind(r),n=r.add.bind(r),o=r.multiply.bind(r),a=r.multiplyElement.bind(r),h=r.tanh.bind(r),u=r.allOnes.bind(r),l=r.cloneNegative.bind(r),c=s(n(n(o(i.updateGateInputMatrix,t),o(i.updateGateHiddenMatrix,e)),i.updateGateBias)),p=s(n(n(o(i.resetGateInputMatrix,t),o(i.resetGateHiddenMatrix,e)),i.resetGateBias)),d=h(n(n(o(i.cellWriteInputMatrix,t),o(i.cellWriteHiddenMatrix,a(p,e))),i.cellWriteBias));return n(a(n(u(c.rows,c.columns),l(c)),d),a(e,c))}class si{constructor(t,e){this.prop=e,this.length=0,this.table={};for(let i=0;i<t.length;i++){const n=t[i][e];for(let o=0;o<n.length;o++){const a=n[o];for(const h in a)!a.hasOwnProperty(h)||this.table.hasOwnProperty(h)||(this.table[h]=this.length++)}}}}const ni=()=>({...xt(),inputSize:1,hiddenLayers:[20],outputSize:1,inputRange:0});class Dt extends Ot{constructor(t={}){super(),this.inputLookupLength=0,this.inputLookup=null,this.outputLookup=null,this.outputLookupLength=0,this.model=Object.seal({isInitialized:!1,hiddenLayers:[],output:new L(0,0),equations:[],allMatrices:[],equationConnections:[],outputConnector:new I(0,0,.08)}),this.options=ni(),this.options={...this.options,...t},this.updateTrainingOptions({...js,...t}),t.json&&this.fromJSON(t.json)}createInputMatrix(){throw new Error("Input Matrices do not exist on RNNTimeStep")}createOutputMatrices(){const{outputSize:t}=this.options,e=Jt(this.options.hiddenLayers),i=new I(t,e,.08);return{output:new I(t,1,.08),outputConnector:i}}bindEquation(){const{model:t,options:e}=this,{hiddenLayers:i,inputSize:s}=e,n=t.hiddenLayers,o=new ti,a=[],h=t.equationConnections.length>0?t.equationConnections[t.equationConnections.length-1]:this.initialLayerInputs;let u=this.getEquation(o,o.input(new L(s,1)),h[0],n[0]);a.push(u);for(let l=1,c=i.length;l<c;l++)u=this.getEquation(o,u,h[l],n[l]),a.push(u);t.equationConnections.push(a),o.add(o.multiply(t.outputConnector,u),t.output),t.equations.push(o)}initialize(){this.model=this.mapModel()}mapModel(){const t=[];this.initialLayerInputs=this.options.hiddenLayers.map(n=>new L(n,1));const e=this.createHiddenLayers();for(let n=0,o=e.length;n<o;n++){const a=e[n];for(const h in a)!a.hasOwnProperty(h)||t.push(a[h])}const{outputConnector:i,output:s}=this.createOutputMatrices();return t.push(i),t.push(s),Object.seal({isInitialized:!0,hiddenLayers:e,output:s,equations:[],allMatrices:t,equationConnections:[],outputConnector:i})}backpropagate(){for(let t=this.model.equations.length-1;t>-1;t--)this.model.equations[t].backpropagate()}run(t){const e=k.dataShape(t).join(",");switch(e){case"array,number":return this.runArray(t);case"array,array,number":return this.runArrayOfArray(t);case"object,number":return this.runObject(t);case"array,object,number":return this.runArrayOfObject(t);default:throw new Error(`Unrecognized data shape ${e}`)}}forecast(t,e=1){const i=k.dataShape(t).join(",");switch(i){case"array,number":return this.forecastArray(t,e);case"array,array,number":return this.forecastArrayOfArray(t,e);case"object,number":return this.runObject(t);case"array,object,number":return this.forecastArrayOfObject(t,e);default:throw new Error(`Unrecognized data shape ${i}`)}}forecastArray(t,e=1){this.checkRunnable();const{model:i}=this,{equations:s}=i,n=t.length+e;for(;s.length<=n;)this.bindEquation();let o,a=0;if(this.options.inputSize===1)for(let u=0;u<t.length;u++)o=s[a++].runInput(Float32Array.from([t[u]]));else for(let u=0;u<t.length;u++)o=s[a++].runInput(Float32Array.from([]));if(!o)throw new Error("lastOutput not set");const h=[o.weights[0]];for(let u=0,l=e-1;u<l;u++)o=s[a++].runInput(o.weights),h.push(o.weights[0]);return this.end(),Float32Array.from(h)}forecastArrayOfArray(t,e=1){this.checkRunnable();const{model:i}=this,{equations:s}=i,n=t.length+e;for(;s.length<=n;)this.bindEquation();let o,a=0;for(let u=0;u<t.length;u++)o=s[a++].runInput(t[u]);if(!o)throw new Error("lastOutput not set");const h=[Float32Array.from(o.weights)];for(let u=0,l=e-1;u<l;u++)o=s[a++].runInput(o.weights),h.push(Float32Array.from(o.weights.slice(0)));return this.end(),h}forecastArrayOfObject(t,e=1){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");const i=t.map(s=>k.toArray(this.inputLookup,s,this.inputLookupLength));return this.forecastArrayOfArray(i,e).map(s=>k.toObject(this.outputLookup,s))}train(t,e={}){this.trainOpts=e={...ht,...e},this.options.inputSize===1&&this.options.outputSize===1&&this.setSize(t),this.verifySize();const i=this.formatData(t);let s=1/0,n;this.verifyIsInitialized();const{iterations:o,errorThresh:a,logPeriod:h,callback:u,callbackPeriod:l}=this.trainOpts,c=e.log===!0?console.log:e.log;for(n=0;n<o&&s>a;n++){let p=0;for(let d=0;d<i.length;d++){const f=this.trainPattern(i[d],!0);p+=f}if(s=p/i.length,isNaN(s))throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");c&&n%h===0&&c(`iterations: ${n}, training error: ${s}`),u&&n%l===0&&u({error:s,iterations:n})}return{error:s,iterations:n}}trainArrayOfArray(t){if(t.length<2)throw new Error("input must be an array of 2 or more");const{equations:e}=this.model;for(;e.length<t.length;)this.bindEquation();let i=0;for(let s=0,n=t.length-1;s<n;s++)i+=e[s].predictTarget(t[s],t[s+1]);return this.end(),i/t.length}trainPattern(t,e){const i=this.trainArrayOfArray(t);return this.backpropagate(),this.adjustWeights(),e?i:0}setSize(t){let e=0;switch(k.dataShape(t).join(",")){case"array,array,number":case"array,object,number":case"array,datum,array,number":case"array,datum,object,number":e=1;break;case"array,array,array,number":e=t[0][0].length;break;case"array,array,object,number":e=Object.keys(k.toTable2D(t)).length;break;case"array,datum,array,array,number":e=t[0].input[0].length;break;case"array,datum,array,object,number":e=Object.keys(k.toInputTable2D(t)).length;break;default:throw new Error("unknown data shape or configuration")}this.options=Object.seal({...this.options,inputSize:e,outputSize:e})}verifySize(){if((this.options.inputSize||this.options.outputSize)&&this.options.inputSize!==this.options.outputSize)throw new Error("manually set inputSize and outputSize mismatch")}runArray(t){this.checkRunnable();const{equations:e}=this.model;for(;e.length<=t.length;)this.bindEquation();let i;for(let s=0;s<t.length;s++)i=e[s].runInput(new Float32Array([t[s]]));return this.end(),i.weights[0]}runArrayOfArray(t){this.checkRunnable();const{model:e}=this,{equations:i}=e;for(;i.length<=t.length;)this.bindEquation();let s;for(let n=0;n<t.length;n++)s=i[n].runInput(t[n]).weights;return this.end(),s!=null?s:Float32Array.from([])}runObject(t){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");if(!this.outputLookupLength)throw new Error("this.outputLookupLength not set");if(this.inputLookup===this.outputLookup){const e=k.toArrayShort(this.inputLookup,t);return k.toObjectPartial(this.outputLookup,this.forecastArray(e,this.outputLookupLength-e.length),e.length)}return k.toObject(this.outputLookup,this.forecastArray(k.toArray(this.inputLookup,t,this.inputLookupLength),this.outputLookupLength))}runArrayOfObject(t){if(this.inputLookup===null)throw new Error("this.inputLookup not set");if(this.outputLookup===null)throw new Error("this.outputLookup not set");const e=t.map(i=>k.toArray(this.inputLookup,i,this.inputLookupLength));return this.forecastArrayOfArray(e,1).map(i=>k.toObject(this.outputLookup,i))[0]}runArrayOfObjectOfArray(t){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");return k.toObject(this.outputLookup,this.runArrayOfArray(k.toArrays(this.inputLookup,t,this.inputLookupLength)))}end(){this.model.equations[this.model.equations.length-1].runInput(new Float32Array(this.options.outputSize))}requireInputOutputOfOne(){if(this.options.inputSize!==1)throw new Error("inputSize must be 1 for this data size");if(this.options.outputSize!==1)throw new Error("outputSize must be 1 for this data size")}formatArray(t){const e=[];this.requireInputOutputOfOne();for(let i=0;i<t.length;i++)e.push(Float32Array.from([t[i]]));return[e]}formatArrayOfArray(t){const e=[],{inputSize:i,outputSize:s}=this.options;if(i===1&&s===1){for(let n=0;n<t.length;n++)e.push(as(t[n]));return e}if(i!==t[0].length)throw new Error("inputSize must match data input size");if(s!==t[0].length)throw new Error("outputSize must match data output size");for(let n=0;n<t.length;n++)e.push(Float32Array.from(t[n]));return[e]}formatArrayOfObject(t){if(this.requireInputOutputOfOne(),!this.inputLookup){const i=new X(t);this.inputLookup=this.outputLookup=i.table,this.inputLookupLength=this.outputLookupLength=i.length}const e=[];for(let i=0;i<t.length;i++)e.push(cs(t[i]));return e}formatArrayOfObjectMulti(t){if(!this.inputLookup){const i=new X(t);this.inputLookup=this.outputLookup=i.table,this.inputLookupLength=this.outputLookupLength=i.length}const e=[];for(let i=0;i<t.length;i++)e.push([Be(t[i],this.inputLookup,this.inputLookupLength)]);return e}formatArrayOfDatumOfArray(t){const e=[];this.requireInputOutputOfOne();for(let i=0;i<t.length;i++){const s=t[i];e.push(hs(s.input,s.output))}return e}formatArrayOfDatumOfObject(t){if(this.requireInputOutputOfOne(),!this.inputLookup){const i=new X(t,"input");this.inputLookup=i.table,this.inputLookupLength=i.length}if(!this.outputLookup){const i=new X(t,"output");this.outputLookup=i.table,this.outputLookupLength=i.length}const e=[];for(let i=0;i<t.length;i++){const s=t[i];e.push(ps(s.input,s.output))}return e}formatArrayOfArrayOfArray(t){const e=[];for(let i=0;i<t.length;i++)e.push(ns(t[i]));return e}formatArrayOfArrayOfObject(t){if(!this.inputLookup){const i=new X(t);this.inputLookup=this.outputLookup=i.table,this.inputLookupLength=this.outputLookupLength=i.length}const e=[];for(let i=0;i<t.length;i++){const s=[];for(let n=0;n<t[i].length;n++)s.push(Be(t[i][n],this.inputLookup,this.inputLookupLength));e.push(s)}return e}formatArrayOfDatumOfArrayOfArray(t){const e=[],{inputSize:i,outputSize:s}=this.options;if(i!==t[0].input[0].length)throw new Error("inputSize must match data input size");if(s!==t[0].output[0].length)throw new Error("outputSize must match data output size");for(let n=0;n<t.length;n++){const o=t[n];e.push(os(o.input,o.output))}return e}formatArrayOfDatumOfArrayOfObject(t){if(!this.inputLookup){const i=new si(t,"input");this.inputLookup=i.table,this.inputLookupLength=i.length}if(!this.outputLookup){const i=new si(t,"output");this.outputLookup=i.table,this.outputLookupLength=i.length}if(!this.outputLookupLength)throw new Error("this.outputLookupLength not set to usable number");const e=[];for(let i=0;i<t.length;i++){const s=t[i];e.push(ls(s.input,s.output,this.inputLookup,this.outputLookup,this.inputLookupLength,this.outputLookupLength))}return e}formatData(t){switch(k.dataShape(t).join(",")){case"array,number":return this.formatArray(t);case"array,array,number":return this.formatArrayOfArray(t);case"array,object,number":return this.options.inputSize===1?this.formatArrayOfObject(t):this.formatArrayOfObjectMulti(t);case"array,datum,array,number":return this.formatArrayOfDatumOfArray(t);case"array,datum,object,number":return this.formatArrayOfDatumOfObject(t);case"array,array,array,number":return this.formatArrayOfArrayOfArray(t);case"array,array,object,number":return this.formatArrayOfArrayOfObject(t);case"array,datum,array,array,number":return this.formatArrayOfDatumOfArrayOfArray(t);case"array,datum,array,object,number":return this.formatArrayOfDatumOfArrayOfObject(t);default:throw new Error("unknown data shape or configuration")}}test(t){const e=[];let i=0;const s=this.formatData(t);for(let n=0;n<s.length;n++){const o=s[n],a=this.run(o.splice(0,o.length-1)),h=o[o.length-1];let u=0,l=0;for(let p=0;p<a.length;p++){l++;const d=h[p]-a[p];u+=d*d}if(i+=u/l,Math.abs(u)>this.trainOpts.errorThresh){const p=t[n];e.push({value:p,actual:a})}}return{error:i/s.length,misclasses:e,total:s.length}}addFormat(t){var e,i,s,n,o,a;switch(k.dataShape(t).join(",")){case"array,array,number":case"datum,array,array,number":case"array,number":case"datum,array,number":return;case"datum,object,number":{this.inputLookup=k.addKeys(t.input,(e=this.inputLookup)!==null&&e!==void 0?e:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length),this.outputLookup=k.addKeys(t.output,(i=this.outputLookup)!==null&&i!==void 0?i:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length);break}case"object,number":{this.inputLookup=this.outputLookup=k.addKeys(t,(s=this.inputLookup)!==null&&s!==void 0?s:{}),this.inputLookup&&(this.inputLookupLength=this.outputLookupLength=Object.keys(this.inputLookup).length);break}case"array,object,number":{const u=t;for(let l=0;l<u.length;l++)this.inputLookup=this.outputLookup=k.addKeys(u[l],(n=this.inputLookup)!==null&&n!==void 0?n:{}),this.inputLookup&&(this.inputLookupLength=this.outputLookupLength=Object.keys(this.inputLookup).length);break}case"datum,array,object,number":{const u=t,l=u.input;for(let p=0;p<l.length;p++)this.inputLookup=k.addKeys(l[p],(o=this.inputLookup)!==null&&o!==void 0?o:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length);const c=u.output;for(let p=0;p<c.length;p++)this.outputLookup=k.addKeys(c[p],(a=this.outputLookup)!==null&&a!==void 0?a:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length);break}default:throw new Error("unknown data shape or configuration")}}toJSON(){this.model||this.initialize();const{model:t}=this,e={...this.options,...xt};return{type:this.constructor.name,options:e,hiddenLayers:t.hiddenLayers.map(i=>{const s={};for(const n in i)!i.hasOwnProperty(n)||(s[n]=i[n].toJSON());return s}),outputConnector:t.outputConnector.toJSON(),output:t.output.toJSON(),inputLookup:this.inputLookup,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup,outputLookupLength:this.outputLookupLength}}fromJSON(t){const{options:e}=t,i=[],s=[];t.hiddenLayers.forEach(a=>{const h={};for(const u in a)h[u]=L.fromJSON(a[u]),i.push(h[u]);s.push(h)});const n=L.fromJSON(t.outputConnector);i.push(n);const o=L.fromJSON(t.output);return i.push(o),this.options={...ni(),...e},this.inputLookup=t.inputLookup,this.inputLookupLength=t.inputLookupLength,this.outputLookup=t.outputLookup,this.outputLookupLength=t.outputLookupLength,this.model=Object.seal({isInitialized:!0,hiddenLayers:s,output:o,allMatrices:i,outputConnector:n,equations:[],equationConnections:[]}),this.initialLayerInputs=e.hiddenLayers.map(a=>new L(a,1)),this.bindEquation(),this}toFunction(t){const{model:e,inputLookup:i,inputLookupLength:s,outputLookup:n,outputLookupLength:o}=this,{inputSize:a}=this.options,{equations:h}=e,u=h[1],{states:l}=u,c=JSON.stringify(this.toJSON());function p(b){const K=e.equationConnections[0],{states:S}=h[0];for(let P=0,C=S.length;P<C;P++)if(S[P].product===b)return P;return K.indexOf(b)}function d(b,K){for(let S=0,P=l.length;S<P;S++){const C=l[S];if(S===K){const q=p(b);switch(b){case C.left:if(q>-1)return`typeof prevStates[${q}] === 'object' ? prevStates[${q}].product : new Matrix(${b.rows}, ${b.columns})`;case C.right:if(q>-1)return`typeof prevStates[${q}] === 'object' ? prevStates[${q}].product : new Matrix(${b.rows}, ${b.columns})`;case C.product:return`new Matrix(${b.rows}, ${b.columns})`;default:throw Error("unknown state")}}if(b===C.product)return`states[${S}].product`;if(b===C.right)return`states[${S}].right`;if(b===C.left)return`states[${S}].left`}return""}function f(b,K){if(!b||!b.rows||!b.columns)return"null";if(b===e.outputConnector)return"json.outputConnector";if(b===e.output)return"json.output";for(let S=0,P=e.hiddenLayers.length;S<P;S++){const C=e.hiddenLayers[S];for(const q in C)if(!!C.hasOwnProperty(q)&&C[q]===b)return`json.hiddenLayers[${S}].${q}`}return d(b,K)}function x(){return i?a===1?i===n?`function lookupInput(input) {
            var table = ${JSON.stringify(i)};
            var result = [];
            for (var p in table) {
              if (!input.hasOwnProperty(p)) break;
              result.push(Float32Array.from([input[p]]));
            }
            return result;
          }`:`function lookupInput(input) {
          var table = ${JSON.stringify(i)};
          var result = [];
          for (var p in table) {
            result.push(Float32Array.from([input[p]]));
          }
          return result;
        }`:`function lookupInput(rawInputs) {
        var table = ${JSON.stringify(i)};
        var result = [];
        for (var i = 0; i < rawInputs.length; i++) {
          var rawInput = rawInputs[i];
          var input = new Float32Array(${s});
          for (var p in table) {
            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;
          }
          result.push(input);
        }
        return result;
      }`:""}function g(){return n?a===1?i===n?`function lookupOutputPartial(output, input) {
            var table = ${JSON.stringify(n)};
            var offset = input.length;
            var result = {};
            var i = 0;
            for (var p in table) {
              if (i++ < offset) continue;
              result[p] = output[table[p] - offset][0];
            }
            return result;
          }`:`function lookupOutput(output) {
          var table = ${JSON.stringify(n)};
          var result = {};
          for (var p in table) {
            result[p] = output[table[p]][0];
          }
          return result;
        }`:`function lookupOutput(output) {
        var table = ${JSON.stringify(n)};
        var result = {};
        for (var p in table) {
          result[p] = output[table[p]];
        }
        return result;
      }`:""}function O(b){const K=b.toString().split("{");K.shift();const P=K.join("{").split("}");return P.pop(),P.join("}").split(`
`).join(`
        `).replace("product.deltas[i] = 0;","").replace("product.deltas[column] = 0;","").replace("left.deltas[leftIndex] = 0;","").replace("right.deltas[rightIndex] = 0;","").replace("product.deltas = left.deltas.slice(0);","")}function m(b){return`src/recurrent/matrix/${b.replace(/[A-Z]/g,function(K){return`-${K.toLowerCase()}`})}.js`}const v=[],_={},T=[];for(let b=0,K=l.length;b<K;b++){const S=l[b];v.push(`states[${b}] = {
      name: '${S.forwardFn.name}',
      left: ${S.left?f(S.left,b):"undefined"},
      right: ${S.right?f(S.right,b):"undefined"},
      product: ${f(S.product,b)}
    }`);const P=S.forwardFn.name;_[P]||(_[P]=!0,S.name==="input"?(T.push(`case '${P}':`),T.push(i&&a===1?"product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;":a===1?"product.weights = [input[_i]];":"product.weights = input[_i];"),T.push("break;")):T.push(`        case '${P}':${P!=="forwardFn"?` //compiled from ${m(P)}`:""}
          ${O(S.forwardFn.toString())}
          break;`))}const St=a===1&&this.outputLookup,W=`
  var input = ${this.inputLookup?"lookupInput(rawInput)":"rawInput"};
  var json = ${c};
  var output = [];
  var states = [];
  var prevStates;
  var state;
  var max = ${St?i===n?s:`input.length + ${o-1}`:"input.length"};
  for (var _i = 0; _i < max; _i++) {
    prevStates = states;
    states = [];
    ${v.join(`;
    `)};
    for (var stateIndex = 0, stateMax = ${v.length}; stateIndex < stateMax; stateIndex++) {
      state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;

      switch (state.name) {
${T.join(`
`)}
      }
    }
    ${a===1&&i?"if (_i >= input.length - 1) { output.push(state.product.weights); }":"output = state.product.weights;"}
  }
  ${n?n===i?"return lookupOutputPartial(output, input)":"return lookupOutput(output)":a===1?"return output[0]":"return output"};
  ${x()}
  ${g()}

  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = new Float32Array(rows * columns);
  }
  ${zt.toString().replace("_2.default","Matrix")}
  ${nt.toString()}
  ${Yt.toString()}
  ${Xt.toString()}`;return new Function("rawInput",t?t(W):W)}}const js={...ht};class oi extends Dt{getHiddenLayer(t,e){return ii(t,e)}getEquation(t,e,i,s){return ri(t,e,i,s)}}class ai extends Ot{getHiddenLayer(t,e){return hi(t,e)}getEquation(t,e,i,s){return ui(t,e,i,s)}}function hi(r,t){return{inputMatrix:new I(r,t,.08),inputHidden:new I(r,r,.08),inputBias:new L(r,1),forgetMatrix:new I(r,t,.08),forgetHidden:new I(r,r,.08),forgetBias:new L(r,1),outputMatrix:new I(r,t,.08),outputHidden:new I(r,r,.08),outputBias:new L(r,1),cellActivationMatrix:new I(r,t,.08),cellActivationHidden:new I(r,r,.08),cellActivationBias:new L(r,1)}}function ui(r,t,e,i){if(!i.inputMatrix||!i.inputHidden||!i.inputBias||!i.forgetMatrix||!i.forgetHidden||!i.forgetBias||!i.outputMatrix||!i.outputHidden||!i.outputBias||!i.cellActivationMatrix||!i.cellActivationHidden||!i.cellActivationBias)throw new Error("hiddenLayer does not have expected properties");const s=r.sigmoid.bind(r),n=r.add.bind(r),o=r.multiply.bind(r),a=r.multiplyElement.bind(r),h=r.tanh.bind(r),u=s(n(n(o(i.inputMatrix,t),o(i.inputHidden,e)),i.inputBias)),l=s(n(n(o(i.forgetMatrix,t),o(i.forgetHidden,e)),i.forgetBias)),c=s(n(n(o(i.outputMatrix,t),o(i.outputHidden,e)),i.outputBias)),p=h(n(n(o(i.cellActivationMatrix,t),o(i.cellActivationHidden,e)),i.cellActivationBias)),d=a(l,e),f=a(u,p),x=n(d,f);return a(c,h(x))}class li extends Dt{getHiddenLayer(t,e){return hi(t,e)}getEquation(t,e,i,s){return ui(t,e,i,s)}}function Ws(r,t){const e=[];for(;r<t;r++)e.push(r);return e}function Hs(r){return Array.isArray(r)?Float32Array.from(r):Float32Array.from(Object.values(r))}function Bs({pixelX:r,pixelY:t,radius:e,inputs:i,row:s,line:n,fontSize:o,fontClassName:a}){let h=`<rect
              x="${r/2-e}"
              y="${t/2+s*t-e}"
              width="${2*e}"
              height="${2*e}"
              stroke="black"
              stroke-width="1"
              fill="${i.color}"
              class="${i.className}" />
            <line
              x1="${r/4}"
              y1="${t/2+s*t}"
              x2="${r/2-e}"
              y2="${t/2+s*t}"
              style="stroke:${n.color};stroke-width:${n.width}"
              class="${n.className}" />`;return i.labels&&(h+=`<text
              x="${r/8}"
              y="${t/2+s*t-5}"
              fill="black"
              font-size="${o}"
              class="${a}">${i.labels[s]}</text>`),h}function qs({pixelX:r,pixelY:t,row:e,column:i,radius:s,hidden:n}){return`<circle
            cx="${r/2+i*r}"
            cy="${t/2+e*t}"
            r="${s}"
            stroke="black"
            stroke-width="1"
            fill="${n.color}"
            class="${n.className}" />`}function Gs({pixelX:r,pixelY:t,row:e,column:i,line:s,outputs:n,radius:o}){return`<circle
            cx="${r/2+i*r}"
            cy="${t/2+e*t}"
            r="${o}"
            stroke="black"
            stroke-width="1"
            fill="${n.color}"
            class="${n.className}" />
          <line
            x1="${r/2+i*r+o}"
            y1="${t/2+e*t}"
            x2="${r/2+i*r+r/4}"
            y2="${t/2+e*t}"
            style="stroke:${s.color};stroke-width:${s.width}"
            class="${s.className}" />`}function Xs({pixelX:r,pixelY:t,row:e,column:i,radius:s,lineY:n,line:o,previousConnectionIndex:a}){return`<line
            x1="${r/2+(i-1)*r+s}"
            y1="${n/2+a*n}"
            x2="${r/2+i*r-s}"
            y2="${t/2+e*t}"
            style="stroke:${o.color};stroke-width:${o.width}"
            class="${o.className}" />`}function Vt(r){const{sizes:t,height:e,width:i}=r;let s="";const n=i/t.length;for(let o=0;o<t.length;o++){const a=t[o],h=e/a;for(let u=0;u<a;u++)if(o===0)s+=Bs({pixelX:n,pixelY:h,row:u,column:o,...r});else{o===t.length-1?s+=Gs({pixelX:n,pixelY:h,row:u,column:o,...r}):s+=qs({pixelX:n,pixelY:h,row:u,column:o,...r});const l=t[o-1],c=e/l;for(let p=0;p<l;p++)s+=Xs({pixelX:n,pixelY:h,row:u,column:o,lineY:c,previousConnectionIndex:p,...r})}}return s}function Ys({pixelX:r,pixelY:t,row:e,column:i,radius:s,recurrentLine:n}){const o=r/2+i*r+s+1,a=t/2+e*t,h=o-s*2-2,u=a,l=h+100,c=u+50,p=o-100,d=a+50;return`<path
              d="M ${o} ${a} C ${l} ${c}, ${p} ${d}, ${h} ${u}"
              stroke="${n.color}"
              stroke-width="${n.width}"
              fill="transparent"
              stroke-linecap="round"
              marker-end="url(#arrow)"
              class="${n.className}" />`}function ci(r){const{width:t,height:e,recurrentLine:i,sizes:s,radius:n}=r,o=t/s.length;let a=`<defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="${i.color}" />
              </marker>
            </defs>`;a+=Vt(r);for(let h=1;h<s.length;h++){const u=s[h],l=e/u;for(let c=0;c<u;c++)a+=Ys({pixelX:o,pixelY:l,row:c,column:h,radius:n,recurrentLine:i})}return a}function Js(r){const{options:t}=r;if(!t)throw new Error("options not defined");if(!t.inputLayer)throw new Error("options.inputLater not defined");if(!t.hiddenLayers)throw new Error("options.hiddenLayers not defined");if(t.hiddenLayers.length<1)throw new Error("options.hiddenLayers is empty");if(!t.outputLayer)throw new Error("options.outputLayer not defined");const e=t.inputLayer(),i=[];i.push(t.hiddenLayers[0](e,0));for(let n=1;n<t.hiddenLayers.length;n++)i.push(t.hiddenLayers[n](i[n-1],n));const s=t.outputLayer(i[i.length-1],i.length);return{inputSize:e.height,hiddenLayers:i.map(n=>n.height),outputSize:s.height}}function Vs(r){const t=[],{options:e}=r;if(!e.inputLayer)throw new Error("inputLayer not defined");if(!e.outputLayer)throw new Error("outputLayer not defined");const i=e.inputLayer();t.push(e.hiddenLayers[0](i,_e(),0));for(let n=1;n<e.hiddenLayers.length;n++)t.push(e.hiddenLayers[n](t[n-1],_e(),n));const s=e.outputLayer(t[t.length-1],-1);return{inputSize:i.height,hiddenLayers:t.map(n=>n.height),outputSize:s.height}}function Pt(r,t,e){return`<svg
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="1.1"
            width="${t}"
            height="${e}">${r}</svg>`}function Us(r){return r.sizes}function Zs(r){const{options:t,sizes:e}=r,{inputSize:i,outputSize:s,hiddenLayers:n}=t;if(!e){if(typeof i=="number"&&i<1)throw new Error("inputSize not set");if(typeof s=="number"&&s<1)throw new Error("outputSize not set");if(n!=null&&n.some(o=>o<1))throw new Error("hiddenLayers not set")}return typeof i=="number"&&Array.isArray(n)&&typeof s=="number"?[i].concat(n).concat([s]):e}function pi(r){const{options:t}=r,{inputSize:e,outputSize:i,hiddenLayers:s}=t;return[e].concat(s).concat([i])}function Qs(){return{line:{width:.5,color:"black",className:"connection"},recurrentLine:{width:1,color:"red",className:"recurrence"},inputs:{color:"rgba(0, 128, 0, 0.5)",labels:null,className:"input"},outputs:{color:"rgba(100, 149, 237, 0.5)",className:"output"},hidden:{color:"rgba(255, 127, 80, 0.5)",className:"hidden-neuron"},fontSize:"14px",fontClassName:"label",radius:8,width:400,height:250,sizes:[]}}function tn(r,t){const e={...Qs(),...t},{width:i,height:s,inputs:n}=e;let o=[];if(r instanceof Gt||r instanceof Ue)o=Zs(r);else if(r instanceof Qe){const{inputSize:a,hiddenLayers:h,outputSize:u}=Vs(r);o=[a].concat(h).concat([u])}else if(r instanceof bt){const{inputSize:a,hiddenLayers:h,outputSize:u}=Js(r);o=[a].concat(h).concat([u])}else{if(r instanceof Ot||r instanceof ai||r instanceof ei||r instanceof Dt||r instanceof li||r instanceof oi)return Pt(ci({...e,sizes:Mt(pi(r),n.labels)}),i,s);if(r.hasOwnProperty("type"))switch(r.type){case"NeuralNetwork":case"NeuralNetworkGPU":return Pt(Vt({...e,sizes:Mt(Us(r),n.labels)}),i,s);case"RNN":case"GRU":case"LSTM":case"RNNTimeStep":case"GRUTimeStep":case"LSTMTimeStep":return Pt(ci({...e,sizes:Mt(pi(r),n.labels)}),i,s);default:throw new Error("unrecognized network")}else if(r.hasOwnProperty("inputSize")&&r.hasOwnProperty("hiddenLayers")&&r.hasOwnProperty("outputSize")){const{inputSize:a,hiddenLayers:h,outputSize:u}=r;o=[a,...h,u]}else if(r.hasOwnProperty("sizes"))o=r.sizes;else throw new Error("unrecognized network")}return Pt(Vt({...e,sizes:Mt(o,n.labels)}),i,s)}function Mt(r,t){if(!r)throw new Error("sizes not set");if(r.some(e=>e<1))throw new Error("sizes not set correctly");if(t&&t.length!==r[0])throw new Error("not enough labels for inputs");return r}const en={RNNTimeStep:Dt,LSTMTimeStep:li,GRUTimeStep:oi,RNN:Ot,LSTM:ai,GRU:ei},rn={max:qt,mse:Et,ones:Se,ones2D:ve,random:Fi,randomWeight:ce,randos:ot,range:Ws,toArray:Hs,DataFormatter:j,zeros:M,toSVG:tn};F.CrossValidate=Y,F.FeedForward=bt,F.NeuralNetwork=Gt,F.NeuralNetworkGPU=Ue,F.Recurrent=Qe,F.activation=yi,F.layer=Ht,F.layerTypes=B,F.likely=ss,F.lookup=k,F.praxis=Pi,F.recurrent=en,F.utilities=rn,Object.defineProperty(F,"__esModule",{value:!0})})})(Zt,Zt.exports);const hn={mounted(){console.clear();const tt=new Zt.exports.recurrent.LSTMTimeStep;tt.train([[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16]],{}),console.log(Math.round(tt.run([1,2,3,4,5,6,7,8,9,10,11]))),console.log(Math.round(tt.run([4,6,8]))),console.log(Math.round(tt.run([8,6,4])))}};function un(tt,Qt,F,E,et,it){return on(),nn("div",null," brain ")}const fn=sn(hn,[["render",un]]);export{fn as default};
