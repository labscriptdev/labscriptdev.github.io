var ls=Object.defineProperty;var us=(d,e,t)=>e in d?ls(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t;var cn=(d,e,t)=>(us(d,typeof e!="symbol"?e+"":e,t),t);import{j as Be,q as ke,f as ae,V as J,r as Xe,a as Re,s as Ue,C as hs,t as Jt,u as _e,v as xt,w as Lt,x as ze,y as Gt,o as Mt,z as lt,E as en,I as de,J as Ne,K as ds,G as st,N as Wt,Q as dt,O as it,U as tn,W as wt,P as Xt,X as Ee,d as Pn,c as Ln,Y as Rn,Z as bt,_ as Rt,$ as Cn,A as fs,F as Le,a0 as ps,a1 as In,a2 as Te,a3 as Oe,a4 as kn,a5 as Kt,a6 as On,M as Ve,a7 as Qe,l as ne,a8 as ms,a9 as gs,aa as ys,ab as xs,p as _n,ac as Dn,ad as Fn,ae as Ot,af as Ct,ag as nn,ah as Nn,ai as ws,aj as Vn,ak as Bn,al as Un,am as bs,an as Ts,ao as vs,ap as As,aq as Ms,ar as Es,as as Ss,at as Ps,B as Ls,au as Rs,av as Cs,aw as Is,ax as ks,ay as Os,az as _t,aA as $e,aB as _s,aC as Ds,aD as Fs,aE as ft,S as sn,aF as Ns,aG as Vs,aH as Bs,aI as Us,aJ as zs,aK as Hs,aL as js,aM as et,aN as tt,aO as ln,aP as It,aQ as Gs,e as Ws,i as qt,aR as zn,aS as Hn,aT as rn,aU as jn,aV as Gn,aW as Wn,aX as Xs,k as Ks,aY as un,g as qs,aZ as Ys,a_ as Qs,a$ as Zs,b0 as $s,b1 as Js}from"./three.module.ecaea3a5.js";import{V as qe,P as hn,E as Xn,l as Je,a as Et,b as ei,C as ti,c as ni,A as si,d as Dt,e as ii,f as ri,g as oi,i as ai,h as ci,L as li,j as ui}from"./Car.952715f3.js";import{a as hi,b as di,e as dn,t as fi,o as pi}from"./entry.138122a5.js";class Ft{constructor(e){this.top=0,this.array=new Float32Array(e)}write(e){this.array[this.top++]=e.x,this.array[this.top++]=e.y,this.array[this.top++]=e.z}}class mi{constructor(e){this.top=0,this.array=new Float32Array(e)}write(e){this.array[this.top++]=e.x,this.array[this.top++]=e.y}}class Ie{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygons=[],e&&this.build(e)}clone(){const e=new Ie;return e.plane=this.plane&&this.plane.clone(),e.front=this.front&&this.front.clone(),e.back=this.back&&this.back.clone(),e.polygons=this.polygons.map(t=>t.clone()),e}invert(){for(let t=0;t<this.polygons.length;t++)this.polygons[t].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const e=this.front;this.front=this.back,this.back=e}clipPolygons(e){if(!this.plane)return e.slice();let t=new Array,n=new Array;for(let s=0;s<e.length;s++)this.plane.splitPolygon(e[s],t,n,t,n);return this.front&&(t=this.front.clipPolygons(t)),this.back?n=this.back.clipPolygons(n):n=[],t.concat(n)}clipTo(e){this.polygons=e.clipPolygons(this.polygons),this.front&&this.front.clipTo(e),this.back&&this.back.clipTo(e)}allPolygons(){let e=this.polygons.slice();return this.front&&(e=e.concat(this.front.allPolygons())),this.back&&(e=e.concat(this.back.allPolygons())),e}build(e){if(!e.length)return;this.plane||(this.plane=e[0].plane.clone());const t=[],n=[];for(let s=0;s<e.length;s++)this.plane.splitPolygon(e[s],this.polygons,this.polygons,t,n);t.length&&(this.front||(this.front=new Ie),this.front.build(t)),n.length&&(this.back||(this.back=new Ie),this.back.build(n))}}class St{constructor(e,t,n,s){this.pos=new qe().copy(e),this.normal=new qe().copy(t),this.uv=new qe().copy(n),this.uv.z=0,s&&(this.color=new qe().copy(s))}clone(){return new St(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(e,t){return new St(this.pos.clone().lerp(e.pos,t),this.normal.clone().lerp(e.normal,t),this.uv.clone().lerp(e.uv,t),this.color&&e.color&&this.color.clone().lerp(e.color,t))}}class fe{constructor(){this.polygons=new Array}static fromPolygons(e){const t=new fe;return t.polygons=e,t}static fromGeometry(e,t){let n=[];const s=e.attributes.position,i=e.attributes.normal,r=e.attributes.uv,a=e.attributes.color,o=e.groups;let c;if(e.index)c=e.index.array;else{c=new Array(s.array.length/s.itemSize|0);for(let l=0;l<c.length;l++)c[l]=l}const u=c.length/3|0;n=new Array(u);for(let l=0,h=0,m=c.length;l<m;l+=3,h++){const T=new Array(3);for(let w=0;w<3;w++){const x=c[l+w],E=x*3,k=x*2,b=s.array[E],R=s.array[E+1],P=s.array[E+2],O=i.array[E],v=i.array[E+1],A=i.array[E+2],C=r==null?void 0:r.array[k],D=r==null?void 0:r.array[k+1];T[w]=new St(new qe(b,R,P),new qe(O,v,A),new qe(C,D,0),a&&new qe(a.array[k],a.array[k+1],a.array[k+2]))}if(t===void 0&&o&&o.length>0)for(const w of o)l>=w.start&&l<w.start+w.count&&(n[h]=new hn(T,w.materialIndex));else n[h]=new hn(T,t)}return fe.fromPolygons(n.filter(l=>!isNaN(l.plane.normal.x)))}static toGeometry(e,t){let n=0;const s=e.polygons;for(const m of s)n+=m.vertices.length-2;const i=new Be,r=new Ft(n*3*3),a=new Ft(n*3*3),o=new mi(n*2*3);let c;const u=[],l=[];for(const m of s){const T=m.vertices,w=T.length;m.shared!==void 0&&(u[m.shared]||(u[m.shared]=[])),w&&T[0].color!==void 0&&(c||(c=new Ft(n*3*3)));for(let x=3;x<=w;x++)(m.shared===void 0?l:u[m.shared]).push(r.top/3,r.top/3+1,r.top/3+2),r.write(T[0].pos),r.write(T[x-2].pos),r.write(T[x-1].pos),a.write(T[0].normal),a.write(T[x-2].normal),a.write(T[x-1].normal),o&&(o.write(T[0].uv),o.write(T[x-2].uv),o.write(T[x-1].uv)),c&&(c.write(T[0].color),c.write(T[x-2].color),c.write(T[x-1].color))}i.setAttribute("position",new ke(r.array,3)),i.setAttribute("normal",new ke(a.array,3)),o&&i.setAttribute("uv",new ke(o.array,2)),c&&i.setAttribute("color",new ke(c.array,3));for(let m=0;m<u.length;m++)u[m]===void 0&&(u[m]=[]);if(u.length){let m=[],T=0;for(let w=0;w<u.length;w++)i.addGroup(T,u[w].length,w),T+=u[w].length,m=m.concat(u[w]);i.addGroup(T,l.length,u.length),m=m.concat(l),i.setIndex(m)}const h=new ae().copy(t).invert();return i.applyMatrix4(h),i.computeBoundingSphere(),i.computeBoundingBox(),i}static fromMesh(e,t){const n=fe.fromGeometry(e.geometry,t),s=new J,i=new Xe;i.getNormalMatrix(e.matrix);for(let r=0;r<n.polygons.length;r++){const a=n.polygons[r];for(let o=0;o<a.vertices.length;o++){const c=a.vertices[o];c.pos.copy(s.copy(c.pos.toVector3()).applyMatrix4(e.matrix)),c.normal.copy(s.copy(c.normal.toVector3()).applyMatrix3(i))}}return n}static toMesh(e,t,n){const s=fe.toGeometry(e,t),i=new Re(s,n);return i.matrix.copy(t),i.matrix.decompose(i.position,i.quaternion,i.scale),i.rotation.setFromQuaternion(i.quaternion),i.updateMatrixWorld(),i.castShadow=i.receiveShadow=!0,i}static union(e,t){const n=fe.fromMesh(e),s=fe.fromMesh(t);return fe.toMesh(n.union(s),e.matrix,e.material)}static subtract(e,t){const n=fe.fromMesh(e),s=fe.fromMesh(t);return fe.toMesh(n.subtract(s),e.matrix,e.material)}static intersect(e,t){const n=fe.fromMesh(e),s=fe.fromMesh(t);return fe.toMesh(n.intersect(s),e.matrix,e.material)}clone(){const e=new fe;return e.polygons=this.polygons.map(t=>t.clone()).filter(t=>Number.isFinite(t.plane.w)),e}toPolygons(){return this.polygons}union(e){const t=new Ie(this.clone().polygons),n=new Ie(e.clone().polygons);return t.clipTo(n),n.clipTo(t),n.invert(),n.clipTo(t),n.invert(),t.build(n.allPolygons()),fe.fromPolygons(t.allPolygons())}subtract(e){const t=new Ie(this.clone().polygons),n=new Ie(e.clone().polygons);return t.invert(),t.clipTo(n),n.clipTo(t),n.invert(),n.clipTo(t),n.invert(),t.build(n.allPolygons()),t.invert(),fe.fromPolygons(t.allPolygons())}intersect(e){const t=new Ie(this.clone().polygons),n=new Ie(e.clone().polygons);return t.invert(),n.clipTo(t),n.invert(),t.clipTo(n),n.clipTo(t),t.build(n.allPolygons()),t.invert(),fe.fromPolygons(t.allPolygons())}inverse(){const e=this.clone();for(const t of e.polygons)t.flip();return e}toMesh(e,t){return fe.toMesh(this,e,t)}toGeometry(e){return fe.toGeometry(this,e)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2022 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class gi{static union(e,t){return this.doCSG(e,t,"union")}static subtract(e,t){return this.doCSG(e,t,"subtract")}static intersect(e,t){return this.doCSG(e,t,"intersect")}static doCSG(e,t,n){if(e.updateMatrix(),t.updateMatrix(),n==="union")return fe.union(e,t);if(n==="subtract")return fe.subtract(e,t);if(n==="intersect")return fe.intersect(e,t)}}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var fn=function(d){return URL.createObjectURL(new Blob([d],{type:"text/javascript"}))};try{URL.revokeObjectURL(fn(""))}catch{fn=function(e){return"data:application/javascript;charset=UTF-8,"+encodeURI(e)}}var Se=Uint8Array,Ye=Uint16Array,Yt=Uint32Array,Kn=new Se([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),qn=new Se([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),yi=new Se([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Yn=function(d,e){for(var t=new Ye(31),n=0;n<31;++n)t[n]=e+=1<<d[n-1];for(var s=new Yt(t[30]),n=1;n<30;++n)for(var i=t[n];i<t[n+1];++i)s[i]=i-t[n]<<5|n;return[t,s]},Qn=Yn(Kn,2),Zn=Qn[0],xi=Qn[1];Zn[28]=258,xi[258]=28;var wi=Yn(qn,0),bi=wi[0],Qt=new Ye(32768);for(var he=0;he<32768;++he){var Ge=(he&43690)>>>1|(he&21845)<<1;Ge=(Ge&52428)>>>2|(Ge&13107)<<2,Ge=(Ge&61680)>>>4|(Ge&3855)<<4,Qt[he]=((Ge&65280)>>>8|(Ge&255)<<8)>>>1}var ut=function(d,e,t){for(var n=d.length,s=0,i=new Ye(e);s<n;++s)++i[d[s]-1];var r=new Ye(e);for(s=0;s<e;++s)r[s]=r[s-1]+i[s-1]<<1;var a;if(t){a=new Ye(1<<e);var o=15-e;for(s=0;s<n;++s)if(d[s])for(var c=s<<4|d[s],u=e-d[s],l=r[d[s]-1]++<<u,h=l|(1<<u)-1;l<=h;++l)a[Qt[l]>>>o]=c}else for(a=new Ye(n),s=0;s<n;++s)d[s]&&(a[s]=Qt[r[d[s]-1]++]>>>15-d[s]);return a},Tt=new Se(288);for(var he=0;he<144;++he)Tt[he]=8;for(var he=144;he<256;++he)Tt[he]=9;for(var he=256;he<280;++he)Tt[he]=7;for(var he=280;he<288;++he)Tt[he]=8;var $n=new Se(32);for(var he=0;he<32;++he)$n[he]=5;var Ti=ut(Tt,9,1),vi=ut($n,5,1),Nt=function(d){for(var e=d[0],t=1;t<d.length;++t)d[t]>e&&(e=d[t]);return e},Pe=function(d,e,t){var n=e/8|0;return(d[n]|d[n+1]<<8)>>(e&7)&t},Vt=function(d,e){var t=e/8|0;return(d[t]|d[t+1]<<8|d[t+2]<<16)>>(e&7)},Ai=function(d){return(d/8|0)+(d&7&&1)},Mi=function(d,e,t){(e==null||e<0)&&(e=0),(t==null||t>d.length)&&(t=d.length);var n=new(d instanceof Ye?Ye:d instanceof Yt?Yt:Se)(t-e);return n.set(d.subarray(e,t)),n},Ei=function(d,e,t){var n=d.length;if(!n||t&&!t.l&&n<5)return e||new Se(0);var s=!e||t,i=!t||t.i;t||(t={}),e||(e=new Se(n*3));var r=function(p){var f=e.length;if(p>f){var _=new Se(Math.max(f*2,p));_.set(e),e=_}},a=t.f||0,o=t.p||0,c=t.b||0,u=t.l,l=t.d,h=t.m,m=t.n,T=n*8;do{if(!u){t.f=a=Pe(d,o,1);var w=Pe(d,o+1,3);if(o+=3,w)if(w==1)u=Ti,l=vi,h=9,m=5;else if(w==2){var b=Pe(d,o,31)+257,R=Pe(d,o+10,15)+4,P=b+Pe(d,o+5,31)+1;o+=14;for(var O=new Se(P),v=new Se(19),A=0;A<R;++A)v[yi[A]]=Pe(d,o+A*3,7);o+=R*3;for(var C=Nt(v),D=(1<<C)-1,H=ut(v,C,1),A=0;A<P;){var N=H[Pe(d,o,D)];o+=N&15;var x=N>>>4;if(x<16)O[A++]=x;else{var j=0,W=0;for(x==16?(W=3+Pe(d,o,3),o+=2,j=O[A-1]):x==17?(W=3+Pe(d,o,7),o+=3):x==18&&(W=11+Pe(d,o,127),o+=7);W--;)O[A++]=j}}var se=O.subarray(0,b),ee=O.subarray(b);h=Nt(se),m=Nt(ee),u=ut(se,h,1),l=ut(ee,m,1)}else throw"invalid block type";else{var x=Ai(o)+4,E=d[x-4]|d[x-3]<<8,k=x+E;if(k>n){if(i)throw"unexpected EOF";break}s&&r(c+E),e.set(d.subarray(x,k),c),t.b=c+=E,t.p=o=k*8;continue}if(o>T){if(i)throw"unexpected EOF";break}}s&&r(c+131072);for(var q=(1<<h)-1,V=(1<<m)-1,ue=o;;ue=o){var j=u[Vt(d,o)&q],ce=j>>>4;if(o+=j&15,o>T){if(i)throw"unexpected EOF";break}if(!j)throw"invalid length/literal";if(ce<256)e[c++]=ce;else if(ce==256){ue=o,u=null;break}else{var Z=ce-254;if(ce>264){var A=ce-257,te=Kn[A];Z=Pe(d,o,(1<<te)-1)+Zn[A],o+=te}var oe=l[Vt(d,o)&V],M=oe>>>4;if(!oe)throw"invalid distance";o+=oe&15;var ee=bi[M];if(M>3){var te=qn[M];ee+=Vt(d,o)&(1<<te)-1,o+=te}if(o>T){if(i)throw"unexpected EOF";break}s&&r(c+131072);for(var y=c+Z;c<y;c+=4)e[c]=e[c-ee],e[c+1]=e[c+1-ee],e[c+2]=e[c+2-ee],e[c+3]=e[c+3-ee];c=y}}t.l=u,t.p=ue,t.b=c,u&&(a=1,t.m=h,t.d=l,t.n=m)}while(!a);return c==e.length?e:Mi(e,0,c)},Si=new Se(0),Pi=function(d){if((d[0]&15)!=8||d[0]>>>4>7||(d[0]<<8|d[1])%31)throw"invalid zlib data";if(d[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Li(d,e){return Ei((Pi(d),d.subarray(2,-4)),e)}var Ri=typeof TextDecoder<"u"&&new TextDecoder,Ci=0;try{Ri.decode(Si,{stream:!0}),Ci=1}catch{}function Jn(d,e,t){const n=t.length-d-1;if(e>=t[n])return n-1;if(e<=t[d])return d;let s=d,i=n,r=Math.floor((s+i)/2);for(;e<t[r]||e>=t[r+1];)e<t[r]?i=r:s=r,r=Math.floor((s+i)/2);return r}function Ii(d,e,t,n){const s=[],i=[],r=[];s[0]=1;for(let a=1;a<=t;++a){i[a]=e-n[d+1-a],r[a]=n[d+a]-e;let o=0;for(let c=0;c<a;++c){const u=r[c+1],l=i[a-c],h=s[c]/(u+l);s[c]=o+u*h,o=l*h}s[a]=o}return s}function ki(d,e,t,n){const s=Jn(d,n,e),i=Ii(s,n,d,e),r=new Ue(0,0,0,0);for(let a=0;a<=d;++a){const o=t[s-d+a],c=i[a],u=o.w*c;r.x+=o.x*u,r.y+=o.y*u,r.z+=o.z*u,r.w+=o.w*c}return r}function Oi(d,e,t,n,s){const i=[];for(let l=0;l<=t;++l)i[l]=0;const r=[];for(let l=0;l<=n;++l)r[l]=i.slice(0);const a=[];for(let l=0;l<=t;++l)a[l]=i.slice(0);a[0][0]=1;const o=i.slice(0),c=i.slice(0);for(let l=1;l<=t;++l){o[l]=e-s[d+1-l],c[l]=s[d+l]-e;let h=0;for(let m=0;m<l;++m){const T=c[m+1],w=o[l-m];a[l][m]=T+w;const x=a[m][l-1]/a[l][m];a[m][l]=h+T*x,h=w*x}a[l][l]=h}for(let l=0;l<=t;++l)r[0][l]=a[l][t];for(let l=0;l<=t;++l){let h=0,m=1;const T=[];for(let w=0;w<=t;++w)T[w]=i.slice(0);T[0][0]=1;for(let w=1;w<=n;++w){let x=0;const E=l-w,k=t-w;l>=w&&(T[m][0]=T[h][0]/a[k+1][E],x=T[m][0]*a[E][k]);const b=E>=-1?1:-E,R=l-1<=k?w-1:t-l;for(let O=b;O<=R;++O)T[m][O]=(T[h][O]-T[h][O-1])/a[k+1][E+O],x+=T[m][O]*a[E+O][k];l<=k&&(T[m][w]=-T[h][w-1]/a[k+1][l],x+=T[m][w]*a[l][k]),r[w][l]=x;const P=h;h=m,m=P}}let u=t;for(let l=1;l<=n;++l){for(let h=0;h<=t;++h)r[l][h]*=u;u*=t-l}return r}function _i(d,e,t,n,s){const i=s<d?s:d,r=[],a=Jn(d,n,e),o=Oi(a,n,d,i,e),c=[];for(let u=0;u<t.length;++u){const l=t[u].clone(),h=l.w;l.x*=h,l.y*=h,l.z*=h,c[u]=l}for(let u=0;u<=i;++u){const l=c[a-d].clone().multiplyScalar(o[u][0]);for(let h=1;h<=d;++h)l.add(c[a-d+h].clone().multiplyScalar(o[u][h]));r[u]=l}for(let u=i+1;u<=s+1;++u)r[u]=new Ue(0,0,0);return r}function Di(d,e){let t=1;for(let s=2;s<=d;++s)t*=s;let n=1;for(let s=2;s<=e;++s)n*=s;for(let s=2;s<=d-e;++s)n*=s;return t/n}function Fi(d){const e=d.length,t=[],n=[];for(let i=0;i<e;++i){const r=d[i];t[i]=new J(r.x,r.y,r.z),n[i]=r.w}const s=[];for(let i=0;i<e;++i){const r=t[i].clone();for(let a=1;a<=i;++a)r.sub(s[i-a].clone().multiplyScalar(Di(i,a)*n[a]));s[i]=r.divideScalar(n[0])}return s}function Ni(d,e,t,n,s){const i=_i(d,e,t,n,s);return Fi(i)}class Vi extends hs{constructor(e,t,n,s,i){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=s||0,this.endKnot=i||this.knots.length-1;for(let r=0;r<n.length;++r){const a=n[r];this.controlPoints[r]=new Ue(a.x,a.y,a.z,a.w)}}getPoint(e,t=new J){const n=t,s=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),i=ki(this.degree,this.knots,this.controlPoints,s);return i.w!==1&&i.divideScalar(i.w),n.set(i.x,i.y,i.z)}getTangent(e,t=new J){const n=t,s=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),i=Ni(this.degree,this.knots,this.controlPoints,s,1);return n.copy(i[1]).normalize(),n}}let ie,ge,be;class Bi extends Jt{constructor(e){super(e)}load(e,t,n,s){const i=this,r=i.path===""?_e.extractUrlBase(e):i.path,a=new xt(this.manager);a.setPath(i.path),a.setResponseType("arraybuffer"),a.setRequestHeader(i.requestHeader),a.setWithCredentials(i.withCredentials),a.load(e,function(o){try{t(i.parse(o,r))}catch(c){s?s(c):console.error(c),i.manager.itemError(e)}},n,s)}parse(e,t){if(Wi(e))ie=new Gi().parse(e);else{const s=ss(e);if(!Xi(s))throw new Error("THREE.FBXLoader: Unknown format.");if(mn(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+mn(s));ie=new ji().parse(s)}const n=new Lt(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Ui(n,this.manager).parse(ie)}}class Ui{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){ge=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),s=this.parseDeformers(),i=new zi().parse(s);return this.parseScene(s,i,n),be}parseConnections(){const e=new Map;return"Connections"in ie&&ie.Connections.connections.forEach(function(n){const s=n[0],i=n[1],r=n[2];e.has(s)||e.set(s,{parents:[],children:[]});const a={ID:i,relationship:r};e.get(s).parents.push(a),e.has(i)||e.set(i,{parents:[],children:[]});const o={ID:s,relationship:r};e.get(i).children.push(o)}),e}parseImages(){const e={},t={};if("Video"in ie.Objects){const n=ie.Objects.Video;for(const s in n){const i=n[s],r=parseInt(s);if(e[r]=i.RelativeFilename||i.Filename,"Content"in i){const a=i.Content instanceof ArrayBuffer&&i.Content.byteLength>0,o=typeof i.Content=="string"&&i.Content!=="";if(a||o){const c=this.parseImage(n[s]);t[i.RelativeFilename||i.Filename]=c}}}}for(const n in e){const s=e[n];t[s]!==void 0?e[n]=t[s]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,s=n.slice(n.lastIndexOf(".")+1).toLowerCase();let i;switch(s){case"bmp":i="image/bmp";break;case"jpg":case"jpeg":i="image/jpeg";break;case"png":i="image/png";break;case"tif":i="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),i="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof t=="string")return"data:"+i+";base64,"+t;{const r=new Uint8Array(t);return window.URL.createObjectURL(new Blob([r],{type:i}))}}parseTextures(e){const t=new Map;if("Texture"in ie.Objects){const n=ie.Objects.Texture;for(const s in n){const i=this.parseTexture(n[s],e);t.set(parseInt(s),i)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const s=e.WrapModeU,i=e.WrapModeV,r=s!==void 0?s.value:0,a=i!==void 0?i.value:0;if(n.wrapS=r===0?ze:Gt,n.wrapT=a===0?ze:Gt,"Scaling"in e){const o=e.Scaling.value;n.repeat.x=o[0],n.repeat.y=o[1]}if("Translation"in e){const o=e.Translation.value;n.offset.x=o[0],n.offset.y=o[1]}return n}loadTexture(e,t){let n;const s=this.textureLoader.path,i=ge.get(e.id).children;i!==void 0&&i.length>0&&t[i[0].ID]!==void 0&&(n=t[i[0].ID],(n.indexOf("blob:")===0||n.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let r;const a=e.FileName.slice(-3).toLowerCase();if(a==="tga"){const o=this.manager.getHandler(".tga");o===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),r=new Mt):(o.setPath(this.textureLoader.path),r=o.load(n))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),r=new Mt):r=this.textureLoader.load(n);return this.textureLoader.setPath(s),r}parseMaterials(e){const t=new Map;if("Material"in ie.Objects){const n=ie.Objects.Material;for(const s in n){const i=this.parseMaterial(n[s],e);i!==null&&t.set(parseInt(s),i)}}return t}parseMaterial(e,t){const n=e.id,s=e.attrName;let i=e.ShadingModel;if(typeof i=="object"&&(i=i.value),!ge.has(n))return null;const r=this.parseParameters(e,t,n);let a;switch(i.toLowerCase()){case"phong":a=new lt;break;case"lambert":a=new en;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',i),a=new lt;break}return a.setValues(r),a.name=s,a}parseParameters(e,t,n){const s={};e.BumpFactor&&(s.bumpScale=e.BumpFactor.value),e.Diffuse?s.color=new de().fromArray(e.Diffuse.value):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(s.color=new de().fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(s.displacementScale=e.DisplacementFactor.value),e.Emissive?s.emissive=new de().fromArray(e.Emissive.value):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(s.emissive=new de().fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(s.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(s.opacity=parseFloat(e.Opacity.value)),s.opacity<1&&(s.transparent=!0),e.ReflectionFactor&&(s.reflectivity=e.ReflectionFactor.value),e.Shininess&&(s.shininess=e.Shininess.value),e.Specular?s.specular=new de().fromArray(e.Specular.value):e.SpecularColor&&e.SpecularColor.type==="Color"&&(s.specular=new de().fromArray(e.SpecularColor.value));const i=this;return ge.get(n).children.forEach(function(r){const a=r.relationship;switch(a){case"Bump":s.bumpMap=i.getTexture(t,r.ID);break;case"Maya|TEX_ao_map":s.aoMap=i.getTexture(t,r.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=i.getTexture(t,r.ID),s.map!==void 0&&(s.map.encoding=Ne);break;case"DisplacementColor":s.displacementMap=i.getTexture(t,r.ID);break;case"EmissiveColor":s.emissiveMap=i.getTexture(t,r.ID),s.emissiveMap!==void 0&&(s.emissiveMap.encoding=Ne);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=i.getTexture(t,r.ID);break;case"ReflectionColor":s.envMap=i.getTexture(t,r.ID),s.envMap!==void 0&&(s.envMap.mapping=ds,s.envMap.encoding=Ne);break;case"SpecularColor":s.specularMap=i.getTexture(t,r.ID),s.specularMap!==void 0&&(s.specularMap.encoding=Ne);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=i.getTexture(t,r.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),s}getTexture(e,t){return"LayeredTexture"in ie.Objects&&t in ie.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=ge.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in ie.Objects){const n=ie.Objects.Deformer;for(const s in n){const i=n[s],r=ge.get(parseInt(s));if(i.attrType==="Skin"){const a=this.parseSkeleton(r,n);a.ID=s,r.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=r.parents[0].ID,e[s]=a}else if(i.attrType==="BlendShape"){const a={id:s};a.rawTargets=this.parseMorphTargets(r,n),a.id=s,r.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[s]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(s){const i=t[s.ID];if(i.attrType!=="Cluster")return;const r={ID:s.ID,indices:[],weights:[],transformLink:new ae().fromArray(i.TransformLink.a)};"Indexes"in i&&(r.indices=i.Indexes.a,r.weights=i.Weights.a),n.push(r)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let s=0;s<e.children.length;s++){const i=e.children[s],r=t[i.ID],a={name:r.attrName,initialWeight:r.DeformPercent,id:r.id,fullWeights:r.FullWeights.a};if(r.attrType!=="BlendShapeChannel")return;a.geoID=ge.get(parseInt(i.ID)).children.filter(function(o){return o.relationship===void 0})[0].ID,n.push(a)}return n}parseScene(e,t,n){be=new st;const s=this.parseModels(e.skeletons,t,n),i=ie.Objects.Model,r=this;s.forEach(function(o){const c=i[o.ID];r.setLookAtProperties(o,c),ge.get(o.ID).parents.forEach(function(l){const h=s.get(l.ID);h!==void 0&&h.add(o)}),o.parent===null&&be.add(o)}),this.bindSkeleton(e.skeletons,t,s),this.createAmbientLight(),be.traverse(function(o){if(o.userData.transformData){o.parent&&(o.userData.transformData.parentMatrix=o.parent.matrix,o.userData.transformData.parentMatrixWorld=o.parent.matrixWorld);const c=ts(o.userData.transformData);o.applyMatrix4(c),o.updateWorldMatrix()}});const a=new Hi().parse();be.children.length===1&&be.children[0].isGroup&&(be.children[0].animations=a,be=be.children[0]),be.animations=a}parseModels(e,t,n){const s=new Map,i=ie.Objects.Model;for(const r in i){const a=parseInt(r),o=i[r],c=ge.get(a);let u=this.buildSkeleton(c,e,a,o.attrName);if(!u){switch(o.attrType){case"Camera":u=this.createCamera(c);break;case"Light":u=this.createLight(c);break;case"Mesh":u=this.createMesh(c,t,n);break;case"NurbsCurve":u=this.createCurve(c,t);break;case"LimbNode":case"Root":u=new Wt;break;case"Null":default:u=new st;break}u.name=o.attrName?dt.sanitizeNodeName(o.attrName):"",u.ID=a}this.getTransformData(u,o),s.set(a,u)}return s}buildSkeleton(e,t,n,s){let i=null;return e.parents.forEach(function(r){for(const a in t){const o=t[a];o.rawBones.forEach(function(c,u){if(c.ID===r.ID){const l=i;i=new Wt,i.matrixWorld.copy(c.transformLink),i.name=s?dt.sanitizeNodeName(s):"",i.ID=n,o.bones[u]=i,l!==null&&i.add(l)}})}}),i}createCamera(e){let t,n;if(e.children.forEach(function(s){const i=ie.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)t=new it;else{let s=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(s=1);let i=1;n.NearPlane!==void 0&&(i=n.NearPlane.value/1e3);let r=1e3;n.FarPlane!==void 0&&(r=n.FarPlane.value/1e3);let a=window.innerWidth,o=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(a=n.AspectWidth.value,o=n.AspectHeight.value);const c=a/o;let u=45;n.FieldOfView!==void 0&&(u=n.FieldOfView.value);const l=n.FocalLength?n.FocalLength.value:null;switch(s){case 0:t=new wt(u,c,i,r),l!==null&&t.setFocalLength(l);break;case 1:t=new tn(-a/2,a/2,o/2,-o/2,i,r);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),t=new it;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(s){const i=ie.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)t=new it;else{let s;n.LightType===void 0?s=0:s=n.LightType.value;let i=16777215;n.Color!==void 0&&(i=new de().fromArray(n.Color.value));let r=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(r=0);let a=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?a=0:a=n.FarAttenuationEnd.value);const o=1;switch(s){case 0:t=new Xt(i,r,a,o);break;case 1:t=new Ln(i,r);break;case 2:let c=Math.PI/3;n.InnerAngle!==void 0&&(c=Ee.degToRad(n.InnerAngle.value));let u=0;n.OuterAngle!==void 0&&(u=Ee.degToRad(n.OuterAngle.value),u=Math.max(u,1)),t=new Pn(i,r,a,c,u,o);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new Xt(i,r);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let s,i=null,r=null;const a=[];return e.children.forEach(function(o){t.has(o.ID)&&(i=t.get(o.ID)),n.has(o.ID)&&a.push(n.get(o.ID))}),a.length>1?r=a:a.length>0?r=a[0]:(r=new lt({color:13421772}),a.push(r)),"color"in i.attributes&&a.forEach(function(o){o.vertexColors=!0}),i.FBX_Deformer?(s=new Rn(i,r),s.normalizeSkinWeights()):s=new Re(i,r),s}createCurve(e,t){const n=e.children.reduce(function(i,r){return t.has(r.ID)&&(i=t.get(r.ID)),i},null),s=new bt({color:3342591,linewidth:1});return new Rt(n,s)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=ns(t.RotationOrder.value):n.eulerOrder="ZYX","Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&ge.get(e.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const i=ie.Objects.Model[s.ID];if("Lcl_Translation"in i){const r=i.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(r),be.add(e.target)):e.lookAt(new J().fromArray(r))}}})}bindSkeleton(e,t,n){const s=this.parsePoseNodes();for(const i in e){const r=e[i];ge.get(parseInt(r.ID)).parents.forEach(function(o){if(t.has(o.ID)){const c=o.ID;ge.get(c).parents.forEach(function(l){n.has(l.ID)&&n.get(l.ID).bind(new Cn(r.bones),s[l.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in ie.Objects){const t=ie.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const s=t[n].PoseNode;Array.isArray(s)?s.forEach(function(i){e[i.Node]=new ae().fromArray(i.Matrix.a)}):e[s.Node]=new ae().fromArray(s.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in ie&&"AmbientColor"in ie.GlobalSettings){const e=ie.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],s=e[2];if(t!==0||n!==0||s!==0){const i=new de(t,n,s);be.add(new fs(i,1))}}}}class zi{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in ie.Objects){const n=ie.Objects.Geometry;for(const s in n){const i=ge.get(parseInt(s)),r=this.parseGeometry(i,n[s],e);t.set(parseInt(s),r)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const s=n.skeletons,i=[],r=e.parents.map(function(l){return ie.Objects.Model[l.ID]});if(r.length===0)return;const a=e.children.reduce(function(l,h){return s[h.ID]!==void 0&&(l=s[h.ID]),l},null);e.children.forEach(function(l){n.morphTargets[l.ID]!==void 0&&i.push(n.morphTargets[l.ID])});const o=r[0],c={};"RotationOrder"in o&&(c.eulerOrder=ns(o.RotationOrder.value)),"InheritType"in o&&(c.inheritType=parseInt(o.InheritType.value)),"GeometricTranslation"in o&&(c.translation=o.GeometricTranslation.value),"GeometricRotation"in o&&(c.rotation=o.GeometricRotation.value),"GeometricScaling"in o&&(c.scale=o.GeometricScaling.value);const u=ts(c);return this.genGeometry(t,a,i,u)}genGeometry(e,t,n,s){const i=new Be;e.attrName&&(i.name=e.attrName);const r=this.parseGeoNode(e,t),a=this.genBuffers(r),o=new Le(a.vertex,3);if(o.applyMatrix4(s),i.setAttribute("position",o),a.colors.length>0&&i.setAttribute("color",new Le(a.colors,3)),t&&(i.setAttribute("skinIndex",new ps(a.weightsIndices,4)),i.setAttribute("skinWeight",new Le(a.vertexWeights,4)),i.FBX_Deformer=t),a.normal.length>0){const c=new Xe().getNormalMatrix(s),u=new Le(a.normal,3);u.applyNormalMatrix(c),i.setAttribute("normal",u)}if(a.uvs.forEach(function(c,u){let l="uv"+(u+1).toString();u===0&&(l="uv"),i.setAttribute(l,new Le(a.uvs[u],2))}),r.material&&r.material.mappingType!=="AllSame"){let c=a.materialIndex[0],u=0;if(a.materialIndex.forEach(function(l,h){l!==c&&(i.addGroup(u,h-u,c),c=l,u=h)}),i.groups.length>0){const l=i.groups[i.groups.length-1],h=l.start+l.count;h!==a.materialIndex.length&&i.addGroup(h,a.materialIndex.length-h,c)}i.groups.length===0&&i.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(i,e,n,s),i}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let s=0;for(;e.LayerElementUV[s];)e.LayerElementUV[s].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[s])),s++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(s,i){s.indices.forEach(function(r,a){n.weightTable[r]===void 0&&(n.weightTable[r]=[]),n.weightTable[r].push({id:i,weight:s.weights[a]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,s=0,i=!1,r=[],a=[],o=[],c=[],u=[],l=[];const h=this;return e.vertexIndices.forEach(function(m,T){let w,x=!1;m<0&&(m=m^-1,x=!0);let E=[],k=[];if(r.push(m*3,m*3+1,m*3+2),e.color){const b=At(T,n,m,e.color);o.push(b[0],b[1],b[2])}if(e.skeleton){if(e.weightTable[m]!==void 0&&e.weightTable[m].forEach(function(b){k.push(b.weight),E.push(b.id)}),k.length>4){i||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),i=!0);const b=[0,0,0,0],R=[0,0,0,0];k.forEach(function(P,O){let v=P,A=E[O];R.forEach(function(C,D,H){if(v>C){H[D]=v,v=C;const N=b[D];b[D]=A,A=N}})}),E=b,k=R}for(;k.length<4;)k.push(0),E.push(0);for(let b=0;b<4;++b)u.push(k[b]),l.push(E[b])}if(e.normal){const b=At(T,n,m,e.normal);a.push(b[0],b[1],b[2])}e.material&&e.material.mappingType!=="AllSame"&&(w=At(T,n,m,e.material)[0],w<0&&(h.negativeMaterialIndices=!0,w=0)),e.uv&&e.uv.forEach(function(b,R){const P=At(T,n,m,b);c[R]===void 0&&(c[R]=[]),c[R].push(P[0]),c[R].push(P[1])}),s++,x&&(s>4&&console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),h.genFace(t,e,r,w,a,o,c,u,l,s),n++,s=0,r=[],a=[],o=[],c=[],u=[],l=[])}),t}genFace(e,t,n,s,i,r,a,o,c,u){for(let l=2;l<u;l++)e.vertex.push(t.vertexPositions[n[0]]),e.vertex.push(t.vertexPositions[n[1]]),e.vertex.push(t.vertexPositions[n[2]]),e.vertex.push(t.vertexPositions[n[(l-1)*3]]),e.vertex.push(t.vertexPositions[n[(l-1)*3+1]]),e.vertex.push(t.vertexPositions[n[(l-1)*3+2]]),e.vertex.push(t.vertexPositions[n[l*3]]),e.vertex.push(t.vertexPositions[n[l*3+1]]),e.vertex.push(t.vertexPositions[n[l*3+2]]),t.skeleton&&(e.vertexWeights.push(o[0]),e.vertexWeights.push(o[1]),e.vertexWeights.push(o[2]),e.vertexWeights.push(o[3]),e.vertexWeights.push(o[(l-1)*4]),e.vertexWeights.push(o[(l-1)*4+1]),e.vertexWeights.push(o[(l-1)*4+2]),e.vertexWeights.push(o[(l-1)*4+3]),e.vertexWeights.push(o[l*4]),e.vertexWeights.push(o[l*4+1]),e.vertexWeights.push(o[l*4+2]),e.vertexWeights.push(o[l*4+3]),e.weightsIndices.push(c[0]),e.weightsIndices.push(c[1]),e.weightsIndices.push(c[2]),e.weightsIndices.push(c[3]),e.weightsIndices.push(c[(l-1)*4]),e.weightsIndices.push(c[(l-1)*4+1]),e.weightsIndices.push(c[(l-1)*4+2]),e.weightsIndices.push(c[(l-1)*4+3]),e.weightsIndices.push(c[l*4]),e.weightsIndices.push(c[l*4+1]),e.weightsIndices.push(c[l*4+2]),e.weightsIndices.push(c[l*4+3])),t.color&&(e.colors.push(r[0]),e.colors.push(r[1]),e.colors.push(r[2]),e.colors.push(r[(l-1)*3]),e.colors.push(r[(l-1)*3+1]),e.colors.push(r[(l-1)*3+2]),e.colors.push(r[l*3]),e.colors.push(r[l*3+1]),e.colors.push(r[l*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(s),e.materialIndex.push(s),e.materialIndex.push(s)),t.normal&&(e.normal.push(i[0]),e.normal.push(i[1]),e.normal.push(i[2]),e.normal.push(i[(l-1)*3]),e.normal.push(i[(l-1)*3+1]),e.normal.push(i[(l-1)*3+2]),e.normal.push(i[l*3]),e.normal.push(i[l*3+1]),e.normal.push(i[l*3+2])),t.uv&&t.uv.forEach(function(h,m){e.uvs[m]===void 0&&(e.uvs[m]=[]),e.uvs[m].push(a[m][0]),e.uvs[m].push(a[m][1]),e.uvs[m].push(a[m][(l-1)*2]),e.uvs[m].push(a[m][(l-1)*2+1]),e.uvs[m].push(a[m][l*2]),e.uvs[m].push(a[m][l*2+1])})}addMorphTargets(e,t,n,s){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const i=this;n.forEach(function(r){r.rawTargets.forEach(function(a){const o=ie.Objects.Geometry[a.geoID];o!==void 0&&i.genMorphGeometry(e,t,o,s,a.name)})})}genMorphGeometry(e,t,n,s,i){const r=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],o=n.Indexes!==void 0?n.Indexes.a:[],c=e.attributes.position.count*3,u=new Float32Array(c);for(let T=0;T<o.length;T++){const w=o[T]*3;u[w]=a[T*3],u[w+1]=a[T*3+1],u[w+2]=a[T*3+2]}const l={vertexIndices:r,vertexPositions:u},h=this.genBuffers(l),m=new Le(h.vertex,3);m.name=i||n.attrName,m.applyMatrix4(s),e.morphAttributes.position.push(m)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Normals.a;let i=[];return n==="IndexToDirect"&&("NormalIndex"in e?i=e.NormalIndex.a:"NormalsIndex"in e&&(i=e.NormalsIndex.a)),{dataSize:3,buffer:s,indices:i,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.UV.a;let i=[];return n==="IndexToDirect"&&(i=e.UVIndex.a),{dataSize:2,buffer:s,indices:i,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Colors.a;let i=[];return n==="IndexToDirect"&&(i=e.ColorIndex.a),{dataSize:4,buffer:s,indices:i,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const s=e.Materials.a,i=[];for(let r=0;r<s.length;++r)i.push(r);return{dataSize:1,buffer:s,indices:i,mappingType:t,referenceType:n}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new Be;const n=t-1,s=e.KnotVector.a,i=[],r=e.Points.a;for(let l=0,h=r.length;l<h;l+=4)i.push(new Ue().fromArray(r,l));let a,o;if(e.Form==="Closed")i.push(i[0]);else if(e.Form==="Periodic"){a=n,o=s.length-1-a;for(let l=0;l<n;++l)i.push(i[l])}const u=new Vi(n,s,i,a,o).getPoints(i.length*12);return new Be().setFromPoints(u)}}class Hi{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const s=t[n],i=this.addClip(s);e.push(i)}return e}parseClips(){if(ie.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=ie.Objects.AnimationCurveNode,t=new Map;for(const n in e){const s=e[n];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const i={id:s.id,attr:s.attrName,curves:{}};t.set(i.id,i)}}return t}parseAnimationCurves(e){const t=ie.Objects.AnimationCurve;for(const n in t){const s={id:t[n].id,times:t[n].KeyTime.a.map(Ki),values:t[n].KeyValueFloat.a},i=ge.get(s.id);if(i!==void 0){const r=i.parents[0].ID,a=i.parents[0].relationship;a.match(/X/)?e.get(r).curves.x=s:a.match(/Y/)?e.get(r).curves.y=s:a.match(/Z/)?e.get(r).curves.z=s:a.match(/d|DeformPercent/)&&e.has(r)&&(e.get(r).curves.morph=s)}}}parseAnimationLayers(e){const t=ie.Objects.AnimationLayer,n=new Map;for(const s in t){const i=[],r=ge.get(parseInt(s));r!==void 0&&(r.children.forEach(function(o,c){if(e.has(o.ID)){const u=e.get(o.ID);if(u.curves.x!==void 0||u.curves.y!==void 0||u.curves.z!==void 0){if(i[c]===void 0){const l=ge.get(o.ID).parents.filter(function(h){return h.relationship!==void 0})[0].ID;if(l!==void 0){const h=ie.Objects.Model[l.toString()];if(h===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",o);return}const m={modelName:h.attrName?dt.sanitizeNodeName(h.attrName):"",ID:h.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};be.traverse(function(T){T.ID===h.id&&(m.transform=T.matrix,T.userData.transformData&&(m.eulerOrder=T.userData.transformData.eulerOrder))}),m.transform||(m.transform=new ae),"PreRotation"in h&&(m.preRotation=h.PreRotation.value),"PostRotation"in h&&(m.postRotation=h.PostRotation.value),i[c]=m}}i[c]&&(i[c][u.attr]=u)}else if(u.curves.morph!==void 0){if(i[c]===void 0){const l=ge.get(o.ID).parents.filter(function(E){return E.relationship!==void 0})[0].ID,h=ge.get(l).parents[0].ID,m=ge.get(h).parents[0].ID,T=ge.get(m).parents[0].ID,w=ie.Objects.Model[T],x={modelName:w.attrName?dt.sanitizeNodeName(w.attrName):"",morphName:ie.Objects.Deformer[l].attrName};i[c]=x}i[c][u.attr]=u}}}),n.set(parseInt(s),i))}return n}parseAnimStacks(e){const t=ie.Objects.AnimationStack,n={};for(const s in t){const i=ge.get(parseInt(s)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const r=e.get(i[0].ID);n[s]={name:t[s].attrName,layer:r}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(s){t=t.concat(n.generateTracks(s))}),new In(e.name,-1,t)}generateTracks(e){const t=[];let n=new J,s=new Te,i=new J;if(e.transform&&e.transform.decompose(n,s,i),n=n.toArray(),s=new Oe().setFromQuaternion(s,e.eulerOrder).toArray(),i=i.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,s,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,i,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,n,s){const i=this.getTimesForAllAxes(t),r=this.getKeyframeTrackValues(i,t,n);return new kn(e+"."+s,i,r)}generateRotationTrack(e,t,n,s,i,r){t.x!==void 0&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(Ee.degToRad)),t.y!==void 0&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(Ee.degToRad)),t.z!==void 0&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(Ee.degToRad));const a=this.getTimesForAllAxes(t),o=this.getKeyframeTrackValues(a,t,n);s!==void 0&&(s=s.map(Ee.degToRad),s.push(r),s=new Oe().fromArray(s),s=new Te().setFromEuler(s)),i!==void 0&&(i=i.map(Ee.degToRad),i.push(r),i=new Oe().fromArray(i),i=new Te().setFromEuler(i).invert());const c=new Te,u=new Oe,l=[];for(let h=0;h<o.length;h+=3)u.set(o[h],o[h+1],o[h+2],r),c.setFromEuler(u),s!==void 0&&c.premultiply(s),i!==void 0&&c.multiply(i),c.toArray(l,h/3*4);return new Kt(e+".quaternion",a,l)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(i){return i/100}),s=be.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new On(e.modelName+".morphTargetInfluences["+s+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,s){return n-s}),t.length>1){let n=1,s=t[0];for(let i=1;i<t.length;i++){const r=t[i];r!==s&&(t[n]=r,s=r,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const s=n,i=[];let r=-1,a=-1,o=-1;return e.forEach(function(c){if(t.x&&(r=t.x.times.indexOf(c)),t.y&&(a=t.y.times.indexOf(c)),t.z&&(o=t.z.times.indexOf(c)),r!==-1){const u=t.x.values[r];i.push(u),s[0]=u}else i.push(s[0]);if(a!==-1){const u=t.y.values[a];i.push(u),s[1]=u}else i.push(s[1]);if(o!==-1){const u=t.z.values[o];i.push(u),s[2]=u}else i.push(s[2])}),i}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const n=e.values[t-1],s=e.values[t]-n,i=Math.abs(s);if(i>=180){const r=i/180,a=s/r;let o=n+a;const c=e.times[t-1],l=(e.times[t]-c)/r;let h=c+l;const m=[],T=[];for(;h<e.times[t];)m.push(h),h+=l,T.push(o),o+=a;e.times=gn(e.times,t,m),e.values=gn(e.values,t,T)}}}}class ji{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new es,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(s,i){const r=s.match(/^[\s\t]*;/),a=s.match(/^[\s\t]*$/);if(r||a)return;const o=s.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=s.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),u=s.match("^\\t{"+(t.currentIndent-1)+"}}");o?t.parseNodeBegin(s,o):c?t.parseNodeProperty(s,c,n[++i]):u?t.popStack():s.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),s=t[2].split(",").map(function(o){return o.trim().replace(/^"/,"").replace(/"$/,"")}),i={name:n},r=this.parseNodeAttr(s),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,i):n in a?(n==="PoseNode"?a.PoseNode.push(i):a[n].id!==void 0&&(a[n]={},a[n][a[n].id]=a[n]),r.id!==""&&(a[n][r.id]=i)):typeof r.id=="number"?(a[n]={},a[n][r.id]=i):n!=="Properties70"&&(n==="PoseNode"?a[n]=[i]:a[n]=i),typeof r.id=="number"&&(i.id=r.id),r.name!==""&&(i.attrName=r.name),r.type!==""&&(i.attrType=r.type),this.pushStack(i)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",s="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),s=e[2]),{id:t,name:n,type:s}}parseNodeProperty(e,t,n){let s=t[1].replace(/^"/,"").replace(/"$/,"").trim(),i=t[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&i===","&&(i=n.replace(/"/g,"").replace(/,$/,"").trim());const r=this.getCurrentNode();if(r.name==="Properties70"){this.parseNodeSpecialProperty(e,s,i);return}if(s==="C"){const o=i.split(",").slice(1),c=parseInt(o[0]),u=parseInt(o[1]);let l=i.split(",").slice(3);l=l.map(function(h){return h.trim().replace(/^"/,"")}),s="connections",i=[c,u],Yi(i,l),r[s]===void 0&&(r[s]=[])}s==="Node"&&(r.id=i),s in r&&Array.isArray(r[s])?r[s].push(i):s!=="a"?r[s]=i:r.a=i,this.setCurrentProp(r,s),s==="a"&&i.slice(-1)!==","&&(r.a=Ut(i))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=Ut(t.a))}parseNodeSpecialProperty(e,t,n){const s=n.split('",').map(function(u){return u.trim().replace(/^\"/,"").replace(/\s/,"_")}),i=s[0],r=s[1],a=s[2],o=s[3];let c=s[4];switch(r){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=Ut(c);break}this.getPrevNode()[i]={type:r,type2:a,flag:o,value:c},this.setCurrentProp(this.getPrevNode(),i)}}class Gi{parse(e){const t=new pn(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const s=new es;for(;!this.endOfContent(t);){const i=this.parseNode(t,n);i!==null&&s.add(i.name,i)}return s}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},s=t>=7500?e.getUint64():e.getUint32(),i=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const r=e.getUint8(),a=e.getString(r);if(s===0)return null;const o=[];for(let h=0;h<i;h++)o.push(this.parseProperty(e));const c=o.length>0?o[0]:"",u=o.length>1?o[1]:"",l=o.length>2?o[2]:"";for(n.singleProperty=i===1&&e.getOffset()===s;s>e.getOffset();){const h=this.parseNode(e,t);h!==null&&this.parseSubNode(a,n,h)}return n.propertyList=o,typeof c=="number"&&(n.id=c),u!==""&&(n.attrName=u),l!==""&&(n.attrType=l),a!==""&&(n.name=a),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const s=n.propertyList[0];Array.isArray(s)?(t[n.name]=n,n.a=s):t[n.name]=s}else if(e==="Connections"&&n.name==="C"){const s=[];n.propertyList.forEach(function(i,r){r!==0&&s.push(i)}),t.connections===void 0&&(t.connections=[]),t.connections.push(s)}else if(n.name==="Properties70")Object.keys(n).forEach(function(i){t[i]=n[i]});else if(e==="Properties70"&&n.name==="P"){let s=n.propertyList[0],i=n.propertyList[1];const r=n.propertyList[2],a=n.propertyList[3];let o;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),i.indexOf("Lcl ")===0&&(i=i.replace("Lcl ","Lcl_")),i==="Color"||i==="ColorRGB"||i==="Vector"||i==="Vector3D"||i.indexOf("Lcl_")===0?o=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:o=n.propertyList[4],t[s]={type:i,type2:r,flag:a,value:o}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=e.getUint32(),i=e.getUint32(),r=e.getUint32();if(i===0)switch(t){case"b":case"c":return e.getBooleanArray(s);case"d":return e.getFloat64Array(s);case"f":return e.getFloat32Array(s);case"i":return e.getInt32Array(s);case"l":return e.getInt64Array(s)}const a=Li(new Uint8Array(e.getArrayBuffer(r))),o=new pn(a.buffer);switch(t){case"b":case"c":return o.getBooleanArray(s);case"d":return o.getFloat64Array(s);case"f":return o.getFloat32Array(s);case"i":return o.getInt32Array(s);case"l":return o.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class pn{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let s=0;s<e;s++)t[s]=this.getUint8();const n=t.indexOf(0);return n>=0&&(t=t.slice(0,n)),_e.decodeText(new Uint8Array(t))}}class es{add(e,t){this[e]=t}}function Wi(d){const e="Kaydara FBX Binary  \0";return d.byteLength>=e.length&&e===ss(d,0,e.length)}function Xi(d){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(s){const i=d[s-1];return d=d.slice(t+s),t++,i}for(let s=0;s<e.length;++s)if(n(1)===e[s])return!1;return!0}function mn(d){const e=/FBXVersion: (\d+)/,t=d.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Ki(d){return d/46186158e3}const qi=[];function At(d,e,t,n){let s;switch(n.mappingType){case"ByPolygonVertex":s=d;break;case"ByPolygon":s=e;break;case"ByVertice":s=t;break;case"AllSame":s=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(s=n.indices[s]);const i=s*n.dataSize,r=i+n.dataSize;return Qi(qi,n.buffer,i,r)}const Bt=new Oe,nt=new J;function ts(d){const e=new ae,t=new ae,n=new ae,s=new ae,i=new ae,r=new ae,a=new ae,o=new ae,c=new ae,u=new ae,l=new ae,h=new ae,m=d.inheritType?d.inheritType:0;if(d.translation&&e.setPosition(nt.fromArray(d.translation)),d.preRotation){const D=d.preRotation.map(Ee.degToRad);D.push(d.eulerOrder||Oe.DefaultOrder),t.makeRotationFromEuler(Bt.fromArray(D))}if(d.rotation){const D=d.rotation.map(Ee.degToRad);D.push(d.eulerOrder||Oe.DefaultOrder),n.makeRotationFromEuler(Bt.fromArray(D))}if(d.postRotation){const D=d.postRotation.map(Ee.degToRad);D.push(d.eulerOrder||Oe.DefaultOrder),s.makeRotationFromEuler(Bt.fromArray(D)),s.invert()}d.scale&&i.scale(nt.fromArray(d.scale)),d.scalingOffset&&a.setPosition(nt.fromArray(d.scalingOffset)),d.scalingPivot&&r.setPosition(nt.fromArray(d.scalingPivot)),d.rotationOffset&&o.setPosition(nt.fromArray(d.rotationOffset)),d.rotationPivot&&c.setPosition(nt.fromArray(d.rotationPivot)),d.parentMatrixWorld&&(l.copy(d.parentMatrix),u.copy(d.parentMatrixWorld));const T=t.clone().multiply(n).multiply(s),w=new ae;w.extractRotation(u);const x=new ae;x.copyPosition(u);const E=x.clone().invert().multiply(u),k=w.clone().invert().multiply(E),b=i,R=new ae;if(m===0)R.copy(w).multiply(T).multiply(k).multiply(b);else if(m===1)R.copy(w).multiply(k).multiply(T).multiply(b);else{const H=new ae().scale(new J().setFromMatrixScale(l)).clone().invert(),N=k.clone().multiply(H);R.copy(w).multiply(T).multiply(N).multiply(b)}const P=c.clone().invert(),O=r.clone().invert();let v=e.clone().multiply(o).multiply(c).multiply(t).multiply(n).multiply(s).multiply(P).multiply(a).multiply(r).multiply(i).multiply(O);const A=new ae().copyPosition(v),C=u.clone().multiply(A);return h.copyPosition(C),v=h.clone().multiply(R),v.premultiply(u.invert()),v}function ns(d){d=d||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return d===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[d]}function Ut(d){return d.split(",").map(function(t){return parseFloat(t)})}function ss(d,e,t){return e===void 0&&(e=0),t===void 0&&(t=d.byteLength),_e.decodeText(new Uint8Array(d,e,t))}function Yi(d,e){for(let t=0,n=d.length,s=e.length;t<s;t++,n++)d[n]=e[t]}function Qi(d,e,t,n){for(let s=t,i=0;s<n;s++,i++)d[i]=e[s];return d}function gn(d,e,t){return d.slice(0,e).concat(t).concat(d.slice(e))}class on extends Jt{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new tr(t)}),this.register(function(t){return new cr(t)}),this.register(function(t){return new lr(t)}),this.register(function(t){return new sr(t)}),this.register(function(t){return new ir(t)}),this.register(function(t){return new rr(t)}),this.register(function(t){return new or(t)}),this.register(function(t){return new er(t)}),this.register(function(t){return new ar(t)}),this.register(function(t){return new nr(t)}),this.register(function(t){return new $i(t)}),this.register(function(t){return new ur(t)}),this.register(function(t){return new hr(t)})}load(e,t,n,s){const i=this;let r;this.resourcePath!==""?r=this.resourcePath:this.path!==""?r=this.path:r=_e.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){s?s(c):console.error(c),i.manager.itemError(e),i.manager.itemEnd(e)},o=new xt(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(c){try{i.parse(c,r,function(u){t(u),i.manager.itemEnd(e)},a)}catch(u){a(u)}},n,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){let i;const r={},a={};if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(_e.decodeText(new Uint8Array(e,0,4))===is){try{r[le.KHR_BINARY_GLTF]=new dr(e)}catch(u){s&&s(u);return}i=JSON.parse(r[le.KHR_BINARY_GLTF].content)}else i=JSON.parse(_e.decodeText(new Uint8Array(e)));else i=e;if(i.asset===void 0||i.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const o=new Er(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});o.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const u=this.pluginCallbacks[c](o);a[u.name]=u,r[u.name]=!0}if(i.extensionsUsed)for(let c=0;c<i.extensionsUsed.length;++c){const u=i.extensionsUsed[c],l=i.extensionsRequired||[];switch(u){case le.KHR_MATERIALS_UNLIT:r[u]=new Ji;break;case le.KHR_DRACO_MESH_COMPRESSION:r[u]=new fr(i,this.dracoLoader);break;case le.KHR_TEXTURE_TRANSFORM:r[u]=new pr;break;case le.KHR_MESH_QUANTIZATION:r[u]=new mr;break;default:l.indexOf(u)>=0&&a[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}o.setExtensions(r),o.setPlugins(a),o.parse(n,s)}parseAsync(e,t){const n=this;return new Promise(function(s,i){n.parse(e,t,s,i)})}}function Zi(){let d={};return{get:function(e){return d[e]},add:function(e,t){d[e]=t},remove:function(e){delete d[e]},removeAll:function(){d={}}}}const le={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class $i{constructor(e){this.parser=e,this.name=le.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,s=t.length;n<s;n++){const i=t[n];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let s=t.cache.get(n);if(s)return s;const i=t.json,o=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let c;const u=new de(16777215);o.color!==void 0&&u.fromArray(o.color);const l=o.range!==void 0?o.range:0;switch(o.type){case"directional":c=new Ln(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Xt(u),c.distance=l;break;case"spot":c=new Pn(u),c.distance=l,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,c.angle=o.spot.outerConeAngle,c.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return c.position.set(0,0,0),c.decay=2,Ke(c,o),o.intensity!==void 0&&(c.intensity=o.intensity),c.name=t.createUniqueName(o.name||"light_"+e),s=Promise.resolve(c),t.cache.add(n,s),s}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(o){return n._getNodeRef(t.cache,a,o)})}}class Ji{constructor(){this.name=le.KHR_MATERIALS_UNLIT}getMaterialType(){return Ve}extendParams(e,t,n){const s=[];e.color=new de(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const r=i.baseColorFactor;e.color.fromArray(r),e.opacity=r[3]}i.baseColorTexture!==void 0&&s.push(n.assignTexture(e,"map",i.baseColorTexture,Ne))}return Promise.all(s)}}class er{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class tr{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],r=s.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(i.push(n.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const a=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new ne(a,a)}return Promise.all(i)}}class nr{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],r=s.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&i.push(n.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&i.push(n.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}}class sr{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new de(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=s.extensions[this.name];return r.sheenColorFactor!==void 0&&t.sheenColor.fromArray(r.sheenColorFactor),r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&i.push(n.assignTexture(t,"sheenColorMap",r.sheenColorTexture,Ne)),r.sheenRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}}class ir{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],r=s.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&i.push(n.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}}class rr{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],r=s.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&i.push(n.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const a=r.attenuationColor||[1,1,1];return t.attenuationColor=new de(a[0],a[1],a[2]),Promise.all(i)}}class or{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class ar{constructor(e){this.parser=e,this.name=le.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Qe}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],r=s.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&i.push(n.assignTexture(t,"specularIntensityMap",r.specularTexture));const a=r.specularColorFactor||[1,1,1];return t.specularColor=new de(a[0],a[1],a[2]),r.specularColorTexture!==void 0&&i.push(n.assignTexture(t,"specularColorMap",r.specularColorTexture,Ne)),Promise.all(i)}}class cr{constructor(e){this.parser=e,this.name=le.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,s=n.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const i=s.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}}class lr{constructor(e){this.parser=e,this.name=le.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,i=s.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],a=s.images[r.source];let o=n.textureLoader;if(a.uri){const c=n.options.manager.getHandler(a.uri);c!==null&&(o=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,r.source,o);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ur{constructor(e){this.name=le.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const s=n.extensions[this.name],i=this.parser.getDependency("buffer",s.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(a){const o=s.byteOffset||0,c=s.byteLength||0,u=s.count,l=s.byteStride,h=new Uint8Array(a,o,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(u,l,h,s.mode,s.filter).then(function(m){return m.buffer}):r.ready.then(function(){const m=new ArrayBuffer(u*l);return r.decodeGltfBuffer(new Uint8Array(m),u,l,h,s.mode,s.filter),m})})}else return null}}class hr{constructor(e){this.name=le.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const s=t.meshes[n.mesh];for(const c of s.primitives)if(c.mode!==Me.TRIANGLES&&c.mode!==Me.TRIANGLE_STRIP&&c.mode!==Me.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=n.extensions[this.name].attributes,a=[],o={};for(const c in r)a.push(this.parser.getDependency("accessor",r[c]).then(u=>(o[c]=u,o[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(c=>{const u=c.pop(),l=u.isGroup?u.children:[u],h=c[0].count,m=[];for(const T of l){const w=new ae,x=new J,E=new Te,k=new J(1,1,1),b=new ms(T.geometry,T.material,h);for(let R=0;R<h;R++)o.TRANSLATION&&x.fromBufferAttribute(o.TRANSLATION,R),o.ROTATION&&E.fromBufferAttribute(o.ROTATION,R),o.SCALE&&k.fromBufferAttribute(o.SCALE,R),b.setMatrixAt(R,w.compose(x,E,k));for(const R in o)R!=="TRANSLATION"&&R!=="ROTATION"&&R!=="SCALE"&&T.geometry.setAttribute(R,o[R]);it.prototype.copy.call(b,T),b.frustumCulled=!1,this.parser.assignFinalMaterial(b),m.push(b)}return u.isGroup?(u.clear(),u.add(...m),u):m[0]}))}}const is="glTF",at=12,yn={JSON:1313821514,BIN:5130562};class dr{constructor(e){this.name=le.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,at);if(this.header={magic:_e.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==is)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-at,s=new DataView(e,at);let i=0;for(;i<n;){const r=s.getUint32(i,!0);i+=4;const a=s.getUint32(i,!0);if(i+=4,a===yn.JSON){const o=new Uint8Array(e,at+i,r);this.content=_e.decodeText(o)}else if(a===yn.BIN){const o=at+i;this.body=e.slice(o,o+r)}i+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class fr{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=le.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,s=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,a={},o={},c={};for(const u in r){const l=Zt[u]||u.toLowerCase();a[l]=r[u]}for(const u in e.attributes){const l=Zt[u]||u.toLowerCase();if(r[u]!==void 0){const h=n.accessors[e.attributes[u]],m=rt[h.componentType];c[l]=m.name,o[l]=h.normalized===!0}}return t.getDependency("bufferView",i).then(function(u){return new Promise(function(l){s.decodeDracoFile(u,function(h){for(const m in h.attributes){const T=h.attributes[m],w=o[m];w!==void 0&&(T.normalized=w)}l(h)},a,c)})})}}class pr{constructor(){this.name=le.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class mr{constructor(){this.name=le.KHR_MESH_QUANTIZATION}}class rs extends Cs{constructor(e,t,n,s){super(e,t,n,s)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,s=this.valueSize,i=e*s*3+s;for(let r=0;r!==s;r++)t[r]=n[i+r];return t}interpolate_(e,t,n,s){const i=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=a*2,c=a*3,u=s-t,l=(n-t)/u,h=l*l,m=h*l,T=e*c,w=T-c,x=-2*m+3*h,E=m-h,k=1-x,b=E-h+l;for(let R=0;R!==a;R++){const P=r[w+R+a],O=r[w+R+o]*u,v=r[T+R+a],A=r[T+R]*u;i[R]=k*P+b*O+x*v+E*A}return i}}const gr=new Te;class yr extends rs{interpolate_(e,t,n,s){const i=super.interpolate_(e,t,n,s);return gr.fromArray(i).normalize().toArray(i),i}}const Me={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},rt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},xn={9728:bs,9729:_n,9984:Ts,9985:vs,9986:As,9987:Dn},wn={33071:Gt,33648:Ms,10497:ze},zt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Zt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},We={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},xr={CUBICSPLINE:void 0,LINEAR:Bn,STEP:Es},Ht={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function wr(d){return d.DefaultMaterial===void 0&&(d.DefaultMaterial=new Ct({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ss})),d.DefaultMaterial}function ct(d,e,t){for(const n in t.extensions)d[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function Ke(d,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(d.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function br(d,e,t){let n=!1,s=!1,i=!1;for(let c=0,u=e.length;c<u;c++){const l=e[c];if(l.POSITION!==void 0&&(n=!0),l.NORMAL!==void 0&&(s=!0),l.COLOR_0!==void 0&&(i=!0),n&&s&&i)break}if(!n&&!s&&!i)return Promise.resolve(d);const r=[],a=[],o=[];for(let c=0,u=e.length;c<u;c++){const l=e[c];if(n){const h=l.POSITION!==void 0?t.getDependency("accessor",l.POSITION):d.attributes.position;r.push(h)}if(s){const h=l.NORMAL!==void 0?t.getDependency("accessor",l.NORMAL):d.attributes.normal;a.push(h)}if(i){const h=l.COLOR_0!==void 0?t.getDependency("accessor",l.COLOR_0):d.attributes.color;o.push(h)}}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(c){const u=c[0],l=c[1],h=c[2];return n&&(d.morphAttributes.position=u),s&&(d.morphAttributes.normal=l),i&&(d.morphAttributes.color=h),d.morphTargetsRelative=!0,d})}function Tr(d,e){if(d.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)d.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(d.morphTargetInfluences.length===t.length){d.morphTargetDictionary={};for(let n=0,s=t.length;n<s;n++)d.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function vr(d){const e=d.extensions&&d.extensions[le.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+bn(e.attributes):t=d.indices+":"+bn(d.attributes)+":"+d.mode,t}function bn(d){let e="";const t=Object.keys(d).sort();for(let n=0,s=t.length;n<s;n++)e+=t[n]+":"+d[t[n]]+";";return e}function $t(d){switch(d){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Ar(d){return d.search(/\.jpe?g($|\?)/i)>0||d.search(/^data\:image\/jpeg/)===0?"image/jpeg":d.search(/\.webp($|\?)/i)>0||d.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Mr=new ae;class Er{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Zi,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,s=!1,i=-1;typeof navigator<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,i=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||s&&i<98?this.textureLoader=new Lt(this.options.manager):this.textureLoader=new gs(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new xt(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,s=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(r){const a={scene:r[0][s.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:s.asset,parser:n,userData:{}};ct(i,a,s),Ke(a,s),Promise.all(n._invokeAll(function(o){return o.afterRoot&&o.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let s=0,i=t.length;s<i;s++){const r=t[s].joints;for(let a=0,o=r.length;a<o;a++)e[r[a]].isBone=!0}for(let s=0,i=e.length;s<i;s++){const r=e[s];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(n[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const s=n.clone(),i=(r,a)=>{const o=this.associations.get(r);o!=null&&this.associations.set(a,o);for(const[c,u]of r.children.entries())i(u,a.children[c])};return i(n,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const s=e(t[n]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let s=0;s<t.length;s++){const i=e(t[s]);i&&n.push(i)}return n}getDependency(e,t){const n=e+":"+t;let s=this.cache.get(n);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":s=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:if(s=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!s)throw new Error("Unknown type: "+e);break}this.cache.add(n,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(i,r){return n.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[le.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(i,r){n.load(_e.resolveURL(t.uri,s.path),i,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const s=t.byteLength||0,i=t.byteOffset||0;return n.slice(i,i+s)})}loadAccessor(e){const t=this,n=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0){const r=zt[s.type],a=rt[s.componentType],o=s.normalized===!0,c=new a(s.count*r);return Promise.resolve(new ke(c,r,o))}const i=[];return s.bufferView!==void 0?i.push(this.getDependency("bufferView",s.bufferView)):i.push(null),s.sparse!==void 0&&(i.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(i).then(function(r){const a=r[0],o=zt[s.type],c=rt[s.componentType],u=c.BYTES_PER_ELEMENT,l=u*o,h=s.byteOffset||0,m=s.bufferView!==void 0?n.bufferViews[s.bufferView].byteStride:void 0,T=s.normalized===!0;let w,x;if(m&&m!==l){const E=Math.floor(h/m),k="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+E+":"+s.count;let b=t.cache.get(k);b||(w=new c(a,E*m,s.count*m/u),b=new ys(w,m/u),t.cache.add(k,b)),x=new xs(b,o,h%m/u,T)}else a===null?w=new c(s.count*o):w=new c(a,h,s.count*o),x=new ke(w,o,T);if(s.sparse!==void 0){const E=zt.SCALAR,k=rt[s.sparse.indices.componentType],b=s.sparse.indices.byteOffset||0,R=s.sparse.values.byteOffset||0,P=new k(r[1],b,s.sparse.count*E),O=new c(r[2],R,s.sparse.count*o);a!==null&&(x=new ke(x.array.slice(),x.itemSize,x.normalized));for(let v=0,A=P.length;v<A;v++){const C=P[v];if(x.setX(C,O[v*o]),o>=2&&x.setY(C,O[v*o+1]),o>=3&&x.setZ(C,O[v*o+2]),o>=4&&x.setW(C,O[v*o+3]),o>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return x})}loadTexture(e){const t=this.json,n=this.options,i=t.textures[e].source,r=t.images[i];let a=this.textureLoader;if(r.uri){const o=n.manager.getHandler(r.uri);o!==null&&(a=o)}return this.loadTextureImage(e,i,a)}loadTextureImage(e,t,n){const s=this,i=this.json,r=i.textures[e],a=i.images[t],o=(a.uri||a.bufferView)+":"+r.sampler;if(this.textureCache[o])return this.textureCache[o];const c=this.loadImageSource(t,n).then(function(u){u.flipY=!1,u.name=r.name||a.name||"";const h=(i.samplers||{})[r.sampler]||{};return u.magFilter=xn[h.magFilter]||_n,u.minFilter=xn[h.minFilter]||Dn,u.wrapS=wn[h.wrapS]||ze,u.wrapT=wn[h.wrapT]||ze,s.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[o]=c,c}loadImageSource(e,t){const n=this,s=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(l=>l.clone());const r=s.images[e],a=self.URL||self.webkitURL;let o=r.uri||"",c=!1;if(r.bufferView!==void 0)o=n.getDependency("bufferView",r.bufferView).then(function(l){c=!0;const h=new Blob([l],{type:r.mimeType});return o=a.createObjectURL(h),o});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(o).then(function(l){return new Promise(function(h,m){let T=h;t.isImageBitmapLoader===!0&&(T=function(w){const x=new Mt(w);x.needsUpdate=!0,h(x)}),t.load(_e.resolveURL(l,i.path),T,void 0,m)})}).then(function(l){return c===!0&&a.revokeObjectURL(o),l.userData.mimeType=r.mimeType||Ar(r.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),l});return this.sourceCache[e]=u,u}assignTexture(e,t,n,s){const i=this;return this.getDependency("texture",n.index).then(function(r){if(!r)return null;if(n.texCoord!==void 0&&n.texCoord!=0&&!(t==="aoMap"&&n.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),i.extensions[le.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[le.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const o=i.associations.get(r);r=i.extensions[le.KHR_TEXTURE_TRANSFORM].extendTexture(r,a),i.associations.set(r,o)}}return s!==void 0&&(r.encoding=s),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const s=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+n.uuid;let o=this.cache.get(a);o||(o=new Fn,Ot.prototype.copy.call(o,n),o.color.copy(n.color),o.map=n.map,o.sizeAttenuation=!1,this.cache.add(a,o)),n=o}else if(e.isLine){const a="LineBasicMaterial:"+n.uuid;let o=this.cache.get(a);o||(o=new bt,Ot.prototype.copy.call(o,n),o.color.copy(n.color),this.cache.add(a,o)),n=o}if(s||i||r){let a="ClonedMaterial:"+n.uuid+":";s&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),r&&(a+="flat-shading:");let o=this.cache.get(a);o||(o=n.clone(),i&&(o.vertexColors=!0),r&&(o.flatShading=!0),s&&(o.normalScale&&(o.normalScale.y*=-1),o.clearcoatNormalScale&&(o.clearcoatNormalScale.y*=-1)),this.cache.add(a,o),this.associations.set(o,this.associations.get(n))),n=o}n.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=n}getMaterialType(){return Ct}loadMaterial(e){const t=this,n=this.json,s=this.extensions,i=n.materials[e];let r;const a={},o=i.extensions||{},c=[];if(o[le.KHR_MATERIALS_UNLIT]){const l=s[le.KHR_MATERIALS_UNLIT];r=l.getMaterialType(),c.push(l.extendParams(a,i,t))}else{const l=i.pbrMetallicRoughness||{};if(a.color=new de(1,1,1),a.opacity=1,Array.isArray(l.baseColorFactor)){const h=l.baseColorFactor;a.color.fromArray(h),a.opacity=h[3]}l.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",l.baseColorTexture,Ne)),a.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,a.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",l.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",l.metallicRoughnessTexture))),r=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,a)})))}i.doubleSided===!0&&(a.side=nn);const u=i.alphaMode||Ht.OPAQUE;if(u===Ht.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,u===Ht.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&r!==Ve&&(c.push(t.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new ne(1,1),i.normalTexture.scale!==void 0)){const l=i.normalTexture.scale;a.normalScale.set(l,l)}return i.occlusionTexture!==void 0&&r!==Ve&&(c.push(t.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&r!==Ve&&(a.emissive=new de().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&r!==Ve&&c.push(t.assignTexture(a,"emissiveMap",i.emissiveTexture,Ne)),Promise.all(c).then(function(){const l=new r(a);return i.name&&(l.name=i.name),Ke(l,i),t.associations.set(l,{materials:e}),i.extensions&&ct(s,l,i),l})}createUniqueName(e){const t=dt.sanitizeNodeName(e||"");let n=t;for(let s=1;this.nodeNamesUsed[n];++s)n=t+"_"+s;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,n=this.extensions,s=this.primitiveCache;function i(a){return n[le.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(o){return Tn(o,a,t)})}const r=[];for(let a=0,o=e.length;a<o;a++){const c=e[a],u=vr(c),l=s[u];if(l)r.push(l.promise);else{let h;c.extensions&&c.extensions[le.KHR_DRACO_MESH_COMPRESSION]?h=i(c):h=Tn(new Be,c,t),s[u]={primitive:c,promise:h},r.push(h)}}return Promise.all(r)}loadMesh(e){const t=this,n=this.json,s=this.extensions,i=n.meshes[e],r=i.primitives,a=[];for(let o=0,c=r.length;o<c;o++){const u=r[o].material===void 0?wr(this.cache):this.getDependency("material",r[o].material);a.push(u)}return a.push(t.loadGeometries(r)),Promise.all(a).then(function(o){const c=o.slice(0,o.length-1),u=o[o.length-1],l=[];for(let m=0,T=u.length;m<T;m++){const w=u[m],x=r[m];let E;const k=c[m];if(x.mode===Me.TRIANGLES||x.mode===Me.TRIANGLE_STRIP||x.mode===Me.TRIANGLE_FAN||x.mode===void 0)E=i.isSkinnedMesh===!0?new Rn(w,k):new Re(w,k),E.isSkinnedMesh===!0&&!E.geometry.attributes.skinWeight.normalized&&E.normalizeSkinWeights(),x.mode===Me.TRIANGLE_STRIP?E.geometry=vn(E.geometry,Ps):x.mode===Me.TRIANGLE_FAN&&(E.geometry=vn(E.geometry,Un));else if(x.mode===Me.LINES)E=new Nn(w,k);else if(x.mode===Me.LINE_STRIP)E=new Rt(w,k);else if(x.mode===Me.LINE_LOOP)E=new ws(w,k);else if(x.mode===Me.POINTS)E=new Vn(w,k);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+x.mode);Object.keys(E.geometry.morphAttributes).length>0&&Tr(E,i),E.name=t.createUniqueName(i.name||"mesh_"+e),Ke(E,i),x.extensions&&ct(s,E,x),t.assignFinalMaterial(E),l.push(E)}for(let m=0,T=l.length;m<T;m++)t.associations.set(l[m],{meshes:e,primitives:m});if(l.length===1)return l[0];const h=new st;t.associations.set(h,{meshes:e});for(let m=0,T=l.length;m<T;m++)h.add(l[m]);return h})}loadCamera(e){let t;const n=this.json.cameras[e],s=n[n.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new wt(Ee.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):n.type==="orthographic"&&(t=new tn(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Ke(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let s=0,i=t.joints.length;s<i;s++)n.push(this.getDependency("node",t.joints[s]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(s){const i=s.pop(),r=s,a=[],o=[];for(let c=0,u=r.length;c<u;c++){const l=r[c];if(l){a.push(l);const h=new ae;i!==null&&h.fromArray(i.array,c*16),o.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new Cn(a,o)})}loadAnimation(e){const n=this.json.animations[e],s=[],i=[],r=[],a=[],o=[];for(let c=0,u=n.channels.length;c<u;c++){const l=n.channels[c],h=n.samplers[l.sampler],m=l.target,T=m.node,w=n.parameters!==void 0?n.parameters[h.input]:h.input,x=n.parameters!==void 0?n.parameters[h.output]:h.output;s.push(this.getDependency("node",T)),i.push(this.getDependency("accessor",w)),r.push(this.getDependency("accessor",x)),a.push(h),o.push(m)}return Promise.all([Promise.all(s),Promise.all(i),Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(c){const u=c[0],l=c[1],h=c[2],m=c[3],T=c[4],w=[];for(let E=0,k=u.length;E<k;E++){const b=u[E],R=l[E],P=h[E],O=m[E],v=T[E];if(b===void 0)continue;b.updateMatrix();let A;switch(We[v.path]){case We.weights:A=On;break;case We.rotation:A=Kt;break;case We.position:case We.scale:default:A=kn;break}const C=b.name?b.name:b.uuid,D=O.interpolation!==void 0?xr[O.interpolation]:Bn,H=[];We[v.path]===We.weights?b.traverse(function(j){j.morphTargetInfluences&&H.push(j.name?j.name:j.uuid)}):H.push(C);let N=P.array;if(P.normalized){const j=$t(N.constructor),W=new Float32Array(N.length);for(let se=0,ee=N.length;se<ee;se++)W[se]=N[se]*j;N=W}for(let j=0,W=H.length;j<W;j++){const se=new A(H[j]+"."+We[v.path],R.array,N,D);O.interpolation==="CUBICSPLINE"&&(se.createInterpolant=function(q){const V=this instanceof Kt?yr:rs;return new V(this.times,this.values,this.getValueSize()/3,q)},se.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),w.push(se)}}const x=n.name?n.name:"animation_"+e;return new In(x,void 0,w)})}createNodeMesh(e){const t=this.json,n=this,s=t.nodes[e];return s.mesh===void 0?null:n.getDependency("mesh",s.mesh).then(function(i){const r=n._getNodeRef(n.meshCache,s.mesh,i);return s.weights!==void 0&&r.traverse(function(a){if(!!a.isMesh)for(let o=0,c=s.weights.length;o<c;o++)a.morphTargetInfluences[o]=s.weights[o]}),r})}loadNode(e){const t=this.json,n=this.extensions,s=this,i=t.nodes[e],r=i.name?s.createUniqueName(i.name):"";return function(){const a=[],o=s._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(e)});o&&a.push(o),i.camera!==void 0&&a.push(s.getDependency("camera",i.camera).then(function(h){return s._getNodeRef(s.cameraCache,i.camera,h)})),s._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(e)}).forEach(function(h){a.push(h)});const c=[],u=i.children||[];for(let h=0,m=u.length;h<m;h++)c.push(s.getDependency("node",u[h]));const l=i.skin===void 0?Promise.resolve(null):s.getDependency("skin",i.skin);return Promise.all([Promise.all(a),Promise.all(c),l])}().then(function(a){const o=a[0],c=a[1],u=a[2];let l;if(i.isBone===!0?l=new Wt:o.length>1?l=new st:o.length===1?l=o[0]:l=new it,l!==o[0])for(let h=0,m=o.length;h<m;h++)l.add(o[h]);if(i.name&&(l.userData.name=i.name,l.name=r),Ke(l,i),i.extensions&&ct(n,l,i),i.matrix!==void 0){const h=new ae;h.fromArray(i.matrix),l.applyMatrix4(h)}else i.translation!==void 0&&l.position.fromArray(i.translation),i.rotation!==void 0&&l.quaternion.fromArray(i.rotation),i.scale!==void 0&&l.scale.fromArray(i.scale);s.associations.has(l)||s.associations.set(l,{}),s.associations.get(l).nodes=e,u!==null&&l.traverse(function(h){!h.isSkinnedMesh||h.bind(u,Mr)});for(let h=0,m=c.length;h<m;h++)l.add(c[h]);return l})}loadScene(e){const t=this.extensions,n=this.json.scenes[e],s=this,i=new st;n.name&&(i.name=s.createUniqueName(n.name)),Ke(i,n),n.extensions&&ct(t,i,n);const r=n.nodes||[],a=[];for(let o=0,c=r.length;o<c;o++)a.push(s.getDependency("node",r[o]));return Promise.all(a).then(function(o){for(let u=0,l=o.length;u<l;u++)i.add(o[u]);const c=u=>{const l=new Map;for(const[h,m]of s.associations)(h instanceof Ot||h instanceof Mt)&&l.set(h,m);return u.traverse(h=>{const m=s.associations.get(h);m!=null&&l.set(h,m)}),l};return s.associations=c(i),i})}}function Sr(d,e,t){const n=e.attributes,s=new Ls;if(n.POSITION!==void 0){const a=t.json.accessors[n.POSITION],o=a.min,c=a.max;if(o!==void 0&&c!==void 0){if(s.set(new J(o[0],o[1],o[2]),new J(c[0],c[1],c[2])),a.normalized){const u=$t(rt[a.componentType]);s.min.multiplyScalar(u),s.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const a=new J,o=new J;for(let c=0,u=i.length;c<u;c++){const l=i[c];if(l.POSITION!==void 0){const h=t.json.accessors[l.POSITION],m=h.min,T=h.max;if(m!==void 0&&T!==void 0){if(o.setX(Math.max(Math.abs(m[0]),Math.abs(T[0]))),o.setY(Math.max(Math.abs(m[1]),Math.abs(T[1]))),o.setZ(Math.max(Math.abs(m[2]),Math.abs(T[2]))),h.normalized){const w=$t(rt[h.componentType]);o.multiplyScalar(w)}a.max(o)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(a)}d.boundingBox=s;const r=new Rs;s.getCenter(r.center),r.radius=s.min.distanceTo(s.max)/2,d.boundingSphere=r}function Tn(d,e,t){const n=e.attributes,s=[];function i(r,a){return t.getDependency("accessor",r).then(function(o){d.setAttribute(a,o)})}for(const r in n){const a=Zt[r]||r.toLowerCase();a in d.attributes||s.push(i(n[r],a))}if(e.indices!==void 0&&!d.index){const r=t.getDependency("accessor",e.indices).then(function(a){d.setIndex(a)});s.push(r)}return Ke(d,e),Sr(d,e,t),Promise.all(s).then(function(){return e.targets!==void 0?br(d,e.targets,t):d})}function vn(d,e){let t=d.getIndex();if(t===null){const r=[],a=d.getAttribute("position");if(a!==void 0){for(let o=0;o<a.count;o++)r.push(o);d.setIndex(r),t=d.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),d}const n=t.count-2,s=[];if(e===Un)for(let r=1;r<=n;r++)s.push(t.getX(0)),s.push(t.getX(r)),s.push(t.getX(r+1));else for(let r=0;r<n;r++)r%2===0?(s.push(t.getX(r)),s.push(t.getX(r+1)),s.push(t.getX(r+2))):(s.push(t.getX(r+2)),s.push(t.getX(r+1)),s.push(t.getX(r)));s.length/3!==n&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=d.clone();return i.setIndex(s),i}class pt extends Jt{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(e,t,n,s){const i=this,r=new xt(i.manager);r.setPath(i.path),r.setRequestHeader(i.requestHeader),r.setWithCredentials(i.withCredentials),r.load(e,function(a){try{t(i.parse(a))}catch(o){s?s(o):console.error(o),i.manager.itemError(e)}},n,s)}parse(e){const t=this;function n(M,y){if(M.nodeType!==1)return;const p=R(M);let f=!1,_=null;switch(M.nodeName){case"svg":y=T(M,y);break;case"style":i(M);break;case"g":y=T(M,y);break;case"path":y=T(M,y),M.hasAttribute("d")&&(_=s(M));break;case"rect":y=T(M,y),_=o(M);break;case"polygon":y=T(M,y),_=c(M);break;case"polyline":y=T(M,y),_=u(M);break;case"circle":y=T(M,y),_=l(M);break;case"ellipse":y=T(M,y),_=h(M);break;case"line":y=T(M,y),_=m(M);break;case"defs":f=!0;break;case"use":y=T(M,y);const z=(M.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),G=M.viewportElement.getElementById(z);G?n(G,y):console.warn("SVGLoader: 'use node' references non-existent node id: "+z);break}_&&(y.fill!==void 0&&y.fill!=="none"&&_.color.setStyle(y.fill),O(_,Z),N.push(_),_.userData={node:M,style:y});const U=M.childNodes;for(let I=0;I<U.length;I++){const z=U[I];f&&z.nodeName!=="style"&&z.nodeName!=="defs"||n(z,y)}p&&(W.pop(),W.length>0?Z.copy(W[W.length-1]):Z.identity())}function s(M){const y=new $e,p=new ne,f=new ne,_=new ne;let U=!0,I=!1;const G=M.getAttribute("d").match(/[a-df-z][^a-df-z]*/ig);for(let X=0,F=G.length;X<F;X++){const B=G[X],K=B.charAt(0),Y=B.slice(1).trim();U===!0&&(I=!0,U=!1);let L;switch(K){case"M":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=2)p.x=L[g+0],p.y=L[g+1],f.x=p.x,f.y=p.y,g===0?y.moveTo(p.x,p.y):y.lineTo(p.x,p.y),g===0&&_.copy(p);break;case"H":L=x(Y);for(let g=0,Q=L.length;g<Q;g++)p.x=L[g],f.x=p.x,f.y=p.y,y.lineTo(p.x,p.y),g===0&&I===!0&&_.copy(p);break;case"V":L=x(Y);for(let g=0,Q=L.length;g<Q;g++)p.y=L[g],f.x=p.x,f.y=p.y,y.lineTo(p.x,p.y),g===0&&I===!0&&_.copy(p);break;case"L":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=2)p.x=L[g+0],p.y=L[g+1],f.x=p.x,f.y=p.y,y.lineTo(p.x,p.y),g===0&&I===!0&&_.copy(p);break;case"C":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=6)y.bezierCurveTo(L[g+0],L[g+1],L[g+2],L[g+3],L[g+4],L[g+5]),f.x=L[g+2],f.y=L[g+3],p.x=L[g+4],p.y=L[g+5],g===0&&I===!0&&_.copy(p);break;case"S":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=4)y.bezierCurveTo(w(p.x,f.x),w(p.y,f.y),L[g+0],L[g+1],L[g+2],L[g+3]),f.x=L[g+0],f.y=L[g+1],p.x=L[g+2],p.y=L[g+3],g===0&&I===!0&&_.copy(p);break;case"Q":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=4)y.quadraticCurveTo(L[g+0],L[g+1],L[g+2],L[g+3]),f.x=L[g+0],f.y=L[g+1],p.x=L[g+2],p.y=L[g+3],g===0&&I===!0&&_.copy(p);break;case"T":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=2){const re=w(p.x,f.x),we=w(p.y,f.y);y.quadraticCurveTo(re,we,L[g+0],L[g+1]),f.x=re,f.y=we,p.x=L[g+0],p.y=L[g+1],g===0&&I===!0&&_.copy(p)}break;case"A":L=x(Y,[3,4],7);for(let g=0,Q=L.length;g<Q;g+=7){if(L[g+5]==p.x&&L[g+6]==p.y)continue;const re=p.clone();p.x=L[g+5],p.y=L[g+6],f.x=p.x,f.y=p.y,r(y,L[g],L[g+1],L[g+2],L[g+3],L[g+4],re,p),g===0&&I===!0&&_.copy(p)}break;case"m":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=2)p.x+=L[g+0],p.y+=L[g+1],f.x=p.x,f.y=p.y,g===0?y.moveTo(p.x,p.y):y.lineTo(p.x,p.y),g===0&&_.copy(p);break;case"h":L=x(Y);for(let g=0,Q=L.length;g<Q;g++)p.x+=L[g],f.x=p.x,f.y=p.y,y.lineTo(p.x,p.y),g===0&&I===!0&&_.copy(p);break;case"v":L=x(Y);for(let g=0,Q=L.length;g<Q;g++)p.y+=L[g],f.x=p.x,f.y=p.y,y.lineTo(p.x,p.y),g===0&&I===!0&&_.copy(p);break;case"l":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=2)p.x+=L[g+0],p.y+=L[g+1],f.x=p.x,f.y=p.y,y.lineTo(p.x,p.y),g===0&&I===!0&&_.copy(p);break;case"c":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=6)y.bezierCurveTo(p.x+L[g+0],p.y+L[g+1],p.x+L[g+2],p.y+L[g+3],p.x+L[g+4],p.y+L[g+5]),f.x=p.x+L[g+2],f.y=p.y+L[g+3],p.x+=L[g+4],p.y+=L[g+5],g===0&&I===!0&&_.copy(p);break;case"s":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=4)y.bezierCurveTo(w(p.x,f.x),w(p.y,f.y),p.x+L[g+0],p.y+L[g+1],p.x+L[g+2],p.y+L[g+3]),f.x=p.x+L[g+0],f.y=p.y+L[g+1],p.x+=L[g+2],p.y+=L[g+3],g===0&&I===!0&&_.copy(p);break;case"q":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=4)y.quadraticCurveTo(p.x+L[g+0],p.y+L[g+1],p.x+L[g+2],p.y+L[g+3]),f.x=p.x+L[g+0],f.y=p.y+L[g+1],p.x+=L[g+2],p.y+=L[g+3],g===0&&I===!0&&_.copy(p);break;case"t":L=x(Y);for(let g=0,Q=L.length;g<Q;g+=2){const re=w(p.x,f.x),we=w(p.y,f.y);y.quadraticCurveTo(re,we,p.x+L[g+0],p.y+L[g+1]),f.x=re,f.y=we,p.x=p.x+L[g+0],p.y=p.y+L[g+1],g===0&&I===!0&&_.copy(p)}break;case"a":L=x(Y,[3,4],7);for(let g=0,Q=L.length;g<Q;g+=7){if(L[g+5]==0&&L[g+6]==0)continue;const re=p.clone();p.x+=L[g+5],p.y+=L[g+6],f.x=p.x,f.y=p.y,r(y,L[g],L[g+1],L[g+2],L[g+3],L[g+4],re,p),g===0&&I===!0&&_.copy(p)}break;case"Z":case"z":y.currentPath.autoClose=!0,y.currentPath.curves.length>0&&(p.copy(_),y.currentPath.currentPoint.copy(p),U=!0);break;default:console.warn(B)}I=!1}return y}function i(M){if(!(!M.sheet||!M.sheet.cssRules||!M.sheet.cssRules.length))for(let y=0;y<M.sheet.cssRules.length;y++){const p=M.sheet.cssRules[y];if(p.type!==1)continue;const f=p.selectorText.split(/,/gm).filter(Boolean).map(_=>_.trim());for(let _=0;_<f.length;_++){const U=Object.fromEntries(Object.entries(p.style).filter(([,I])=>I!==""));j[f[_]]=Object.assign(j[f[_]]||{},U)}}}function r(M,y,p,f,_,U,I,z){if(y==0||p==0){M.lineTo(z.x,z.y);return}f=f*Math.PI/180,y=Math.abs(y),p=Math.abs(p);const G=(I.x-z.x)/2,X=(I.y-z.y)/2,F=Math.cos(f)*G+Math.sin(f)*X,B=-Math.sin(f)*G+Math.cos(f)*X;let K=y*y,Y=p*p;const L=F*F,g=B*B,Q=L/K+g/Y;if(Q>1){const $=Math.sqrt(Q);y=$*y,p=$*p,K=y*y,Y=p*p}const re=K*g+Y*L,we=(K*Y-re)/re;let Ae=Math.sqrt(Math.max(0,we));_===U&&(Ae=-Ae);const ye=Ae*y*B/p,Ce=-Ae*p*F/y,Ze=Math.cos(f)*ye-Math.sin(f)*Ce+(I.x+z.x)/2,ot=Math.sin(f)*ye+Math.cos(f)*Ce+(I.y+z.y)/2,He=a(1,0,(F-ye)/y,(B-Ce)/p),S=a((F-ye)/y,(B-Ce)/p,(-F-ye)/y,(-B-Ce)/p)%(Math.PI*2);M.currentPath.absellipse(Ze,ot,y,p,He,He+S,U===0,f)}function a(M,y,p,f){const _=M*p+y*f,U=Math.sqrt(M*M+y*y)*Math.sqrt(p*p+f*f);let I=Math.acos(Math.max(-1,Math.min(1,_/U)));return M*f-y*p<0&&(I=-I),I}function o(M){const y=b(M.getAttribute("x")||0),p=b(M.getAttribute("y")||0),f=b(M.getAttribute("rx")||M.getAttribute("ry")||0),_=b(M.getAttribute("ry")||M.getAttribute("rx")||0),U=b(M.getAttribute("width")),I=b(M.getAttribute("height")),z=1-.551915024494,G=new $e;return G.moveTo(y+f,p),G.lineTo(y+U-f,p),(f!==0||_!==0)&&G.bezierCurveTo(y+U-f*z,p,y+U,p+_*z,y+U,p+_),G.lineTo(y+U,p+I-_),(f!==0||_!==0)&&G.bezierCurveTo(y+U,p+I-_*z,y+U-f*z,p+I,y+U-f,p+I),G.lineTo(y+f,p+I),(f!==0||_!==0)&&G.bezierCurveTo(y+f*z,p+I,y,p+I-_*z,y,p+I-_),G.lineTo(y,p+_),(f!==0||_!==0)&&G.bezierCurveTo(y,p+_*z,y+f*z,p,y+f,p),G}function c(M){function y(U,I,z){const G=b(I),X=b(z);_===0?f.moveTo(G,X):f.lineTo(G,X),_++}const p=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,f=new $e;let _=0;return M.getAttribute("points").replace(p,y),f.currentPath.autoClose=!0,f}function u(M){function y(U,I,z){const G=b(I),X=b(z);_===0?f.moveTo(G,X):f.lineTo(G,X),_++}const p=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,f=new $e;let _=0;return M.getAttribute("points").replace(p,y),f.currentPath.autoClose=!1,f}function l(M){const y=b(M.getAttribute("cx")||0),p=b(M.getAttribute("cy")||0),f=b(M.getAttribute("r")||0),_=new _t;_.absarc(y,p,f,0,Math.PI*2);const U=new $e;return U.subPaths.push(_),U}function h(M){const y=b(M.getAttribute("cx")||0),p=b(M.getAttribute("cy")||0),f=b(M.getAttribute("rx")||0),_=b(M.getAttribute("ry")||0),U=new _t;U.absellipse(y,p,f,_,0,Math.PI*2);const I=new $e;return I.subPaths.push(U),I}function m(M){const y=b(M.getAttribute("x1")||0),p=b(M.getAttribute("y1")||0),f=b(M.getAttribute("x2")||0),_=b(M.getAttribute("y2")||0),U=new $e;return U.moveTo(y,p),U.lineTo(f,_),U.currentPath.autoClose=!1,U}function T(M,y){y=Object.assign({},y);let p={};if(M.hasAttribute("class")){const I=M.getAttribute("class").split(/\s/).filter(Boolean).map(z=>z.trim());for(let z=0;z<I.length;z++)p=Object.assign(p,j["."+I[z]])}M.hasAttribute("id")&&(p=Object.assign(p,j["#"+M.getAttribute("id")]));function f(I,z,G){G===void 0&&(G=function(F){return F.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),F}),M.hasAttribute(I)&&(y[z]=G(M.getAttribute(I))),p[I]&&(y[z]=G(p[I])),M.style&&M.style[I]!==""&&(y[z]=G(M.style[I]))}function _(I){return Math.max(0,Math.min(1,b(I)))}function U(I){return Math.max(0,b(I))}return f("fill","fill"),f("fill-opacity","fillOpacity",_),f("fill-rule","fillRule"),f("opacity","opacity",_),f("stroke","stroke"),f("stroke-opacity","strokeOpacity",_),f("stroke-width","strokeWidth",U),f("stroke-linejoin","strokeLineJoin"),f("stroke-linecap","strokeLineCap"),f("stroke-miterlimit","strokeMiterLimit",U),f("visibility","visibility"),y}function w(M,y){return M-(y-M)}function x(M,y,p){if(typeof M!="string")throw new TypeError("Invalid input: "+typeof M);const f={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},_=0,U=1,I=2,z=3;let G=_,X=!0,F="",B="";const K=[];function Y(re,we,Ae){const ye=new SyntaxError('Unexpected character "'+re+'" at index '+we+".");throw ye.partial=Ae,ye}function L(){F!==""&&(B===""?K.push(Number(F)):K.push(Number(F)*Math.pow(10,Number(B)))),F="",B=""}let g;const Q=M.length;for(let re=0;re<Q;re++){if(g=M[re],Array.isArray(y)&&y.includes(K.length%p)&&f.FLAGS.test(g)){G=U,F=g,L();continue}if(G===_){if(f.WHITESPACE.test(g))continue;if(f.DIGIT.test(g)||f.SIGN.test(g)){G=U,F=g;continue}if(f.POINT.test(g)){G=I,F=g;continue}f.COMMA.test(g)&&(X&&Y(g,re,K),X=!0)}if(G===U){if(f.DIGIT.test(g)){F+=g;continue}if(f.POINT.test(g)){F+=g,G=I;continue}if(f.EXP.test(g)){G=z;continue}f.SIGN.test(g)&&F.length===1&&f.SIGN.test(F[0])&&Y(g,re,K)}if(G===I){if(f.DIGIT.test(g)){F+=g;continue}if(f.EXP.test(g)){G=z;continue}f.POINT.test(g)&&F[F.length-1]==="."&&Y(g,re,K)}if(G===z){if(f.DIGIT.test(g)){B+=g;continue}if(f.SIGN.test(g)){if(B===""){B+=g;continue}B.length===1&&f.SIGN.test(B)&&Y(g,re,K)}}f.WHITESPACE.test(g)?(L(),G=_,X=!1):f.COMMA.test(g)?(L(),G=_,X=!0):f.SIGN.test(g)?(L(),G=U,F=g):f.POINT.test(g)?(L(),G=I,F=g):Y(g,re,K)}return L(),K}const E=["mm","cm","in","pt","pc","px"],k={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function b(M){let y="px";if(typeof M=="string"||M instanceof String)for(let f=0,_=E.length;f<_;f++){const U=E[f];if(M.endsWith(U)){y=U,M=M.substring(0,M.length-U.length);break}}let p;return y==="px"&&t.defaultUnit!=="px"?p=k.in[t.defaultUnit]/t.defaultDPI:(p=k[y][t.defaultUnit],p<0&&(p=k[y].in*t.defaultDPI)),p*parseFloat(M)}function R(M){if(!(M.hasAttribute("transform")||M.nodeName==="use"&&(M.hasAttribute("x")||M.hasAttribute("y"))))return null;const y=P(M);return W.length>0&&y.premultiply(W[W.length-1]),Z.copy(y),W.push(y),y}function P(M){const y=new Xe,p=se;if(M.nodeName==="use"&&(M.hasAttribute("x")||M.hasAttribute("y"))){const f=b(M.getAttribute("x")),_=b(M.getAttribute("y"));y.translate(f,_)}if(M.hasAttribute("transform")){const f=M.getAttribute("transform").split(")");for(let _=f.length-1;_>=0;_--){const U=f[_].trim();if(U==="")continue;const I=U.indexOf("("),z=U.length;if(I>0&&I<z){const G=U.slice(0,I),X=x(U.slice(I+1));switch(p.identity(),G){case"translate":if(X.length>=1){const F=X[0];let B=0;X.length>=2&&(B=X[1]),p.translate(F,B)}break;case"rotate":if(X.length>=1){let F=0,B=0,K=0;F=X[0]*Math.PI/180,X.length>=3&&(B=X[1],K=X[2]),ee.makeTranslation(-B,-K),q.makeRotation(F),V.multiplyMatrices(q,ee),ee.makeTranslation(B,K),p.multiplyMatrices(ee,V)}break;case"scale":if(X.length>=1){const F=X[0];let B=F;X.length>=2&&(B=X[1]),p.scale(F,B)}break;case"skewX":X.length===1&&p.set(1,Math.tan(X[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":X.length===1&&p.set(1,0,0,Math.tan(X[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":X.length===6&&p.set(X[0],X[2],X[4],X[1],X[3],X[5],0,0,1);break}}y.premultiply(p)}}return y}function O(M,y){function p(I){ce.set(I.x,I.y,1).applyMatrix3(y),I.set(ce.x,ce.y)}function f(I){const z=I.xRadius,G=I.yRadius,X=Math.cos(I.aRotation),F=Math.sin(I.aRotation),B=new J(z*X,z*F,0),K=new J(-G*F,G*X,0),Y=B.applyMatrix3(y),L=K.applyMatrix3(y),g=se.set(Y.x,L.x,0,Y.y,L.y,0,0,0,1),Q=ee.copy(g).invert(),Ae=q.copy(Q).transpose().multiply(Q).elements,ye=H(Ae[0],Ae[1],Ae[4]),Ce=Math.sqrt(ye.rt1),Ze=Math.sqrt(ye.rt2);if(I.xRadius=1/Ce,I.yRadius=1/Ze,I.aRotation=Math.atan2(ye.sn,ye.cs),!((I.aEndAngle-I.aStartAngle)%(2*Math.PI)<Number.EPSILON)){const He=ee.set(Ce,0,0,0,Ze,0,0,0,1),S=q.set(ye.cs,ye.sn,0,-ye.sn,ye.cs,0,0,0,1),$=He.multiply(S).multiply(g),me=xe=>{const{x:ve,y:je}=new J(Math.cos(xe),Math.sin(xe),0).applyMatrix3($);return Math.atan2(je,ve)};I.aStartAngle=me(I.aStartAngle),I.aEndAngle=me(I.aEndAngle),v(y)&&(I.aClockwise=!I.aClockwise)}}function _(I){const z=C(y),G=D(y);I.xRadius*=z,I.yRadius*=G;const X=z>Number.EPSILON?Math.atan2(y.elements[1],y.elements[0]):Math.atan2(-y.elements[3],y.elements[4]);I.aRotation+=X,v(y)&&(I.aStartAngle*=-1,I.aEndAngle*=-1,I.aClockwise=!I.aClockwise)}const U=M.subPaths;for(let I=0,z=U.length;I<z;I++){const X=U[I].curves;for(let F=0;F<X.length;F++){const B=X[F];B.isLineCurve?(p(B.v1),p(B.v2)):B.isCubicBezierCurve?(p(B.v0),p(B.v1),p(B.v2),p(B.v3)):B.isQuadraticBezierCurve?(p(B.v0),p(B.v1),p(B.v2)):B.isEllipseCurve&&(ue.set(B.aX,B.aY),p(ue),B.aX=ue.x,B.aY=ue.y,A(y)?f(B):_(B))}}}function v(M){const y=M.elements;return y[0]*y[4]-y[1]*y[3]<0}function A(M){const y=M.elements,p=y[0]*y[3]+y[1]*y[4];if(p===0)return!1;const f=C(M),_=D(M);return Math.abs(p/(f*_))>Number.EPSILON}function C(M){const y=M.elements;return Math.sqrt(y[0]*y[0]+y[1]*y[1])}function D(M){const y=M.elements;return Math.sqrt(y[3]*y[3]+y[4]*y[4])}function H(M,y,p){let f,_,U,I,z;const G=M+p,X=M-p,F=Math.sqrt(X*X+4*y*y);return G>0?(f=.5*(G+F),z=1/f,_=M*z*p-y*z*y):G<0?_=.5*(G-F):(f=.5*F,_=-.5*F),X>0?U=X+F:U=X-F,Math.abs(U)>2*Math.abs(y)?(z=-2*y/U,I=1/Math.sqrt(1+z*z),U=z*I):Math.abs(y)===0?(U=1,I=0):(z=-.5*U/y,U=1/Math.sqrt(1+z*z),I=z*U),X>0&&(z=U,U=-I,I=z),{rt1:f,rt2:_,cs:U,sn:I}}const N=[],j={},W=[],se=new Xe,ee=new Xe,q=new Xe,V=new Xe,ue=new ne,ce=new J,Z=new Xe,te=new DOMParser().parseFromString(e,"image/svg+xml");return n(te.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:N,xml:te.documentElement}}static createShapes(e){const n={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},s={loc:n.ORIGIN,t:0};function i(w,x,E,k){const b=w.x,R=x.x,P=E.x,O=k.x,v=w.y,A=x.y,C=E.y,D=k.y,H=(O-P)*(v-C)-(D-C)*(b-P),N=(R-b)*(v-C)-(A-v)*(b-P),j=(D-C)*(R-b)-(O-P)*(A-v),W=H/j,se=N/j;if(j===0&&H!==0||W<=0||W>=1||se<0||se>1)return null;if(H===0&&j===0){for(let ee=0;ee<2;ee++)if(r(ee===0?E:k,w,x),s.loc==n.ORIGIN){const q=ee===0?E:k;return{x:q.x,y:q.y,t:s.t}}else if(s.loc==n.BETWEEN){const q=+(b+s.t*(R-b)).toPrecision(10),V=+(v+s.t*(A-v)).toPrecision(10);return{x:q,y:V,t:s.t}}return null}else{for(let V=0;V<2;V++)if(r(V===0?E:k,w,x),s.loc==n.ORIGIN){const ue=V===0?E:k;return{x:ue.x,y:ue.y,t:s.t}}const ee=+(b+W*(R-b)).toPrecision(10),q=+(v+W*(A-v)).toPrecision(10);return{x:ee,y:q,t:W}}}function r(w,x,E){const k=E.x-x.x,b=E.y-x.y,R=w.x-x.x,P=w.y-x.y,O=k*P-R*b;if(w.x===x.x&&w.y===x.y){s.loc=n.ORIGIN,s.t=0;return}if(w.x===E.x&&w.y===E.y){s.loc=n.DESTINATION,s.t=1;return}if(O<-Number.EPSILON){s.loc=n.LEFT;return}if(O>Number.EPSILON){s.loc=n.RIGHT;return}if(k*R<0||b*P<0){s.loc=n.BEHIND;return}if(Math.sqrt(k*k+b*b)<Math.sqrt(R*R+P*P)){s.loc=n.BEYOND;return}let v;k!==0?v=R/k:v=P/b,s.loc=n.BETWEEN,s.t=v}function a(w,x){const E=[],k=[];for(let b=1;b<w.length;b++){const R=w[b-1],P=w[b];for(let O=1;O<x.length;O++){const v=x[O-1],A=x[O],C=i(R,P,v,A);C!==null&&E.find(D=>D.t<=C.t+Number.EPSILON&&D.t>=C.t-Number.EPSILON)===void 0&&(E.push(C),k.push(new ne(C.x,C.y)))}}return k}function o(w,x,E){const k=new ne;x.getCenter(k);const b=[];return E.forEach(R=>{R.boundingBox.containsPoint(k)&&a(w,R.points).forEach(O=>{b.push({identifier:R.identifier,isCW:R.isCW,point:O})})}),b.sort((R,P)=>R.point.x-P.point.x),b}function c(w,x,E,k,b){(b==null||b==="")&&(b="nonzero");const R=new ne;w.boundingBox.getCenter(R);const P=[new ne(E,R.y),new ne(k,R.y)],O=o(P,w.boundingBox,x);O.sort((N,j)=>N.point.x-j.point.x);const v=[],A=[];O.forEach(N=>{N.identifier===w.identifier?v.push(N):A.push(N)});const C=v[0].point.x,D=[];let H=0;for(;H<A.length&&A[H].point.x<C;)D.length>0&&D[D.length-1]===A[H].identifier?D.pop():D.push(A[H].identifier),H++;if(D.push(w.identifier),b==="evenodd"){const N=D.length%2===0,j=D[D.length-2];return{identifier:w.identifier,isHole:N,for:j}}else if(b==="nonzero"){let N=!0,j=null,W=null;for(let se=0;se<D.length;se++){const ee=D[se];N?(W=x[ee].isCW,N=!1,j=ee):W!==x[ee].isCW&&(W=x[ee].isCW,N=!0)}return{identifier:w.identifier,isHole:N,for:j}}else console.warn('fill-rule: "'+b+'" is currently not implemented.')}let u=999999999,l=-999999999,h=e.subPaths.map(w=>{const x=w.getPoints();let E=-999999999,k=999999999,b=-999999999,R=999999999;for(let P=0;P<x.length;P++){const O=x[P];O.y>E&&(E=O.y),O.y<k&&(k=O.y),O.x>b&&(b=O.x),O.x<R&&(R=O.x)}return l<=b&&(l=b+1),u>=R&&(u=R-1),{curves:w.curves,points:x,isCW:Is.isClockWise(x),identifier:-1,boundingBox:new ks(new ne(R,k),new ne(b,E))}});h=h.filter(w=>w.points.length>1);for(let w=0;w<h.length;w++)h[w].identifier=w;const m=h.map(w=>{var x;return c(w,h,u,l,(x=e.userData)==null?void 0:x.style.fillRule)}),T=[];return h.forEach(w=>{if(!m[w.identifier].isHole){const E=new Os;E.curves=w.curves,m.filter(b=>b.isHole&&b.for===w.identifier).forEach(b=>{const R=h[b.identifier],P=new _t;P.curves=R.curves,E.holes.push(P)}),T.push(E)}}),T}static getStrokeStyle(e,t,n,s,i){return e=e!==void 0?e:1,t=t!==void 0?t:"#000",n=n!==void 0?n:"miter",s=s!==void 0?s:"butt",i=i!==void 0?i:4,{strokeColor:t,strokeWidth:e,strokeLineJoin:n,strokeLineCap:s,strokeMiterLimit:i}}static pointsToStroke(e,t,n,s){const i=[],r=[],a=[];if(pt.pointsToStrokeWithBuffers(e,t,n,s,i,r,a)===0)return null;const o=new Be;return o.setAttribute("position",new Le(i,3)),o.setAttribute("normal",new Le(r,3)),o.setAttribute("uv",new Le(a,2)),o}static pointsToStrokeWithBuffers(e,t,n,s,i,r,a,o){const c=new ne,u=new ne,l=new ne,h=new ne,m=new ne,T=new ne,w=new ne,x=new ne,E=new ne,k=new ne,b=new ne,R=new ne,P=new ne,O=new ne,v=new ne,A=new ne,C=new ne;n=n!==void 0?n:12,s=s!==void 0?s:.001,o=o!==void 0?o:0,e=X(e);const D=e.length;if(D<2)return 0;const H=e[0].equals(e[D-1]);let N,j=e[0],W;const se=t.strokeWidth/2,ee=1/(D-1);let q=0,V,ue,ce,Z,te=!1,oe=0,M=o*3,y=o*2;p(e[0],e[1],c).multiplyScalar(se),x.copy(e[0]).sub(c),E.copy(e[0]).add(c),k.copy(x),b.copy(E);for(let F=1;F<D;F++){N=e[F],F===D-1?H?W=e[1]:W=void 0:W=e[F+1];const B=c;if(p(j,N,B),l.copy(B).multiplyScalar(se),R.copy(N).sub(l),P.copy(N).add(l),V=q+ee,ue=!1,W!==void 0){p(N,W,u),l.copy(u).multiplyScalar(se),O.copy(N).sub(l),v.copy(N).add(l),ce=!0,l.subVectors(W,j),B.dot(l)<0&&(ce=!1),F===1&&(te=ce),l.subVectors(W,N),l.normalize();const K=Math.abs(B.dot(l));if(K>Number.EPSILON){const Y=se/K;l.multiplyScalar(-Y),h.subVectors(N,j),m.copy(h).setLength(Y).add(l),A.copy(m).negate();const L=m.length(),g=h.length();h.divideScalar(g),T.subVectors(W,N);const Q=T.length();switch(T.divideScalar(Q),h.dot(A)<g&&T.dot(A)<Q&&(ue=!0),C.copy(m).add(N),A.add(N),Z=!1,ue?ce?(v.copy(A),P.copy(A)):(O.copy(A),R.copy(A)):U(),t.strokeLineJoin){case"bevel":I(ce,ue,V);break;case"round":z(ce,ue),ce?_(N,R,O,V,0):_(N,v,P,V,1);break;case"miter":case"miter-clip":default:const re=se*t.strokeMiterLimit/L;if(re<1)if(t.strokeLineJoin!=="miter-clip"){I(ce,ue,V);break}else z(ce,ue),ce?(T.subVectors(C,R).multiplyScalar(re).add(R),w.subVectors(C,O).multiplyScalar(re).add(O),f(R,V,0),f(T,V,0),f(N,V,.5),f(N,V,.5),f(T,V,0),f(w,V,0),f(N,V,.5),f(w,V,0),f(O,V,0)):(T.subVectors(C,P).multiplyScalar(re).add(P),w.subVectors(C,v).multiplyScalar(re).add(v),f(P,V,1),f(T,V,1),f(N,V,.5),f(N,V,.5),f(T,V,1),f(w,V,1),f(N,V,.5),f(w,V,1),f(v,V,1));else ue?(ce?(f(E,q,1),f(x,q,0),f(C,V,0),f(E,q,1),f(C,V,0),f(A,V,1)):(f(E,q,1),f(x,q,0),f(C,V,1),f(x,q,0),f(A,V,0),f(C,V,1)),ce?O.copy(C):v.copy(C)):ce?(f(R,V,0),f(C,V,0),f(N,V,.5),f(N,V,.5),f(C,V,0),f(O,V,0)):(f(P,V,1),f(C,V,1),f(N,V,.5),f(N,V,.5),f(C,V,1),f(v,V,1)),Z=!0;break}}else U()}else U();!H&&F===D-1&&G(e[0],k,b,ce,!0,q),q=V,j=N,x.copy(O),E.copy(v)}if(!H)G(N,R,P,ce,!1,V);else if(ue&&i){let F=C,B=A;te!==ce&&(F=A,B=C),ce?(Z||te)&&(B.toArray(i,0*3),B.toArray(i,3*3),Z&&F.toArray(i,1*3)):(Z||!te)&&(B.toArray(i,1*3),B.toArray(i,3*3),Z&&F.toArray(i,0*3))}return oe;function p(F,B,K){return K.subVectors(B,F),K.set(-K.y,K.x).normalize()}function f(F,B,K){i&&(i[M]=F.x,i[M+1]=F.y,i[M+2]=0,r&&(r[M]=0,r[M+1]=0,r[M+2]=1),M+=3,a&&(a[y]=B,a[y+1]=K,y+=2)),oe+=3}function _(F,B,K,Y,L){c.copy(B).sub(F).normalize(),u.copy(K).sub(F).normalize();let g=Math.PI;const Q=c.dot(u);Math.abs(Q)<1&&(g=Math.abs(Math.acos(Q))),g/=n,l.copy(B);for(let re=0,we=n-1;re<we;re++)h.copy(l).rotateAround(F,g),f(l,Y,L),f(h,Y,L),f(F,Y,.5),l.copy(h);f(h,Y,L),f(K,Y,L),f(F,Y,.5)}function U(){f(E,q,1),f(x,q,0),f(R,V,0),f(E,q,1),f(R,V,1),f(P,V,0)}function I(F,B,K){B?F?(f(E,q,1),f(x,q,0),f(R,V,0),f(E,q,1),f(R,V,0),f(A,V,1),f(R,K,0),f(O,K,0),f(A,K,.5)):(f(E,q,1),f(x,q,0),f(P,V,1),f(x,q,0),f(A,V,0),f(P,V,1),f(P,K,1),f(v,K,0),f(A,K,.5)):F?(f(R,K,0),f(O,K,0),f(N,K,.5)):(f(P,K,1),f(v,K,0),f(N,K,.5))}function z(F,B){B&&(F?(f(E,q,1),f(x,q,0),f(R,V,0),f(E,q,1),f(R,V,0),f(A,V,1),f(R,q,0),f(N,V,.5),f(A,V,1),f(N,V,.5),f(O,q,0),f(A,V,1)):(f(E,q,1),f(x,q,0),f(P,V,1),f(x,q,0),f(A,V,0),f(P,V,1),f(P,q,1),f(A,V,0),f(N,V,.5),f(N,V,.5),f(A,V,0),f(v,q,1)))}function G(F,B,K,Y,L,g){switch(t.strokeLineCap){case"round":L?_(F,K,B,g,.5):_(F,B,K,g,.5);break;case"square":if(L)c.subVectors(B,F),u.set(c.y,-c.x),l.addVectors(c,u).add(F),h.subVectors(u,c).add(F),Y?(l.toArray(i,1*3),h.toArray(i,0*3),h.toArray(i,3*3)):(l.toArray(i,1*3),l.toArray(i,3*3),h.toArray(i,0*3));else{c.subVectors(K,F),u.set(c.y,-c.x),l.addVectors(c,u).add(F),h.subVectors(u,c).add(F);const Q=i.length;Y?(l.toArray(i,Q-1*3),h.toArray(i,Q-2*3),h.toArray(i,Q-4*3)):(l.toArray(i,Q-2*3),h.toArray(i,Q-1*3),h.toArray(i,Q-4*3))}break}}function X(F){let B=!1;for(let Y=1,L=F.length-1;Y<L;Y++)if(F[Y].distanceTo(F[Y+1])<s){B=!0;break}if(!B)return F;const K=[];K.push(F[0]);for(let Y=1,L=F.length-1;Y<L;Y++)F[Y].distanceTo(F[Y+1])>=s&&K.push(F[Y]);return K.push(F[F.length-1]),K}}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Pr{constructor(e,t){this.cache=e,this.textureAnisotropy=t}get fileLoader(){return this._fileLoader||(this._fileLoader=new xt),this._fileLoader}get imageLoader(){return this._imgLoader||(this._imgLoader=new _s),this._imgLoader}get svgLoader(){return this._svgLoader||(this._svgLoader=new pt),this._svgLoader}get textureLoader(){return this._textureLoader||(this._textureLoader=new Lt),this._textureLoader}get objectLoader(){return this._objectLoader||(this._objectLoader=new Ds),this._objectLoader}get gltfLoader(){return this._gltfLoader||(this._gltfLoader=new on),this._gltfLoader}get fbxLoader(){return this._fbxLoader||(this._fbxLoader=new Bi),this._fbxLoader}async preload(e,t){return this.cache.add(e,t),new Promise(n=>{const s=/\.fbx$|\.glb$|\.gltf$/.test(t);/\.jpe?g$|\.png$/.test(t)?this.textureLoader.load(t,r=>n(r)):(s&&this.fileLoader.setResponseType("arraybuffer"),this.fileLoader.load(t,r=>n(r)))})}async textureAtlas(e,t,n="JSONHash"){let s=JSON.parse(await this.file(t));if(s.textures){const a=s.textures[0].frames;let o={frames:{}};a.forEach(c=>{o={...o,frames:{...o.frames,[c.filename]:{frame:c.frame,rotated:c.rotated,sourceSize:c.sourceSize,spriteSourceSize:c.spriteSourceSize,trimmed:c.trimmed}}}}),s=o}return{texture:await this.texture(e),json:s}}file(e){const t=this.cache.get(e);return e=t||e,new Promise(n=>{this.fileLoader.load(e,s=>n(s))})}svg(e){const t=this.cache.get(e);return e=t||e,new Promise(n=>{this.svgLoader.load(e,s=>n(s))})}texture(e){if(!/^data:image\/[\S]+;base64,/gm.test(e)){const n=this.cache.get(e);e=n||e}return new Promise(n=>{this.textureLoader.load(e,s=>{s.anisotropy=this.textureAnisotropy,s.needsUpdate=!0,n(s)})})}object(e){const t=this.cache.get(e);return e=t||e,new Promise(n=>{this.objectLoader.load(e,s=>{n(s)})})}gltf(e){const t=this.cache.get(e);return e=t||e,new Promise(n=>{this.gltfLoader.load(e,s=>{n(s)})})}fbx(e){const t=this.cache.get(e);return e=t||e,new Promise(n=>{this.fbxLoader.load(e,s=>{n(s)})})}}class os{constructor(){this._defaultMaterial=new en({color:13421772})}get(){return this._defaultMaterial}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class as{constructor(e){this.scene=e,this.isHeadless=e==="headless",this.defaultMaterial=new os}get make(){return{plane:(e={},t={})=>this.makePlane(e,t),box:(e={},t={})=>this.makeBox(e,t),sphere:(e={},t={})=>this.makeSphere(e,t),cylinder:(e={},t={})=>this.makeCylinder(e,t),cone:(e={},t={})=>this.makeCone(e,t),torus:(e={},t={})=>this.makeTorus(e,t),extrude:(e,t={})=>this.makeExtrude(e,t)}}get add(){return{mesh:e=>this.addMesh(e),existing:e=>this.addExisting(e),plane:(e={},t={})=>this.addPlane(e,t),box:(e={},t={})=>this.addBox(e,t),ground:(e,t={})=>this.addGround(e,t),sphere:(e={},t={})=>this.addSphere(e,t),cylinder:(e={},t={})=>this.addCylinder(e,t),cone:(e={},t={})=>this.addCone(e,t),torus:(e={},t={})=>this.addTorus(e,t),extrude:(e,t={})=>this.addExtrude(e,t),material:(e={})=>this.addMaterial(e)}}addExisting(...e){this.scene!=="headless"&&this.scene.add(...e)}addMesh(e){if(Array.isArray(e))for(let t=0;t<e.length;t++)this.addExisting(e[t]);else this.addExisting(e);return this}createMesh(e,t,n){const{x:s=0,y:i=0,z:r=0}=n;let a;switch(!Array.isArray(t)&&t.type){case"LineBasicMaterial":a=new Rt(e,t);break;case"PointsMaterial":a=new Vn(e,t);break;default:a=new Xn(e,t);break}return a.position.set(s,i,r),a.castShadow=a.receiveShadow=!0,a}makeExtrude(e,t){const{x:n,y:s,z:i,name:r,shape:a,autoCenter:o=!0,breakable:c=!1,...u}=e,{depth:l=1,bevelEnabled:h=!1}=u,m=new Fs(a,{depth:l,bevelEnabled:h,...u}),T=this.addMaterial(t),w=this.createMesh(m,T,{x:n,y:s,z:i});return o&&w.geometry.center(),w.name=r||`body_id_${w.id}`,w.shape="extrude",w}addExtrude(e,t={}){const n=this.makeExtrude(e,t);return this.addExisting(n),n}makePlane(e,t){const{x:n,y:s,z:i,name:r,breakable:a=!1,...o}=e,c=new ft(o.width||1,o.height||1,o.widthSegments||1,o.heightSegments||1),u=this.addMaterial(t);u.side=nn;const l=this.createMesh(c,u,{x:n,y:s,z:i});return l.name=r||`body_id_${l.id}`,l.shape="plane",l}addPlane(e,t){const n=this.makePlane(e,t);return this.addExisting(n),n}makeSphere(e,t){const{x:n,y:s,z:i,name:r,breakable:a=!1,...o}=e,c=new sn(o.radius||1,o.widthSegments||16,o.heightSegments||12,o.phiStart||void 0,o.phiLength||void 0,o.thetaStart||void 0,o.thetaLength||void 0),u=this.addMaterial(t),l=this.createMesh(c,u,{x:n,y:s,z:i});return l.name=r||`body_id_${l.id}`,l.shape="sphere",l}addSphere(e={},t={}){const n=this.makeSphere(e,t);return this.addExisting(n),n}makeBox(e,t){const{x:n,y:s,z:i,name:r,breakable:a=!1,...o}=e,c=new Ns(o.width||1,o.height||1,o.depth||1,o.widthSegments||void 0,o.heightSegments||void 0,o.depthSegments||void 0),u=this.addMaterial(t),l=this.createMesh(c,u,{x:n,y:s,z:i});return l.name=r||`body_id_${l.id}`,l.shape="box",l}addBox(e={},t={}){const n=this.makeBox(e,t);return this.addExisting(n),n}addGround(e,t={}){const n=this.makeBox(e,t);return n.rotateX(Ee.degToRad(90)),this.addExisting(n),n}makeCylinder(e={},t={}){const{x:n,y:s,z:i,name:r,breakable:a=!1,...o}=e,c=new Vs(o.radiusTop||1,o.radiusBottom||1,o.height||1,o.radiusSegments||void 0,o.heightSegments||void 0,o.openEnded||void 0,o.thetaStart||void 0,o.thetaLength||void 0),u=this.addMaterial(t),l=this.createMesh(c,u,{x:n,y:s,z:i});return l.name=r||`body_id_${l.id}`,l.shape="cylinder",l}addCylinder(e={},t={}){const n=this.makeCylinder(e,t);return this.addExisting(n),n}makeCone(e={},t={}){const{x:n,y:s,z:i,name:r,breakable:a=!1,...o}=e,c=new Bs(o.radius||1,o.height||1,o.radiusSegments||8,o.heightSegments||1,o.openEnded||!1,o.thetaStart||0,o.thetaLength||2*Math.PI),u=this.addMaterial(t),l=this.createMesh(c,u,{x:n,y:s,z:i});return l.name=r||`body_id_${l.id}`,l.shape="cone",l}addCone(e={},t={}){const n=this.makeCone(e,t);return this.addExisting(n),n}makeTorus(e={},t={}){const{x:n,y:s,z:i,name:r,breakable:a=!1,...o}=e,c=new Us(o.radius||void 0,o.tube||void 0,o.radialSegments||void 0,o.tubularSegments||void 0,o.arc||void 0),u=this.addMaterial(t),l=this.createMesh(c,u,{x:n,y:s,z:i});return l.name=r||`body_id_${l.id}`,l.shape="torus",l}addTorus(e={},t={}){const n=this.makeTorus(e,t);return this.addExisting(n),n}addMaterial(e={}){const t=Object.keys(e)[0];let n;if(this.scene==="headless")return this.defaultMaterial.get();switch(t){case"basic":n=new Ve(e.basic);break;case"normal":n=new Hs(e.normal);break;case"standard":n=new Ct(e.standard);break;case"lambert":n=new en(e.lambert);break;case"phong":n=new lt(e.phong);break;case"physical":typeof e.physical<"u"?n=new Qe(e.physical):(Je("You need to pass parameters to the physical material. (Fallback to default material)"),n=this.defaultMaterial.get());break;case"toon":n=new zs(e.toon);break;case"line":n=new bt(e.line);break;case"points":n=new Fn(e.points);break;case"custom":n=e.custom||this.defaultMaterial.get();break;default:n=this.defaultMaterial.get();break}return n}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2022 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Lr{constructor(e){this.scene=e}add(e,t={}){const n=this.make(e,t);return n?this.scene.add(n):console.warn("Could not make heightmap"),n}make(e,t={}){const{image:n}=e,{width:s,height:i}=n,{colorScale:r,heightScale:a=100}=t,o=document.createElement("canvas");o.width=s,o.height=i;const c=o.getContext("2d");if(!c)return;c.drawImage(e.image,0,0);const u=c.getImageData(0,0,s,i),l=new ft(10,10,s-1,i-1);let h={color:13421772,side:nn};r&&(h={...h,vertexColors:!0});const m=new lt(h),T=new Xn(l,m);T.receiveShadow=T.castShadow=!0,T.shape="concave";const w=l.attributes.position.array;for(let x=0;x<w.length;x++){const E=u.data[x*4]/a;w[x*3+2]=E}if(r){const x=l.attributes.position.count;l.setAttribute("color",new ke(new Float32Array(x*3),3));const E=new de,k=l.attributes.position,b=l.attributes.color;let R,P;for(let O=0;O<x;O++)R=k.getZ(O),P=r(R).hsl(),E.setHSL(P[0]/360,P[1],P[2],P[3]),b.setXYZ(O,E.r,E.g,E.b)}return T.rotateX(-Math.PI/2),T.updateMatrix(),l.computeVertexNormals(),T.name="heightmap",T}}const An={type:"change"},jt={type:"start"},Mn={type:"end"};class Rr extends js{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new J,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:et.ROTATE,MIDDLE:et.DOLLY,RIGHT:et.PAN},this.touches={ONE:tt.ROTATE,TWO:tt.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(S){S.addEventListener("keydown",re),this._domElementKeyEvents=S},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(An),n.update(),i=s.NONE},this.update=function(){const S=new J,$=new Te().setFromUnitVectors(e.up,new J(0,1,0)),me=$.clone().invert(),xe=new J,ve=new Te,je=2*Math.PI;return function(){const an=n.object.position;S.copy(an).sub(n.target),S.applyQuaternion($),a.setFromVector3(S),n.autoRotate&&i===s.NONE&&C(v()),n.enableDamping?(a.theta+=o.theta*n.dampingFactor,a.phi+=o.phi*n.dampingFactor):(a.theta+=o.theta,a.phi+=o.phi);let De=n.minAzimuthAngle,Fe=n.maxAzimuthAngle;return isFinite(De)&&isFinite(Fe)&&(De<-Math.PI?De+=je:De>Math.PI&&(De-=je),Fe<-Math.PI?Fe+=je:Fe>Math.PI&&(Fe-=je),De<=Fe?a.theta=Math.max(De,Math.min(Fe,a.theta)):a.theta=a.theta>(De+Fe)/2?Math.max(De,a.theta):Math.min(Fe,a.theta)),a.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=c,a.radius=Math.max(n.minDistance,Math.min(n.maxDistance,a.radius)),n.enableDamping===!0?n.target.addScaledVector(u,n.dampingFactor):n.target.add(u),S.setFromSpherical(a),S.applyQuaternion(me),an.copy(n.target).add(S),n.object.lookAt(n.target),n.enableDamping===!0?(o.theta*=1-n.dampingFactor,o.phi*=1-n.dampingFactor,u.multiplyScalar(1-n.dampingFactor)):(o.set(0,0,0),u.set(0,0,0)),c=1,l||xe.distanceToSquared(n.object.position)>r||8*(1-ve.dot(n.object.quaternion))>r?(n.dispatchEvent(An),xe.copy(n.object.position),ve.copy(n.object.quaternion),l=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",ye),n.domElement.removeEventListener("pointerdown",F),n.domElement.removeEventListener("pointercancel",Y),n.domElement.removeEventListener("wheel",Q),n.domElement.removeEventListener("pointermove",B),n.domElement.removeEventListener("pointerup",K),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",re)};const n=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=s.NONE;const r=1e-6,a=new ln,o=new ln;let c=1;const u=new J;let l=!1;const h=new ne,m=new ne,T=new ne,w=new ne,x=new ne,E=new ne,k=new ne,b=new ne,R=new ne,P=[],O={};function v(){return 2*Math.PI/60/60*n.autoRotateSpeed}function A(){return Math.pow(.95,n.zoomSpeed)}function C(S){o.theta-=S}function D(S){o.phi-=S}const H=function(){const S=new J;return function(me,xe){S.setFromMatrixColumn(xe,0),S.multiplyScalar(-me),u.add(S)}}(),N=function(){const S=new J;return function(me,xe){n.screenSpacePanning===!0?S.setFromMatrixColumn(xe,1):(S.setFromMatrixColumn(xe,0),S.crossVectors(n.object.up,S)),S.multiplyScalar(me),u.add(S)}}(),j=function(){const S=new J;return function(me,xe){const ve=n.domElement;if(n.object.isPerspectiveCamera){const je=n.object.position;S.copy(je).sub(n.target);let vt=S.length();vt*=Math.tan(n.object.fov/2*Math.PI/180),H(2*me*vt/ve.clientHeight,n.object.matrix),N(2*xe*vt/ve.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(H(me*(n.object.right-n.object.left)/n.object.zoom/ve.clientWidth,n.object.matrix),N(xe*(n.object.top-n.object.bottom)/n.object.zoom/ve.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function W(S){n.object.isPerspectiveCamera?c/=S:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*S)),n.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function se(S){n.object.isPerspectiveCamera?c*=S:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/S)),n.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function ee(S){h.set(S.clientX,S.clientY)}function q(S){k.set(S.clientX,S.clientY)}function V(S){w.set(S.clientX,S.clientY)}function ue(S){m.set(S.clientX,S.clientY),T.subVectors(m,h).multiplyScalar(n.rotateSpeed);const $=n.domElement;C(2*Math.PI*T.x/$.clientHeight),D(2*Math.PI*T.y/$.clientHeight),h.copy(m),n.update()}function ce(S){b.set(S.clientX,S.clientY),R.subVectors(b,k),R.y>0?W(A()):R.y<0&&se(A()),k.copy(b),n.update()}function Z(S){x.set(S.clientX,S.clientY),E.subVectors(x,w).multiplyScalar(n.panSpeed),j(E.x,E.y),w.copy(x),n.update()}function te(S){S.deltaY<0?se(A()):S.deltaY>0&&W(A()),n.update()}function oe(S){let $=!1;switch(S.code){case n.keys.UP:S.ctrlKey||S.metaKey||S.shiftKey?D(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):j(0,n.keyPanSpeed),$=!0;break;case n.keys.BOTTOM:S.ctrlKey||S.metaKey||S.shiftKey?D(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):j(0,-n.keyPanSpeed),$=!0;break;case n.keys.LEFT:S.ctrlKey||S.metaKey||S.shiftKey?C(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):j(n.keyPanSpeed,0),$=!0;break;case n.keys.RIGHT:S.ctrlKey||S.metaKey||S.shiftKey?C(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):j(-n.keyPanSpeed,0),$=!0;break}$&&(S.preventDefault(),n.update())}function M(){if(P.length===1)h.set(P[0].pageX,P[0].pageY);else{const S=.5*(P[0].pageX+P[1].pageX),$=.5*(P[0].pageY+P[1].pageY);h.set(S,$)}}function y(){if(P.length===1)w.set(P[0].pageX,P[0].pageY);else{const S=.5*(P[0].pageX+P[1].pageX),$=.5*(P[0].pageY+P[1].pageY);w.set(S,$)}}function p(){const S=P[0].pageX-P[1].pageX,$=P[0].pageY-P[1].pageY,me=Math.sqrt(S*S+$*$);k.set(0,me)}function f(){n.enableZoom&&p(),n.enablePan&&y()}function _(){n.enableZoom&&p(),n.enableRotate&&M()}function U(S){if(P.length==1)m.set(S.pageX,S.pageY);else{const me=He(S),xe=.5*(S.pageX+me.x),ve=.5*(S.pageY+me.y);m.set(xe,ve)}T.subVectors(m,h).multiplyScalar(n.rotateSpeed);const $=n.domElement;C(2*Math.PI*T.x/$.clientHeight),D(2*Math.PI*T.y/$.clientHeight),h.copy(m)}function I(S){if(P.length===1)x.set(S.pageX,S.pageY);else{const $=He(S),me=.5*(S.pageX+$.x),xe=.5*(S.pageY+$.y);x.set(me,xe)}E.subVectors(x,w).multiplyScalar(n.panSpeed),j(E.x,E.y),w.copy(x)}function z(S){const $=He(S),me=S.pageX-$.x,xe=S.pageY-$.y,ve=Math.sqrt(me*me+xe*xe);b.set(0,ve),R.set(0,Math.pow(b.y/k.y,n.zoomSpeed)),W(R.y),k.copy(b)}function G(S){n.enableZoom&&z(S),n.enablePan&&I(S)}function X(S){n.enableZoom&&z(S),n.enableRotate&&U(S)}function F(S){n.enabled!==!1&&(P.length===0&&(n.domElement.setPointerCapture(S.pointerId),n.domElement.addEventListener("pointermove",B),n.domElement.addEventListener("pointerup",K)),Ce(S),S.pointerType==="touch"?we(S):L(S))}function B(S){n.enabled!==!1&&(S.pointerType==="touch"?Ae(S):g(S))}function K(S){Ze(S),P.length===0&&(n.domElement.releasePointerCapture(S.pointerId),n.domElement.removeEventListener("pointermove",B),n.domElement.removeEventListener("pointerup",K)),n.dispatchEvent(Mn),i=s.NONE}function Y(S){Ze(S)}function L(S){let $;switch(S.button){case 0:$=n.mouseButtons.LEFT;break;case 1:$=n.mouseButtons.MIDDLE;break;case 2:$=n.mouseButtons.RIGHT;break;default:$=-1}switch($){case et.DOLLY:if(n.enableZoom===!1)return;q(S),i=s.DOLLY;break;case et.ROTATE:if(S.ctrlKey||S.metaKey||S.shiftKey){if(n.enablePan===!1)return;V(S),i=s.PAN}else{if(n.enableRotate===!1)return;ee(S),i=s.ROTATE}break;case et.PAN:if(S.ctrlKey||S.metaKey||S.shiftKey){if(n.enableRotate===!1)return;ee(S),i=s.ROTATE}else{if(n.enablePan===!1)return;V(S),i=s.PAN}break;default:i=s.NONE}i!==s.NONE&&n.dispatchEvent(jt)}function g(S){switch(i){case s.ROTATE:if(n.enableRotate===!1)return;ue(S);break;case s.DOLLY:if(n.enableZoom===!1)return;ce(S);break;case s.PAN:if(n.enablePan===!1)return;Z(S);break}}function Q(S){n.enabled===!1||n.enableZoom===!1||i!==s.NONE||(S.preventDefault(),n.dispatchEvent(jt),te(S),n.dispatchEvent(Mn))}function re(S){n.enabled===!1||n.enablePan===!1||oe(S)}function we(S){switch(ot(S),P.length){case 1:switch(n.touches.ONE){case tt.ROTATE:if(n.enableRotate===!1)return;M(),i=s.TOUCH_ROTATE;break;case tt.PAN:if(n.enablePan===!1)return;y(),i=s.TOUCH_PAN;break;default:i=s.NONE}break;case 2:switch(n.touches.TWO){case tt.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;f(),i=s.TOUCH_DOLLY_PAN;break;case tt.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;_(),i=s.TOUCH_DOLLY_ROTATE;break;default:i=s.NONE}break;default:i=s.NONE}i!==s.NONE&&n.dispatchEvent(jt)}function Ae(S){switch(ot(S),i){case s.TOUCH_ROTATE:if(n.enableRotate===!1)return;U(S),n.update();break;case s.TOUCH_PAN:if(n.enablePan===!1)return;I(S),n.update();break;case s.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;G(S),n.update();break;case s.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;X(S),n.update();break;default:i=s.NONE}}function ye(S){n.enabled!==!1&&S.preventDefault()}function Ce(S){P.push(S)}function Ze(S){delete O[S.pointerId];for(let $=0;$<P.length;$++)if(P[$].pointerId==S.pointerId){P.splice($,1);return}}function ot(S){let $=O[S.pointerId];$===void 0&&($=new ne,O[S.pointerId]=$),$.set(S.pageX,S.pageY)}function He(S){const $=S.pointerId===P[0].pointerId?P[1]:P[0];return O[$.pointerId]}n.domElement.addEventListener("contextmenu",ye),n.domElement.addEventListener("pointerdown",F),n.domElement.addEventListener("pointercancel",Y),n.domElement.addEventListener("wheel",Q,{passive:!1}),this.update()}}class Cr{constructor(e,t,n,s,i,r,a){this.scene=e,this.renderer=t,this.camera=n,this.lights=s,this.physics=i,this.load=r,this.factories=a}async warpSpeed(...e){let t={};const n=e.filter(o=>/^-\w+/.test(o)),s=n.length>0;if((e.length===0||s)&&(e=["light","camera","lookAtCenter","ground","grid","orbitControls","fog","sky"]),s&&n.map(c=>c.substr(1)).forEach(c=>{const u=e.indexOf(c);e.splice(u,1)}),e.includes("sky")){const o=["varying vec3 vWorldPosition;","","void main() {","","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","vWorldPosition = worldPosition.xyz;","","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","","}"].join(`
`),c=["uniform vec3 topColor;","uniform vec3 bottomColor;","uniform float offset;","uniform float exponent;","","varying vec3 vWorldPosition;","","void main() {","","float h = normalize( vWorldPosition + offset ).y;","gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );","","}"].join(`
`),u={topColor:{value:new de(30719)},bottomColor:{value:new de(15595007)},offset:{value:33},exponent:{value:.6}};var i=new sn(500,32,15),r=new It({uniforms:u,vertexShader:o,fragmentShader:c,side:Gs}),a=new Re(i,r);this.scene.add(a)}if(e.includes("camera")&&(this.camera.position.set(0,6,12),t={camera:this.camera,...t}),e.includes("light")){const c=this.lights.hemisphereLight({skyColor:16777215,groundColor:0,intensity:.4}),u=this.lights.ambientLight({color:16777215,intensity:.4}),l=this.lights.directionalLight({color:16777215,intensity:.4});l.position.set(100,200,50);const h=20;l.shadow.camera.top=h,l.shadow.camera.bottom=-h,l.shadow.camera.left=-h,l.shadow.camera.right=h,l.shadow.mapSize.set(1024,1024),t={lights:{ambientLight:u,directionalLight:l,hemisphereLight:c},...t}}if(e.includes("lookAtCenter")&&this.camera.lookAt(this.scene.position),e.includes("ground")){const o=e.includes("grid"),c="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC",u=await this.load.texture(c);u.wrapS=u.wrapT=ze,u.repeat.set(21,21);const l={name:"ground",width:21,height:21,depth:1,y:-.5},h={phong:{map:o?u:null,color:16777215}};let m;window.__loadPhysics?(m=this.physics.add.ground(l,h),m.body.setRestitution(1)):m=this.factories.add.ground(l,h),m.receiveShadow=!0,t={ground:m,...t}}return e.includes("orbitControls")&&(t={orbitControls:new Rr(this.camera,document.getElementById("enable3d-phaser-canvas")||this.renderer.domElement),...t}),t}}class Ir{constructor(){this._mixers=[]}animationMixer(e){const t=new Ws(e);return this.mixers.add(t),t}get mixers(){return{create:e=>this.animationMixer(e),add:e=>this._mixers.push(e),get:()=>this._mixers,update:e=>{var t;return(t=this._mixers)==null?void 0:t.forEach(n=>n.update(e/1e3))}}}}class mt extends Re{constructor(e,t={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new wt;const n=this,s=t.color!==void 0?new de(t.color):new de(8355711),i=t.textureWidth||512,r=t.textureHeight||512,a=t.clipBias||0,o=t.shader||mt.ReflectorShader,c=t.multisample!==void 0?t.multisample:4,u=new qt,l=new J,h=new J,m=new J,T=new ae,w=new J(0,0,-1),x=new Ue,E=new J,k=new J,b=new Ue,R=new ae,P=this.camera,O=new zn(i,r,{samples:c,type:Hn}),v=new It({uniforms:rn.clone(o.uniforms),fragmentShader:o.fragmentShader,vertexShader:o.vertexShader});v.uniforms.tDiffuse.value=O.texture,v.uniforms.color.value=s,v.uniforms.textureMatrix.value=R,this.material=v,this.onBeforeRender=function(A,C,D){if(h.setFromMatrixPosition(n.matrixWorld),m.setFromMatrixPosition(D.matrixWorld),T.extractRotation(n.matrixWorld),l.set(0,0,1),l.applyMatrix4(T),E.subVectors(h,m),E.dot(l)>0)return;E.reflect(l).negate(),E.add(h),T.extractRotation(D.matrixWorld),w.set(0,0,-1),w.applyMatrix4(T),w.add(m),k.subVectors(h,w),k.reflect(l).negate(),k.add(h),P.position.copy(E),P.up.set(0,1,0),P.up.applyMatrix4(T),P.up.reflect(l),P.lookAt(k),P.far=D.far,P.updateMatrixWorld(),P.projectionMatrix.copy(D.projectionMatrix),R.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),R.multiply(P.projectionMatrix),R.multiply(P.matrixWorldInverse),R.multiply(n.matrixWorld),u.setFromNormalAndCoplanarPoint(l,h),u.applyMatrix4(P.matrixWorldInverse),x.set(u.normal.x,u.normal.y,u.normal.z,u.constant);const H=P.projectionMatrix;b.x=(Math.sign(x.x)+H.elements[8])/H.elements[0],b.y=(Math.sign(x.y)+H.elements[9])/H.elements[5],b.z=-1,b.w=(1+H.elements[10])/H.elements[14],x.multiplyScalar(2/x.dot(b)),H.elements[2]=x.x,H.elements[6]=x.y,H.elements[10]=x.z+1-a,H.elements[14]=x.w,n.visible=!1;const N=A.getRenderTarget(),j=A.xr.enabled,W=A.shadowMap.autoUpdate,se=A.outputEncoding,ee=A.toneMapping;A.xr.enabled=!1,A.shadowMap.autoUpdate=!1,A.outputEncoding=jn,A.toneMapping=Gn,A.setRenderTarget(O),A.state.buffers.depth.setMask(!0),A.autoClear===!1&&A.clear(),A.render(C,P),A.xr.enabled=j,A.shadowMap.autoUpdate=W,A.outputEncoding=se,A.toneMapping=ee,A.setRenderTarget(N);const q=D.viewport;q!==void 0&&A.state.viewport(q),n.visible=!0},this.getRenderTarget=function(){return O},this.dispose=function(){O.dispose(),n.material.dispose()}}}mt.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,fragmentShader:`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`};class gt extends Re{constructor(e,t={}){super(e),this.isRefractor=!0,this.type="Refractor",this.camera=new wt;const n=this,s=t.color!==void 0?new de(t.color):new de(8355711),i=t.textureWidth||512,r=t.textureHeight||512,a=t.clipBias||0,o=t.shader||gt.RefractorShader,c=t.multisample!==void 0?t.multisample:4,u=this.camera;u.matrixAutoUpdate=!1,u.userData.refractor=!0;const l=new qt,h=new ae,m=new zn(i,r,{samples:c,type:Hn});this.material=new It({uniforms:rn.clone(o.uniforms),vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,transparent:!0}),this.material.uniforms.color.value=s,this.material.uniforms.tDiffuse.value=m.texture,this.material.uniforms.textureMatrix.value=h;const T=function(){const b=new J,R=new J,P=new ae,O=new J,v=new J;return function(C){return b.setFromMatrixPosition(n.matrixWorld),R.setFromMatrixPosition(C.matrixWorld),O.subVectors(b,R),P.extractRotation(n.matrixWorld),v.set(0,0,1),v.applyMatrix4(P),O.dot(v)<0}}(),w=function(){const b=new J,R=new J,P=new Te,O=new J;return function(){n.matrixWorld.decompose(R,P,O),b.set(0,0,1).applyQuaternion(P).normalize(),b.negate(),l.setFromNormalAndCoplanarPoint(b,R)}}(),x=function(){const b=new qt,R=new Ue,P=new Ue;return function(v){u.matrixWorld.copy(v.matrixWorld),u.matrixWorldInverse.copy(u.matrixWorld).invert(),u.projectionMatrix.copy(v.projectionMatrix),u.far=v.far,b.copy(l),b.applyMatrix4(u.matrixWorldInverse),R.set(b.normal.x,b.normal.y,b.normal.z,b.constant);const A=u.projectionMatrix;P.x=(Math.sign(R.x)+A.elements[8])/A.elements[0],P.y=(Math.sign(R.y)+A.elements[9])/A.elements[5],P.z=-1,P.w=(1+A.elements[10])/A.elements[14],R.multiplyScalar(2/R.dot(P)),A.elements[2]=R.x,A.elements[6]=R.y,A.elements[10]=R.z+1-a,A.elements[14]=R.w}}();function E(b){h.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),h.multiply(b.projectionMatrix),h.multiply(b.matrixWorldInverse),h.multiply(n.matrixWorld)}function k(b,R,P){n.visible=!1;const O=b.getRenderTarget(),v=b.xr.enabled,A=b.shadowMap.autoUpdate,C=b.outputEncoding,D=b.toneMapping;b.xr.enabled=!1,b.shadowMap.autoUpdate=!1,b.outputEncoding=jn,b.toneMapping=Gn,b.setRenderTarget(m),b.autoClear===!1&&b.clear(),b.render(R,u),b.xr.enabled=v,b.shadowMap.autoUpdate=A,b.outputEncoding=C,b.toneMapping=D,b.setRenderTarget(O);const H=P.viewport;H!==void 0&&b.state.viewport(H),n.visible=!0}this.onBeforeRender=function(b,R,P){P.userData.refractor!==!0&&(!T(P)||(w(),E(P),x(P),k(b,R,P)))},this.getRenderTarget=function(){return m},this.dispose=function(){m.dispose(),n.material.dispose()}}}gt.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`};class kt extends Re{constructor(e,t={}){super(e),this.isWater=!0,this.type="Water";const n=this,s=t.color!==void 0?new de(t.color):new de(16777215),i=t.textureWidth||512,r=t.textureHeight||512,a=t.clipBias||0,o=t.flowDirection||new ne(1,0),c=t.flowSpeed||.03,u=t.reflectivity||.02,l=t.scale||1,h=t.shader||kt.WaterShader,m=new Lt,T=t.flowMap||void 0,w=t.normalMap0||m.load("textures/water/Water_1_M_Normal.jpg"),x=t.normalMap1||m.load("textures/water/Water_2_M_Normal.jpg"),E=.15,k=E*.5,b=new ae,R=new Wn;if(mt===void 0){console.error("THREE.Water: Required component Reflector not found.");return}if(gt===void 0){console.error("THREE.Water: Required component Refractor not found.");return}const P=new mt(e,{textureWidth:i,textureHeight:r,clipBias:a}),O=new gt(e,{textureWidth:i,textureHeight:r,clipBias:a});P.matrixAutoUpdate=!1,O.matrixAutoUpdate=!1,this.material=new It({uniforms:rn.merge([Xs.fog,h.uniforms]),vertexShader:h.vertexShader,fragmentShader:h.fragmentShader,transparent:!0,fog:!0}),T!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:T}):this.material.uniforms.flowDirection={type:"v2",value:o},w.wrapS=w.wrapT=ze,x.wrapS=x.wrapT=ze,this.material.uniforms.tReflectionMap.value=P.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=O.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=w,this.material.uniforms.tNormalMap1.value=x,this.material.uniforms.color.value=s,this.material.uniforms.reflectivity.value=u,this.material.uniforms.textureMatrix.value=b,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=k,this.material.uniforms.config.value.z=k,this.material.uniforms.config.value.w=l;function v(C){b.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),b.multiply(C.projectionMatrix),b.multiply(C.matrixWorldInverse),b.multiply(n.matrixWorld)}function A(){const C=R.getDelta(),D=n.material.uniforms.config;D.value.x+=c*C,D.value.y=D.value.x+k,D.value.x>=E?(D.value.x=0,D.value.y=k):D.value.y>=E&&(D.value.y=D.value.y-E)}this.onBeforeRender=function(C,D,H){v(H),A(),n.visible=!1,P.matrixWorld.copy(n.matrixWorld),O.matrixWorld.copy(n.matrixWorld),P.onBeforeRender(C,D,H),O.onBeforeRender(C,D,H),n.visible=!0}}}kt.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new Ue}},vertexShader:`

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`,fragmentShader:`

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>

		}`};const kr=(d,e,t={})=>{const{width:n=20,height:s=20,x:i=0,y:r=0,z:a=0,color:o="#ffffff",scale:c=4,flowX:u=1,flowY:l=1,normalMap0:h=void 0,normalMap1:m=void 0}=t,T=new ft(n,s),w=new Ct({color:30654,transparent:!0,opacity:.8}),x=new Re(T,w);x.position.set(i,r,a),x.rotation.x=Math.PI*-.5,d.add(x);const E=new ft(n,s),k=new kt(E,{color:o,scale:c,flowDirection:new ne(u,l),textureWidth:1024,textureHeight:1024,normalMap0:h,normalMap1:m,encoding:e.outputEncoding});return k.position.set(i,r+.1,a),k.rotation.x=Math.PI*-.5,d.add(k),{ground:x,water:k}};class Or{constructor(e,t,n){this.scene=e,this.renderer=t,this.factories=n}water(e={}){kr(this.scene,this.renderer,e)}textureCube(e){e.length!==6&&Je("You need to pass 6 urls to textureCube()");const t=new _r;return e.forEach((n,s)=>{n.wrapS=n.wrapT=ze;const i=this.factories.add.material({phong:{map:n}});t.materials[s]=i}),t}}class _r{constructor(){this.materials=new Array(6)}get texture(){return{left:this.getTexture(0),right:this.getTexture(1),up:this.getTexture(2),down:this.getTexture(3),front:this.getTexture(4),back:this.getTexture(5)}}getTexture(e){return this.materials[e].map}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Dr{constructor(e,t){this.camera=e,this.renderer=t}fromSVGtoShape(e){if(e){const t=new pt,n=[];return t.parse(e).paths.forEach(s=>{pt.createShapes(s).forEach(i=>{n.push(i)})}),n}return[]}from3dto2d(e){const t=new J(e.x,e.y,e.z),n=this.renderer.domElement;this.camera.updateMatrixWorld(),t.project(this.camera);const s=Math.round((t.x+1)*(n.width/2)),i=Math.round((-t.y+1)*(n.height/2));return new ne(s,i)}from2dto3d(e,t,n){var a;if(!this.tmpPlane){const o=new ft(1e4,1e4),c=new Ve({transparent:!0,opacity:.25});this.tmpPlane=new Re(o,c),this.tmpPlane.name="_tmp_raycast_plane"}this.tmpRaycaster||(this.tmpRaycaster=new Ks),this.tmpVector3||(this.tmpVector3=new J);let s;this.tmpPlane.setRotationFromEuler(this.camera.rotation);const i=this.camera.position;this.tmpPlane.position.set(i.x,i.y,i.z),this.camera.getWorldDirection(this.tmpVector3),this.tmpPlane.position.add(this.tmpVector3.clone().multiplyScalar(n)),this.tmpPlane.updateMatrix(),this.tmpPlane.updateMatrixWorld(!0),this.tmpRaycaster.setFromCamera({x:e,y:t},this.camera);const r=this.tmpRaycaster.intersectObjects([this.tmpPlane]);return((a=r[0])==null?void 0:a.object.name)==="_tmp_raycast_plane"&&(s=r[0].point),s}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Fr{constructor(e,t){this.physics=e,this.ammo=t,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.impact=[],this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new Oe,this.tmpQuaternion=new Te,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new Et,this.name=t.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){typeof this.eventEmitter>"u"&&(this.eventEmitter=new Et)}get needUpdate(){return this._needUpdate}set needUpdate(e){!e&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=e}onUpdateEvent(e,t=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,t?this.eventEmitter.once("update",()=>{e()}):this.eventEmitter.on("update",()=>{e()})}get on(){return{update:e=>this.onUpdateEvent(e),collision:e=>this.onCollision(e)}}get once(){return{update:e=>this.onUpdateEvent(e,!0)}}onCollision(e){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",t=>{const{bodies:n,event:s}=t;n[0].name===this.name?e(n[1],s):n[1].name===this.name&&e(n[0],s)})}transform(){const e=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(e)}refresh(){const e=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(e)}setRotation(e,t,n){const s=this.tmpEuler.set(e,t,n),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(s),this.tmpBtQuaternion.setValue(0,0,0,1);const r=this.tmpBtQuaternion;r.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(r)}get rotation(){let e,t,n;const i=this.physics.worldTransform.getRotation();let r=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());r.w>1&&(r=r.normalize());const a=2*Math.acos(r.w),o=Math.sqrt(1-r.w*r.w);return o<.001?(e=r.x,t=r.y,n=r.z):(e=r.x/o,t=r.y/o,n=r.z/o),{x:e*a,y:t*a,z:n*a}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(e,t,n){this.physics.worldTransform.getOrigin().setValue(e,t,n)}get position(){const e=this.physics.worldTransform;return{x:e.getOrigin().x(),y:e.getOrigin().y(),z:e.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(e){this.tmpBtVector3.setValue(e,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(e){this.tmpBtVector3.setValue(this.velocity.x,e,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(e){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,e),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(e){this.tmpBtVector3.setValue(e,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(e){this.tmpBtVector3.setValue(this.angularVelocity.x,e,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(e){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,e),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(e){this.tmpBtVector3.setValue(e,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(e){this.tmpBtVector3.setValue(0,e,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(e){this.tmpBtVector3.setValue(0,0,e),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(e,t){this.tmpBtVector3.setValue(e.x||0,e.y||0,e.z||0),this.tmpBtVector3_1.setValue(t.x||0,t.y||0,t.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(e){this.ammo.setCollisionFlags(e)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(e){this.ammo.setRestitution(e)}setBounciness(e){this.setRestitution(e)}setFriction(e){this.ammo.setFriction(e)}setDamping(e,t){this.ammo.setDamping(e,t)}setGravity(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(e,t,n){this.tmpBtVector3.setValue(e,t,n),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(e){this.ammo.setCcdMotionThreshold(e)}setCcdSweptSphereRadius(e){this.ammo.setCcdSweptSphereRadius(e)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Nr{constructor(e,t){this.factory=e,this.addExisting=t}addPlane(e={},t={}){const n=this.factory.add.plane(e,t);return this.addExisting(n,e),n}addSphere(e={},t={}){const n=this.factory.add.sphere(e,t);return this.addExisting(n,e),n}addBox(e={},t={}){const n=this.factory.add.box(e,t);return this.addExisting(n,e),n}addGround(e,t={}){const n=this.factory.add.ground(e,t),s={...e,mass:0,collisionFlags:1};return this.addExisting(n,s),n}addCylinder(e={},t={}){const n=this.factory.add.cylinder(e,t);return this.addExisting(n,e),n}addCone(e={},t={}){const n=this.factory.add.cone(e,t);return this.addExisting(n,e),n}addTorus(e={},t={}){const n=this.factory.add.torus(e,t);return this.addExisting(n,e),n}addExtrude(e,t={}){const n=this.factory.add.extrude(e,t);return n.translateX(1),this.addExisting(n),n}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Vr{constructor(e,t){this.worldTransform=e,this.physicsWorld=t,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(e,t=0){return new Ammo.btVector3(typeof(e==null?void 0:e.x)<"u"?e.x:t,typeof(e==null?void 0:e.y)<"u"?e.y:t,typeof(e==null?void 0:e.z)<"u"?e.z:t)}get addConstraints(){return{lock:(e,t,n)=>this.lock(e,t,n),fixed:(e,t,n)=>this.fixed(e,t,n),pointToPoint:(e,t,n,s)=>this.pointToPoint(e,t,n,s),hinge:(e,t,n,s)=>this.hinge(e,t,n,s),slider:(e,t,n={},s)=>this.slider(e,t,n,s),spring:(e,t,n={},s)=>this.spring(e,t,n,s),coneTwist:(e,t,n={frameA:{},frameB:{}},s)=>this.coneTwist(e,t,n,s),dof:(e,t,n,s)=>this.dof(e,t,n,s)}}getTransform(e,t,n={x:0,y:0,z:0},s=!1){n={x:0,y:0,z:0,...n};const i=(a,o)=>{var c=(a.x()-o.x())/2+n.x,u=(a.y()-o.y())/2+n.y,l=(a.z()-o.z())/2+n.z;return new Ammo.btVector3(c,u,l)},r=new Ammo.btTransform;if(r.setIdentity(),s){const a=i(e.getWorldTransform().getOrigin(),t.getWorldTransform().getOrigin()),o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(a);const c=e.getCenterOfMassTransform().inverse().op_mul(t.getWorldTransform());return c.op_mul(o),{transformA:c,transformB:o}}else return r.setOrigin(new Ammo.btVector3(n.x,n.y,n.z)),{transformA:e.getCenterOfMassTransform().inverse().op_mul(t.getWorldTransform()).op_mul(r),transformB:r}}lock(e,t,n=!0){const s={x:0,y:0,z:0};return this.dof(e,t,{angularLowerLimit:s,angularUpperLimit:s},n)}fixed(e,t,n=!0){const s=this.getTransform(e.ammo,t.ammo);s.transformA.setRotation(e.ammo.getWorldTransform().getRotation()),s.transformB.setRotation(t.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(e.ammo,t.ammo,s.transformA,s.transformB);return this.physicsWorld.addConstraint(i,n),i}pointToPoint(e,t,n={},s=!0){const{pivotA:i,pivotB:r}=n,a=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),o=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),c=new Ammo.btPoint2PointConstraint(e.ammo,t.ammo,a,o);return this.physicsWorld.addConstraint(c,s),c}hinge(e,t,n={},s=!0){const{pivotA:i,pivotB:r,axisA:a,axisB:o}=n,c=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),u=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),l=new Ammo.btVector3((a==null?void 0:a.x)||0,(a==null?void 0:a.y)||0,(a==null?void 0:a.z)||0),h=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),m=new Ammo.btHingeConstraint(e.ammo,t.ammo,c,u,l,h,!0);return this.physicsWorld.addConstraint(m,s),m}slider(e,t,n={},s=!0){const i=this.getTransform(e.ammo,t.ammo),{frameA:r={},frameB:a={},linearLowerLimit:o=0,linearUpperLimit:c=0,angularLowerLimit:u=0,angularUpperLimit:l=0}=n,h=i.transformA.getRotation();h.setEulerZYX(r.x||0,r.y||0,r.z||0),i.transformA.setRotation(h);const m=i.transformB.getRotation();m.setEulerZYX(a.x||0,a.y||0,a.z||0),i.transformB.setRotation(m);const T=new Ammo.btSliderConstraint(e.ammo,t.ammo,i.transformA,i.transformB,!0);return T.setLowerLinLimit(o),T.setUpperLinLimit(c),T.setLowerAngLimit(u),T.setUpperAngLimit(l),this.physicsWorld.addConstraint(T,s),T}spring(e,t,n={},s=!0){const{stiffness:i=50,damping:r=.01,angularLock:a=!1,linearLowerLimit:o={},linearUpperLimit:c={},angularLowerLimit:u={},angularUpperLimit:l={},offset:h={},center:m=!1,enableSpring:T=!0}=n,w={x:0,y:0,z:0,...h},x=this.getTransform(e.ammo,t.ammo,w,m),E=new Ammo.btGeneric6DofSpringConstraint(e.ammo,t.ammo,x.transformA,x.transformB,!0);this.tmpBtVector3.setValue(o.x||0,o.y||0,o.z||0),E.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(c.x||0,c.y||0,c.z||0),E.setLinearUpperLimit(this.tmpBtVector3),a?(this.tmpBtVector3.setValue(0,0,0),E.setAngularLowerLimit(this.tmpBtVector3),E.setAngularUpperLimit(this.tmpBtVector3)):(console.log(u,l),E.setAngularLowerLimit(this.toAmmoV3(u,-Math.PI)),E.setAngularUpperLimit(this.toAmmoV3(l,Math.PI)));for(let k=0;k<3;k++)E.enableSpring(k,T),E.setStiffness(k,i),E.setDamping(k,r);return this.physicsWorld.addConstraint(E,s),E}coneTwist(e,t,n,s=!0){const{frameA:i,frameB:r}=n,a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0);const o=new Ammo.btTransform;o.setIdentity(),o.getOrigin().setValue((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),this.getTransform(e.ammo,t.ammo);const c=new Ammo.btConeTwistConstraint(t.ammo,e.ammo,a,o);return c.setAngularOnly(!0),this.physicsWorld.addConstraint(c,s),c}dof(e,t,n={},s=!0){const{offset:i,center:r=!1}=n,a={x:0,y:0,z:0,...i},o=this.getTransform(e.ammo,t.ammo,a,r),c=new Ammo.btGeneric6DofConstraint(e.ammo,t.ammo,o.transformA,o.transformB,!0),{linearLowerLimit:u,linearUpperLimit:l,angularLowerLimit:h,angularUpperLimit:m}=n,T=this.toAmmoV3(u),w=this.toAmmoV3(l),x=this.toAmmoV3(h,-Math.PI),E=this.toAmmoV3(m,Math.PI);return c.setLinearLowerLimit(T),c.setLinearUpperLimit(w),c.setAngularLowerLimit(x),c.setAngularUpperLimit(E),Ammo.destroy(T),Ammo.destroy(w),Ammo.destroy(x),Ammo.destroy(E),this.physicsWorld.addConstraint(c,s),c}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */const Br=(d,e)=>{const{radius:t=1,tube:n=.4,tubularSegments:s=8}=d,i=Math.PI,r=s,a=Math.sqrt(2*n*n-2*n*n*Math.cos(2*i/r)),o=new Ammo.btVector3(n,i/r+.5*a,n),c=new Ammo.btCylinderShape(o);c.setMargin(.05);const u=new Ammo.btCompoundShape,l=new Ammo.btVector3(0,0,1),h=new Ammo.btVector3(0,t,0),m=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let T=0;T<r;T++){const w=T*2*i/r,x=h.rotate(l,w),E=new Ammo.btTransform;m.setRotation(l,w+Math.PI/2),E.setIdentity(),E.setOrigin(x),E.setRotation(m),u.addChildShape(E,c)}return u};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Ur extends Et{addCollider(e,t,n){!e.body||!t.body||(e.body.checkCollisions=!0,t.body.checkCollisions=!0,this.on("collision",s=>{var a,o;const{bodies:i,event:r}=s;((a=i[0])==null?void 0:a.name)&&((o=i[1])==null?void 0:o.name)&&(e==null?void 0:e.name)&&(t==null?void 0:t.name)&&(i[0].name===e.name&&i[1].name===t.name||i[1].name===e.name&&i[0].name===t.name)&&n(r)}))}}const En={NoDebug:0,DrawWireframe:1,DrawAabb:2,DrawFeaturesText:4,DrawContactPoints:8,NoDeactivation:16,NoHelpText:32,DrawText:64,ProfileTimings:128,EnableSatComparison:256,DisableBulletLCP:512,EnableCCD:1024,DrawConstraints:1<<11,DrawConstraintLimits:1<<12,FastWireframe:1<<13,DrawNormals:1<<14,DrawOnTop:1<<15,MAX_DEBUG_DRAW_MODE:4294967295};class zr{constructor(e,t,n={}){this.scene=e,this.world=t,this.options=n,this.debugDrawMode=n.debugDrawMode||En.DrawWireframe;const s=this.debugDrawMode&En.DrawOnTop||!1,i=n.maxBufferSize||1e6;this.geometry=new Be;const r=new Float32Array(i*3),a=new Float32Array(i*3);this.geometry.setAttribute("position",new ke(r,3).setUsage(un)),this.geometry.setAttribute("color",new ke(a,3).setUsage(un)),this.index=0;const o=new bt({vertexColors:!0,depthTest:!s});this.mesh=new Nn(this.geometry,o),s&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){!this.enabled||(this.index!=0&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(e,t,n){const s=Ammo.HEAPF32,i=s[(n+0)/4],r=s[(n+4)/4],a=s[(n+8)/4],o=s[(e+0)/4],c=s[(e+4)/4],u=s[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,o,c,u),this.geometry.attributes.color.setXYZ(this.index++,i,r,a);const l=s[(t+0)/4],h=s[(t+4)/4],m=s[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,h,m),this.geometry.attributes.color.setXYZ(this.index++,i,r,a)}drawContactPoint(e,t,n,s,i){const r=Ammo.HEAPF32,a=r[(i+0)/4],o=r[(i+4)/4],c=r[(i+8)/4],u=r[(e+0)/4],l=r[(e+4)/4],h=r[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,u,l,h),this.geometry.attributes.color.setXYZ(this.index++,a,o,c);const m=r[(t+0)/4]*n,T=r[(t+4)/4]*n,w=r[(t+8)/4]*n;this.geometry.attributes.position.setXYZ(this.index,u+m,l+T,h+w),this.geometry.attributes.color.setXYZ(this.index++,a,o,c)}reportErrorWarning(e){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(e)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(e,t){console.warn("TODO: draw3dText")}setDebugMode(e){this.debugDrawMode=e}getDebugMode(){return this.debugDrawMode}}const Hr=(d,e)=>{typeof window<"u"&&(window.__loadPhysics=!0),ei(d,()=>{Ammo().then(()=>{e()})})};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class jr extends Et{constructor(e,t={}){super(),this.scene=e,this.config=t,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=t.gravity||{x:0,y:-9.81,z:0},this.isHeadless=e==="headless",this.tmpEuler=new Oe,this.tmpQuaternion=new Te,this.tmpVector3=new J,this.tmpVector3a=new J,this.tmpMatrix4=new ae,this.tmpMatrix4a=new ae,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new J,this.impactPoint=new J,this.impactNormal=new J,e!=="headless"&&(this.defaultMaterial=new os),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(e){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=e}destroy(e){var i;const t=Object.keys(e).includes("body")?e.body:e;if(typeof(t==null?void 0:t.ammo)>"u")return;let n=t.ammo.threeObject;const s=n.name;if(s&&n&&(i=n==null?void 0:n.body)!=null&&i.ammo){n.body.isSoftBody?this.physicsWorld.removeSoftBody(n.body.ammo):this.physicsWorld.removeRigidBody(n.body.ammo),n.body.destructor(),n.body=void 0,n.hasBody=!1,delete t.ammo.threeObject;for(let r=0;r<this.rigidBodies.length;r++)this.rigidBodies[r].name===s&&(this.rigidBodies.splice(r,1),r--)}this.scene==="headless"&&n&&(n=null)}setup(){if(this.worldTransform=new Ammo.btTransform,typeof this.config.setupPhysicsWorld=="function"?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),this.scene!=="headless"){this.convexBreaker=new ti,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let e=0;e<500;e++)this.objectsToRemove[e]=null}this.collisionEvents=new Ur,this.factory=new as(this.scene),this.shapes=new Nr(this.factory,(e,t)=>this.addExisting(e,t)),this.constraints=new Vr(this.worldTransform,this.physicsWorld),this.scene!=="headless"&&(this.debugDrawer=new zr(this.scene,this.physicsWorld,{}))}updateDebugger(){this.scene!=="headless"&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const e=this.gravity,{softBodies:t=!1}=this.config;let n;if(!t){const s=new Ammo.btDefaultCollisionConfiguration,i=new Ammo.btCollisionDispatcher(s),r=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver;n=new Ammo.btDiscreteDynamicsWorld(i,r,a,s)}if(t){const s=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,i=new Ammo.btCollisionDispatcher(s),r=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver,o=new Ammo.btDefaultSoftBodySolver;n=new Ammo.btSoftRigidDynamicsWorld(i,r,a,s,o)}return n.setGravity(new Ammo.btVector3(e.x,e.y,e.z)),n}createDebrisFromBreakableObject(e,t){this.scene!=="headless"&&(e.material=t.material,e.shape="hull",e.fragmentDepth=t.fragmentDepth+1,e.name=`${t.name}__DEBRIS_${e.id}`,this.scene.add(e),this.addExisting(e,{autoCenter:!0}),e.body.fractureImpulse=t.body.fractureImpulse,e.body.breakable=!1,setTimeout(()=>{e.body.breakable=!0},2500))}removeDebris(e){this.scene!=="headless"&&(this.scene.remove(e),this.destroy(e))}update(e){this.updatePhysics(e),this.detectCollisions()}updatePhysics(e){const t=e/1e3;this.physicsWorld.stepSimulation(t,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let n=0;n<this.rigidBodies.length;n++){const s=this.rigidBodies[n];s.body.impact=[];const r=s.body.ammo.getMotionState();if(r){if(r.getWorldTransform(this.worldTransform),s.body.didUpdate&&(s.body._emitUpdateEvents&&s.body.eventEmitter.emit("update"),s.body.didUpdate=!1),s.body.ammo.isKinematicObject()&&s.body.needUpdate)s.getWorldQuaternion(this.tmpQuaternion),s.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),r.setWorldTransform(this.worldTransform),s.body.needUpdate=!1;else if(!s.body.skipUpdate){if(!s.body.ammo.isStaticObject()){const a=this.worldTransform.getOrigin(),o=this.worldTransform.getRotation(),c=s.body.offset;if(s.body.ignoreScale)this.tmpVector3a.set(s.scale.x,s.scale.y,s.scale.z);else{const u=s.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(u.x(),u.y(),u.z())}this.tmpVector3.set(a.x()+c.x,a.y()+c.y,a.z()+c.z),this.tmpQuaternion.set(o.x(),o.y(),o.z(),o.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),s.parent?parseInt(qs)>=123?this.tmpMatrix4a.copy(s.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(s.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(s.position,s.quaternion,s.scale)}}}}}detectCollisions(){var s,i;const e=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const t=this.physicsWorld.getDispatcher(),n=t.getNumManifolds();for(let r=0;r<n;r++){const a=t.getManifoldByIndexInternal(r),o=a.getNumContacts(),c=Ammo.castObject(a.getBody0(),Ammo.btRigidBody),u=Ammo.castObject(a.getBody1(),Ammo.btRigidBody),l=c.threeObject,h=u.threeObject;if(!l||!h||c.name===""&&u.name==="")continue;const m=(s=l.body)==null?void 0:s.checkCollisions,T=(i=h.body)==null?void 0:i.checkCollisions,w=l.body.breakable,x=h.body.breakable,E=l.body.fractureImpulse,k=h.body.fractureImpulse,b=m||T,R=w||x;if(typeof l.fragmentDepth>"u"&&(l.fragmentDepth=0),typeof h.fragmentDepth>"u"&&(h.fragmentDepth=0),!b&&!R)continue;let P=!1,O=0,v="start";for(let C=0;C<o;C++){const D=a.getContactPoint(C);if(D.getDistance()<=0){P=!0;const N=D.getAppliedImpulse(),j=D.get_m_positionWorldOnB(),W=D.get_m_normalWorldOnB();if(m||T){const se=[l.uuid,h.uuid].sort(),ee=`${se[0]}__${se[1]}`;if(this.earlierDetectedCollisions.find(q=>q.combinedName===ee)&&(v="collision"),!e.find(q=>q.combinedName===ee)){e.push({combinedName:ee,collision:!0});const q={x:j.x(),y:j.y(),z:j.z()},V={x:W.x(),y:W.y(),z:W.z()};l.body.impact.push({impulse:N,point:q,normal:V,name:h.name}),h.body.impact.push({impulse:N,point:q,normal:V,name:l.name}),this.collisionEvents.emit("collision",{bodies:[l,h],event:v})}}N>=O&&(O=N,(w||x)&&(this.impactPoint.set(j.x(),j.y(),j.z()),this.impactNormal.set(W.x(),W.y(),W.z())));break}}if(!P||!R)continue;const A=2;if(this.emptyV3.set(0,0,0),l.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:w,physicsBody:c},h.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:x,physicsBody:u},w&&O>E&&l.fragmentDepth<A){const C=this.convexBreaker.subdivideByImpact(l,this.impactPoint,this.impactNormal,1,2),D=C.length;for(let H=0;H<D;H++){const N=c.getLinearVelocity(),j=c.getAngularVelocity(),W=C[H];W.userData.ammoPhysicsData.velocity.set(N.x(),N.y(),N.z()),W.userData.ammoPhysicsData.angularVelocity.set(j.x(),j.y(),j.z()),this.createDebrisFromBreakableObject(W,l)}this.objectsToRemove[this.numObjectsToRemove++]=l}if(x&&O>k&&h.fragmentDepth<A){const C=this.convexBreaker.subdivideByImpact(h,this.impactPoint,this.impactNormal,1,2),D=C.length;for(let H=0;H<D;H++){const N=u.getLinearVelocity(),j=u.getAngularVelocity(),W=C[H];W.userData.ammoPhysicsData.velocity.set(N.x(),N.y(),N.z()),W.userData.ammoPhysicsData.angularVelocity.set(j.x(),j.y(),j.z()),this.createDebrisFromBreakableObject(W,h)}this.objectsToRemove[this.numObjectsToRemove++]=h}}for(let r=0;r<this.numObjectsToRemove;r++)this.removeDebris(this.objectsToRemove[r]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(r=>{const{combinedName:a}=r;if(!e.find(o=>o.combinedName===a)){const o=a.split("__"),c=this.rigidBodies.find(h=>h.uuid===o[0]),u=this.rigidBodies.find(h=>h.uuid===o[1]),l="end";c&&u&&this.collisionEvents.emit("collision",{bodies:[c,u],event:l})}}),this.earlierDetectedCollisions=[...e]}setGravity(e=0,t=-9.8,n=0){this.tmpBtVector3.setValue(e,t,n),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(e=1)=>{this.debugDrawer.setDebugMode(e)},disable:()=>{this.debugDrawer.disable()}}}start(){if(typeof Ammo>"u"){Je("Are you sure you included ammo.js?");return}typeof Ammo=="function"?Ammo().then(()=>{this.setup()}):this.setup()}get add(){return{collider:(e,t,n)=>this.collisionEvents.addCollider(e,t,n),constraints:this.constraints.addConstraints,existing:(e,t)=>this.addExisting(e,t),plane:(e={},t={})=>this.shapes.addPlane(e,t),sphere:(e={},t={})=>this.shapes.addSphere(e,t),ground:(e={},t={})=>this.shapes.addGround(e,t),box:(e={},t={})=>this.shapes.addBox(e,t),cylinder:(e={},t={})=>this.shapes.addCylinder(e,t),cone:(e={},t={})=>this.shapes.addCone(e,t),torus:(e={},t={})=>this.shapes.addTorus(e,t),extrude:(e,t={})=>this.shapes.addExtrude(e,t),raycaster:(e="closest")=>e==="closest"?new ni(this):new si(this)}}prepareThreeObjectForCollisionShape(e,t={}){var o,c;const{autoCenter:n=!1}=t,s={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let i="unknown";const r=((o=e.geometry)==null?void 0:o.type)||"unknown";/box/i.test(r)?i="box":/cone/i.test(r)?i="cone":/cylinder/i.test(r)?i="cylinder":/extrude/i.test(r)?i="extrude":/plane/i.test(r)?i="plane":/sphere/i.test(r)?i="sphere":/torus/i.test(r)&&(i="torus");let a={...s,...(c=e==null?void 0:e.geometry)==null?void 0:c.parameters};return t.shape?(a={...s,...t},i=t.shape):e.shape&&(i=e.shape),Object.keys(a).forEach(u=>{typeof a[u]>"u"&&s[u]&&(a[u]=s[u])}),n&&e.geometry.center(),i==="cylinder"&&(a.radius=t.radius||a.radiusTop),i==="extrude"&&(i="hacd"),(i==="mesh"||i==="convex")&&(i="convexMesh"),i==="concave"&&(i="concaveMesh"),i==="unknown"&&(Je(`Shape for ${e==null?void 0:e.name} not recognized! Will fallback to box.`),i="box"),{shape:i,params:a,object:e}}createCollisionShape(e,t,n){const s=n!=null&&n.quaternion?n==null?void 0:n.quaternion:new Te(0,0,0,1),{axis:i="y"}=t,r=new Ammo.btVector3,a=n==null?void 0:n.geometry;n&&(a==null?void 0:a.isGeometry)&&(n.geometry=new Be().fromGeometry(a));const o=T=>{const w=new ae().elements,x=[],E=[],k=[];return ai(T,{},(b,R,P)=>{x.push(b),E.push(R),k.push(P)}),{vertices:x,matrices:E,indexes:k,matrixWorld:w}};let c={};this.complexShapes.indexOf(e)!==-1&&(c=o(n));let u;switch(e){case"box":r.setValue(t.width/2,t.height/2,t.depth/2),u=new Ammo.btBoxShape(r);break;case"sphere":u=new Ammo.btSphereShape(t.radius);break;case"cylinder":switch(i){case"y":r.setValue(t.radius,t.height/2,t.radius),u=new Ammo.btCylinderShape(r);break;case"x":r.setValue(t.height/2,t.radius,t.radius),u=new Ammo.btCylinderShapeX(r);break;case"z":r.setValue(t.radius,t.radius,t.height/2),u=new Ammo.btCylinderShapeZ(r);break}break;case"cone":switch(i){case"y":u=new Ammo.btConeShape(t.radius,t.height);break;case"x":u=new Ammo.btConeShapeX(t.radius,t.height);break;case"z":u=new Ammo.btConeShapeZ(t.radius,t.height);break}break;case"capsule":switch(i){case"y":u=new Ammo.btCapsuleShape(t.radius,t.height);break;case"x":u=new Ammo.btCapsuleShapeX(t.radius,t.height);break;case"z":u=new Ammo.btCapsuleShapeZ(t.radius,t.height);break}break;case"torus":u=Br(t,s);break;case"plane":u=Dt(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...t,concave:!1});break;case"hull":u=oi(c.vertices,c.matrices,c.matrixWorld,t);break;case"hacd":u=ri(c.vertices,c.matrices,c.indexes,c.matrixWorld,t);break;case"vhacd":u=ii(c.vertices,c.matrices,c.indexes,c.matrixWorld,t);break;case"convexMesh":u=Dt(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...t,concave:!1});break;case"concaveMesh":u=Dt(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...t,concave:!0});break}Ammo.destroy(r);const{x:l,y:h,z:m}=t;return(l||h||m)&&(u._compoundOffset={x:l||0,y:h||0,z:m||0}),Array.isArray(u)&&(u=this.mergeCollisionShapesToCompoundShape(u)),u}mergeCollisionShapesToCompoundShape(e){const t=new Ammo.btCompoundShape;return e.forEach(n=>{const{_childOffset:s,_compoundOffset:i}=n;if(s){const{pos:r,quat:a,scale:o,margin:c}=s,u=this.applyPosQuatScaleMargin(n,r,a,o,c);t.addChildShape(u,n)}else if(i){const r=new Ammo.btTransform;r.setIdentity(),r.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),t.addChildShape(r,n)}else{const r=new Ammo.btTransform;r.setIdentity(),t.addChildShape(r,n)}}),t}addExisting(e,t={}){const{hasBody:n}=e;if(n){Je(`Object "${e.name}" already has a physical body!`);return}const s=new J,i=new Te,r=new J;e.getWorldPosition(s),e.getWorldQuaternion(i),e.getWorldScale(r);const a=(t.collisionFlags||0).toString(2).slice(-1)==="1",o=(t.collisionFlags||0).toString(2).slice(-2,-1)==="1",{shape:c="unknown",compound:u=[],mass:l=a||o?0:1,collisionFlags:h=0,collisionGroup:m=1,collisionMask:T=-1,offset:w=void 0,breakable:x=!1,addChildren:E=!0,margin:k=.01,ignoreScale:b=!1,fractureImpulse:R=1}=t;if(b&&r.set(1,1,1),u.length>=1){const C=u.map(j=>this.createCollisionShape(j.shape,j)),D=this.mergeCollisionShapesToCompoundShape(C),H=this.applyPosQuatScaleMargin(D,s,i,r,k),N=this.collisionShapeToRigidBody(D,H,l,o);this.addRigidBodyToWorld(e,N,h,m,T,w),e.body.breakable=x,e.body.fractureImpulse=R,e.body.ignoreScale=b;return}const P=[];if(c!=="unknown"||e.isMesh){const C=this.prepareThreeObjectForCollisionShape(e,t),D=this.createCollisionShape(C.shape,C.params,C.object);P.push(D)}if(c==="unknown"&&E&&e.children.length>=1&&e.children.forEach(C=>{if(C.isMesh){const D=this.prepareThreeObjectForCollisionShape(C),H=this.createCollisionShape(D.shape,D.params,D.object);H._childOffset={pos:C.position.clone(),quat:C.quaternion.clone(),scale:C.scale.clone(),margin:k},P.push(H)}}),P.length===0){const C=this.prepareThreeObjectForCollisionShape(e,t),D=this.createCollisionShape(C.shape,C.params,C.object);P.push(D)}const O=P.length===1?P[0]:this.mergeCollisionShapesToCompoundShape(P),v=this.applyPosQuatScaleMargin(O,s,i,r,k),A=this.collisionShapeToRigidBody(O,v,l,o);this.addRigidBodyToWorld(e,A,h,m,T,w),e.body.breakable=x,e.body.fractureImpulse=R,e.body.ignoreScale=b}addRigidBodyToWorld(e,t,n,s,i,r){this.rigidBodies.push(e),this.physicsWorld.addRigidBody(t,s,i);const a=Object.values(t)[0];e.name||(e.name=`object-${e.id}`),t.name=e.name,e.body=new Fr(this,t),e.hasBody=!0,e.ptr=a,t.threeObject=e,r&&(e.body.offset={x:0,y:0,z:0,...r}),e.body.setCollisionFlags(n)}applyPosQuatScaleMargin(e,t=new J,n=new Te,s=new J,i=.01){e.setMargin(i);const r=new Ammo.btQuaternion(0,0,0,1);r.setValue(n.x,n.y,n.z,n.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(t.x,t.y,t.z),a.setRotation(r),Ammo.destroy(r);const o=new Ammo.btVector3(s.x,s.y,s.z);return e.setLocalScaling(o),Ammo.destroy(o),a}collisionShapeToRigidBody(e,t,n,s){const i=new Ammo.btDefaultMotionState(t),r=new Ammo.btVector3(0,0,0);n>0&&e.calculateLocalInertia(n,r);const a=new Ammo.btRigidBodyConstructionInfo(n,i,e,r),o=new Ammo.btRigidBody(a);return(n>0||s)&&o.setActivationState(4),o}}const Pt=class{static createButton(e){const t=document.createElement("button");function n(){let o=null;async function c(l){l.addEventListener("end",u),await e.xr.setSession(l),t.textContent="EXIT VR",o=l}function u(){o.removeEventListener("end",u),t.textContent="ENTER VR",o=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){if(o===null){const l={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};navigator.xr.requestSession("immersive-vr",l).then(c)}else o.end()}}function s(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function i(){s(),t.textContent="VR NOT SUPPORTED"}function r(o){s(),console.warn("Exception when trying to call xr.isSessionSupported",o),t.textContent="VR NOT ALLOWED"}function a(o){o.style.position="absolute",o.style.bottom="20px",o.style.padding="12px 6px",o.style.border="1px solid #fff",o.style.borderRadius="4px",o.style.background="rgba(0,0,0,0.1)",o.style.color="#fff",o.style.font="normal 13px sans-serif",o.style.textAlign="center",o.style.opacity="0.5",o.style.outline="none",o.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-vr").then(function(o){o?n():i(),o&&Pt.xrSessionIsGranted&&t.click()}).catch(r),t;{const o=document.createElement("a");return window.isSecureContext===!1?(o.href=document.location.href.replace(/^http:/,"https:"),o.innerHTML="WEBXR NEEDS HTTPS"):(o.href="https://immersiveweb.dev/",o.innerHTML="WEBXR NOT AVAILABLE"),o.style.left="calc(50% - 90px)",o.style.width="180px",o.style.textDecoration="none",a(o),o}}static registerSessionGrantedListener(){if("xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{Pt.xrSessionIsGranted=!0})}}};let ht=Pt;cn(ht,"xrSessionIsGranted",!1);ht.registerSessionGrantedListener();const pe={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function cs(d){const e=await fetch(d);if(e.ok)return e.json();throw new Error(e.statusText)}async function Gr(d){if(!d)throw new Error("No basePath supplied");return await cs(`${d}/profilesList.json`)}async function Wr(d,e,t=null,n=!0){if(!d)throw new Error("No xrInputSource supplied");if(!e)throw new Error("No basePath supplied");const s=await Gr(e);let i;if(d.profiles.some(o=>{const c=s[o];return c&&(i={profileId:o,profilePath:`${e}/${c.path}`,deprecated:!!c.deprecated}),!!i}),!i){if(!t)throw new Error("No matching profile name found");const o=s[t];if(!o)throw new Error(`No matching profile name found and default profile "${t}" missing.`);i={profileId:t,profilePath:`${e}/${o.path}`,deprecated:!!o.deprecated}}const r=await cs(i.profilePath);let a;if(n){let o;if(d.handedness==="any"?o=r.layouts[Object.keys(r.layouts)[0]]:o=r.layouts[d.handedness],!o)throw new Error(`No matching handedness, ${d.handedness}, in profile ${i.profileId}`);o.assetPath&&(a=i.profilePath.replace("profile.json",o.assetPath))}return{profile:r,assetPath:a}}const Xr={xAxis:0,yAxis:0,button:0,state:pe.ComponentState.DEFAULT};function Kr(d=0,e=0){let t=d,n=e;if(Math.sqrt(d*d+e*e)>1){const r=Math.atan2(e,d);t=Math.cos(r),n=Math.sin(r)}return{normalizedXAxis:t*.5+.5,normalizedYAxis:n*.5+.5}}class qr{constructor(e){this.componentProperty=e.componentProperty,this.states=e.states,this.valueNodeName=e.valueNodeName,this.valueNodeProperty=e.valueNodeProperty,this.valueNodeProperty===pe.VisualResponseProperty.TRANSFORM&&(this.minNodeName=e.minNodeName,this.maxNodeName=e.maxNodeName),this.value=0,this.updateFromComponent(Xr)}updateFromComponent({xAxis:e,yAxis:t,button:n,state:s}){const{normalizedXAxis:i,normalizedYAxis:r}=Kr(e,t);switch(this.componentProperty){case pe.ComponentProperty.X_AXIS:this.value=this.states.includes(s)?i:.5;break;case pe.ComponentProperty.Y_AXIS:this.value=this.states.includes(s)?r:.5;break;case pe.ComponentProperty.BUTTON:this.value=this.states.includes(s)?n:0;break;case pe.ComponentProperty.STATE:this.valueNodeProperty===pe.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(s):this.value=this.states.includes(s)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class Yr{constructor(e,t){if(!e||!t||!t.visualResponses||!t.gamepadIndices||Object.keys(t.gamepadIndices).length===0)throw new Error("Invalid arguments supplied");this.id=e,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach(n=>{const s=new qr(t.visualResponses[n]);this.visualResponses[n]=s}),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:pe.ComponentState.DEFAULT,button:this.gamepadIndices.button!==void 0?0:void 0,xAxis:this.gamepadIndices.xAxis!==void 0?0:void 0,yAxis:this.gamepadIndices.yAxis!==void 0?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(e){if(this.values.state=pe.ComponentState.DEFAULT,this.gamepadIndices.button!==void 0&&e.buttons.length>this.gamepadIndices.button){const t=e.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||this.values.button===1?this.values.state=pe.ComponentState.PRESSED:(t.touched||this.values.button>pe.ButtonTouchThreshold)&&(this.values.state=pe.ComponentState.TOUCHED)}this.gamepadIndices.xAxis!==void 0&&e.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=e.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===pe.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>pe.AxisTouchThreshold&&(this.values.state=pe.ComponentState.TOUCHED)),this.gamepadIndices.yAxis!==void 0&&e.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=e.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===pe.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>pe.AxisTouchThreshold&&(this.values.state=pe.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach(t=>{t.updateFromComponent(this.values)})}}class Qr{constructor(e,t,n){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=n,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach(s=>{const i=this.layoutDescription.components[s];this.components[s]=new Yr(s,i)}),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach(t=>{e.push(t.data)}),e}updateFromGamepad(){Object.values(this.components).forEach(e=>{e.updateFromGamepad(this.xrInputSource.gamepad)})}}const Zr="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",$r="generic-trigger";class Jr extends it{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e?this:(this.envMap=e,this.traverse(t=>{t.isMesh&&(t.material.envMap=this.envMap,t.material.needsUpdate=!0)}),this)}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach(t=>{Object.values(t.visualResponses).forEach(n=>{const{valueNode:s,minNode:i,maxNode:r,value:a,valueNodeProperty:o}=n;!s||(o===pe.VisualResponseProperty.VISIBILITY?s.visible=a:o===pe.VisualResponseProperty.TRANSFORM&&(s.quaternion.slerpQuaternions(i.quaternion,r.quaternion,a),s.position.lerpVectors(i.position,r.position,a)))})}))}}function eo(d,e){Object.values(d.components).forEach(t=>{const{type:n,touchPointNodeName:s,visualResponses:i}=t;if(n===pe.ComponentType.TOUCHPAD)if(t.touchPointNode=e.getObjectByName(s),t.touchPointNode){const r=new sn(.001),a=new Ve({color:255}),o=new Re(r,a);t.touchPointNode.add(o)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(i).forEach(r=>{const{valueNodeName:a,minNodeName:o,maxNodeName:c,valueNodeProperty:u}=r;if(u===pe.VisualResponseProperty.TRANSFORM){if(r.minNode=e.getObjectByName(o),r.maxNode=e.getObjectByName(c),!r.minNode){console.warn(`Could not find ${o} in the model`);return}if(!r.maxNode){console.warn(`Could not find ${c} in the model`);return}}r.valueNode=e.getObjectByName(a),r.valueNode||console.warn(`Could not find ${a} in the model`)})})}function Sn(d,e){eo(d.motionController,e),d.envMap&&e.traverse(t=>{t.isMesh&&(t.material.envMap=d.envMap,t.material.needsUpdate=!0)}),d.add(e)}class to{constructor(e=null){this.gltfLoader=e,this.path=Zr,this._assetCache={},this.gltfLoader||(this.gltfLoader=new on)}createControllerModel(e){const t=new Jr;let n=null;return e.addEventListener("connected",s=>{const i=s.data;i.targetRayMode!=="tracked-pointer"||!i.gamepad||Wr(i,this.path,$r).then(({profile:r,assetPath:a})=>{t.motionController=new Qr(i,r,a);const o=this._assetCache[t.motionController.assetUrl];if(o)n=o.scene.clone(),Sn(t,n);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(t.motionController.assetUrl,c=>{this._assetCache[t.motionController.assetUrl]=c,n=c.scene.clone(),Sn(t,n)},null,()=>{throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`)})}}).catch(r=>{console.warn(r)})}),e.addEventListener("disconnected",()=>{t.motionController=null,t.remove(n),n=null}),t}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class no{constructor(e,t){this._renderer=e,this._scene=t,this.controllerModelFactory=new to;const n=new ci;n.name="dot",this.cameraGroup=new st,this.cameraGroup.add(n),t.add(this.cameraGroup),e.xr.enabled=!0;const s=ht.createButton(e);s.style.cssText+="background: rgba(0, 0, 0, 0.8); ",document.body.appendChild(s),this._renderer.xr.getCamera().add(this.cameraGroup)}get isPresenting(){var e,t;return!!((t=(e=this._renderer)==null?void 0:e.xr)!=null&&t.isPresenting)}getController(e){const t=this._renderer.xr.getController(e);return this.cameraGroup.add(t),t}getControllerGrip(e){const t=this._renderer.xr.getControllerGrip(e),n=this.controllerModelFactory.createControllerModel(t);return t.add(n),this.cameraGroup.add(t),t}getControllerRay(e){const{targetRayMode:t}=e;if(t==="tracked-pointer"){const n=new Be;n.setAttribute("position",new Le([0,0,0,0,0,-1],3)),n.setAttribute("color",new Le([1,0,0,1,1,1],3));const s=new bt({vertexColors:!0});return new Rt(n,s)}if(t==="gaze"){const n=new Ys(.02,.04,32).translate(0,0,-1),s=new Ve({color:"red",opacity:.5,transparent:!0});return new Re(n,s)}}get camera(){return this.WebXRCamera}get WebXRCamera(){var e;return{group:this.cameraGroup,position:(e=this._renderer.xr.getCamera())==null?void 0:e.position,rotation:this.isPresenting?this._renderer.xr.getCamera().rotation:void 0,getWorldDirection:t=>this.isPresenting?this._renderer.xr.getCamera().getWorldDirection(t):void 0}}}const so=(d=20,e)=>{if(!window.__loadPhysics){console.log("There is not much fun without physics enabled!");return}for(let t=0;t<d;t++){const n=["standard","basic","normal","phong","line","points"],s=(r,a)=>Math.floor(Math.random()*(a-r+1)+r),i=r=>r[Math.floor(Math.random()*r.length)];Math.random()>.5?e.add.box({x:s(-10,10),y:s(10,20),z:s(-10,10),width:s(1,2)/10,height:s(1,2)/10,depth:s(1,2)/10,mass:1},{[i(n)]:{color:Math.floor(Math.random()*16777215)}}).body.setRestitution(Math.floor(Math.random()*10)/20):e.add.sphere({x:s(-10,10),y:s(10,20),z:s(-10,10),radius:s(1,2)/10,mass:1},{[i(n)]:{color:Math.floor(Math.random()*16777215)}}).body.setRestitution(Math.floor(Math.random()*10)/20)}};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class yt{perspectiveCamera(e={}){return yt.Perspective(e)}orthographicCamera(e={}){return yt.Orthographic(e)}static Perspective(e={}){const{fov:t=50,aspect:n=window.innerWidth/window.innerHeight,near:s=.1,far:i=2e3,x:r=0,y:a=5,z:o=25}=e,c=new wt(t,n,s,i);return c.position.set(r,a,o),c}static Orthographic(e={}){const t=window.innerWidth,n=window.innerHeight,{left:s=t/-2,right:i=t/2,top:r=n/2,bottom:a=n/-2,near:o=1,far:c=1e3,x:u=0,y:l=0,z:h=10}=e,m=new tn(s,i,r,a,o,c);return m.position.set(u,l,h),m}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class io{constructor(e={}){this.sceneConfig=e,this.scenes=new Map,this.__config={},this._isRunning=!1,this._deconstructor=[];const{key:t=Math.random().toString(),enableXR:n=!1}=e;this.__config.sceneKey=t,this.__config.enableXR=n}get deconstructor(){return{add:(...e)=>{e.forEach(t=>{this._deconstructor.push(t)})}}}initializeScene(e){const{renderer:t,parent:n,canvas:s,scene:i,scenes:r,camera:a,cache:o,physics:c,sceneConfig:u}=e;this.scene=i,this.scenes=r,this.camera=a,this.cache=o,this.physics=c,this.renderer=t,this.parent=n,this.canvas=s;const{autoStart:l,textureAnisotropy:h}=u;this.load=new Pr(this.cache,h),this.lights=new li(this.scene),this.transform=new Dr(this.camera,this.renderer),this.csg=gi,this.heightMap=new Lr(this.scene),this.factories=new as(this.scene),this.misc=new Or(this.scene,this.renderer,this.factories),this.ws=new Cr(i,t,a,this.lights,this.physics,this.load,this.factories),this.mixers=new Ir,this.cameras=new yt,this.clock=new Wn,this.__config.enableXR&&(this.webXR=new no(this.renderer,this.scene)),l&&this.start(this.__config.sceneKey)}get sceneKey(){return this.__config.sceneKey}destroy(e){var t;(t=this.physics)==null||t.destroy(e.body),this.scene.remove(e),e=null}async warpSpeed(...e){return await this.ws.warpSpeed(...e)}get animationMixers(){return this.mixers.mixers}get make(){return this.factories.make}get add(){return this.factories.add}haveSomeFun(e=20){so(e,this.physics)}isRunning(){return this._isRunning}async start(e,t){var n;e&&e!==this.__config.sceneKey?(this.stop(),(n=this.scenes.get(e))==null||n._start(t)):this._start(t)}async _start(e){var t;await((t=this.init)==null?void 0:t.call(this,e)),await this._preload(),await this._create(),this.renderer.setAnimationLoop(()=>{this._update()}),this._isRunning=!0}async restart(e){await this.stop(),await this.start(this.__config.sceneKey,e)}async stop(){var e,t,n;this._isRunning=!1,this.renderer.setAnimationLoop(null),this.clock.start();for(let s of this._deconstructor)await((e=s.dispose)==null?void 0:e.call(s)),await((t=s.destroy)==null?void 0:t.call(s)),typeof s=="function"&&await(s==null?void 0:s()),s=null;if(this._deconstructor=[],(n=this.physics)!=null&&n.rigidBodies)for(let s=this.physics.rigidBodies.length-1;s>=0;s--)this.physics.destroy(this.physics.rigidBodies[s]);for(let s=this.scene.children.length-1;s>=0;s--)this.scene.remove(this.scene.children[s])}setSize(e,t){this.renderer.setSize(e,t),typeof this.camera.aspect<"u"&&(this.camera.aspect=e/t),this.camera.updateProjectionMatrix()}setPixelRatio(e){this.renderer.setPixelRatio(e)}init(e={}){}preload(){}create(){}update(e,t){}preRender(){}postRender(){}async _preload(){var e;await((e=this.preload)==null?void 0:e.call(this))}async _create(){var e;await((e=this.create)==null?void 0:e.call(this))}_update(){var n,s,i;const e=this.clock.getDelta()*1e3,t=this.clock.getElapsedTime();(n=this.update)==null||n.call(this,parseFloat(t.toFixed(3)),parseInt(e.toString())),(s=this.physics)==null||s.update(e),(i=this.physics)==null||i.updateDebugger(),this.animationMixers.update(e),this.preRender(),this.composer?this.composer.render():this.renderer.render(this.scene,this.camera),this.postRender()}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class ro{constructor(e={}){this.threeGraphicsConfig=e;const{alpha:t=!1,anisotropy:n=1,camera:s=yt.Perspective({z:25,y:5}),antialias:i=!1,usePhysics:r=!0,renderer:a}=e;this.textureAnisotropy=n,this.camera=s,this.scene=new Qs,this.renderer=a||new Zs({antialias:i,alpha:t}),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=$s,this.cache=Js,this.cache.enabled=!0,r&&(typeof Ammo<"u"?this.physics=new jr(this.scene,e):Je("Are you sure you included ammo.js?"))}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class oo extends ro{constructor(e){var n;super(e),this.projectConfig=e,this.scenes=new Map,this.renderer.setSize(window.innerWidth,window.innerHeight),this.projectConfig.parent?this.parent=document.getElementById(this.projectConfig.parent):this.parent=document.body,this.parent||(Je(`Parent "${this.projectConfig.parent}" not found! Will add it to the body.`),this.parent=document.body),this.parent.appendChild(this.renderer.domElement),this.canvas=this.renderer.domElement;let t="";this.projectConfig.scenes.forEach((s,i)=>{const r=new s;i===0&&(t=r.sceneKey);const a={sceneConfig:{textureAnisotropy:this.textureAnisotropy,autoStart:!1},renderer:this.renderer,parent:this.parent,canvas:this.canvas,scene:this.scene,scenes:this.scenes,camera:this.camera,cache:this.cache,physics:this.physics};r.initializeScene(a),i===0&&(r.setSize(this.parent.clientWidth,this.parent.clientHeight),r.setPixelRatio(Math.max(1,window.devicePixelRatio/2))),this.scenes.set(r.sceneKey,r)}),(n=this.scenes.get(t))==null||n.start(t)}}var ao={exports:{}};(function(d){(function(e,t,n){if(!e)return;for(var s={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},i={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},r={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},a={option:"alt",command:"meta",return:"enter",escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},o,c=1;c<20;++c)s[111+c]="f"+c;for(c=0;c<=9;++c)s[c+96]=c.toString();function u(v,A,C){if(v.addEventListener){v.addEventListener(A,C,!1);return}v.attachEvent("on"+A,C)}function l(v){if(v.type=="keypress"){var A=String.fromCharCode(v.which);return v.shiftKey||(A=A.toLowerCase()),A}return s[v.which]?s[v.which]:i[v.which]?i[v.which]:String.fromCharCode(v.which).toLowerCase()}function h(v,A){return v.sort().join(",")===A.sort().join(",")}function m(v){var A=[];return v.shiftKey&&A.push("shift"),v.altKey&&A.push("alt"),v.ctrlKey&&A.push("ctrl"),v.metaKey&&A.push("meta"),A}function T(v){if(v.preventDefault){v.preventDefault();return}v.returnValue=!1}function w(v){if(v.stopPropagation){v.stopPropagation();return}v.cancelBubble=!0}function x(v){return v=="shift"||v=="ctrl"||v=="alt"||v=="meta"}function E(){if(!o){o={};for(var v in s)v>95&&v<112||s.hasOwnProperty(v)&&(o[s[v]]=v)}return o}function k(v,A,C){return C||(C=E()[v]?"keydown":"keypress"),C=="keypress"&&A.length&&(C="keydown"),C}function b(v){return v==="+"?["+"]:(v=v.replace(/\+{2}/g,"+plus"),v.split("+"))}function R(v,A){var C,D,H,N=[];for(C=b(v),H=0;H<C.length;++H)D=C[H],a[D]&&(D=a[D]),A&&A!="keypress"&&r[D]&&(D=r[D],N.push("shift")),x(D)&&N.push(D);return A=k(D,N,A),{key:D,modifiers:N,action:A}}function P(v,A){return v===null||v===t?!1:v===A?!0:P(v.parentNode,A)}function O(v){var A=this;if(v=v||t,!(A instanceof O))return new O(v);A.target=v,A._callbacks={},A._directMap={};var C={},D,H=!1,N=!1,j=!1;function W(Z){Z=Z||{};var te=!1,oe;for(oe in C){if(Z[oe]){te=!0;continue}C[oe]=0}te||(j=!1)}function se(Z,te,oe,M,y,p){var f,_,U=[],I=oe.type;if(!A._callbacks[Z])return[];for(I=="keyup"&&x(Z)&&(te=[Z]),f=0;f<A._callbacks[Z].length;++f)if(_=A._callbacks[Z][f],!(!M&&_.seq&&C[_.seq]!=_.level)&&I==_.action&&(I=="keypress"&&!oe.metaKey&&!oe.ctrlKey||h(te,_.modifiers))){var z=!M&&_.combo==y,G=M&&_.seq==M&&_.level==p;(z||G)&&A._callbacks[Z].splice(f,1),U.push(_)}return U}function ee(Z,te,oe,M){A.stopCallback(te,te.target||te.srcElement,oe,M)||Z(te,oe)===!1&&(T(te),w(te))}A._handleKey=function(Z,te,oe){var M=se(Z,te,oe),y,p={},f=0,_=!1;for(y=0;y<M.length;++y)M[y].seq&&(f=Math.max(f,M[y].level));for(y=0;y<M.length;++y){if(M[y].seq){if(M[y].level!=f)continue;_=!0,p[M[y].seq]=1,ee(M[y].callback,oe,M[y].combo,M[y].seq);continue}_||ee(M[y].callback,oe,M[y].combo)}var U=oe.type=="keypress"&&N;oe.type==j&&!x(Z)&&!U&&W(p),N=_&&oe.type=="keydown"};function q(Z){typeof Z.which!="number"&&(Z.which=Z.keyCode);var te=l(Z);if(!!te){if(Z.type=="keyup"&&H===te){H=!1;return}A.handleKey(te,m(Z),Z)}}function V(){clearTimeout(D),D=setTimeout(W,1e3)}function ue(Z,te,oe,M){C[Z]=0;function y(I){return function(){j=I,++C[Z],V()}}function p(I){ee(oe,I,Z),M!=="keyup"&&(H=l(I)),setTimeout(W,10)}for(var f=0;f<te.length;++f){var _=f+1===te.length,U=_?p:y(M||R(te[f+1]).action);ce(te[f],U,M,Z,f)}}function ce(Z,te,oe,M,y){A._directMap[Z+":"+oe]=te,Z=Z.replace(/\s+/g," ");var p=Z.split(" "),f;if(p.length>1){ue(Z,p,te,oe);return}f=R(Z,oe),A._callbacks[f.key]=A._callbacks[f.key]||[],se(f.key,f.modifiers,{type:f.action},M,Z,y),A._callbacks[f.key][M?"unshift":"push"]({callback:te,modifiers:f.modifiers,action:f.action,seq:M,level:y,combo:Z})}A._bindMultiple=function(Z,te,oe){for(var M=0;M<Z.length;++M)ce(Z[M],te,oe)},u(v,"keypress",q),u(v,"keydown",q),u(v,"keyup",q)}O.prototype.bind=function(v,A,C){var D=this;return v=v instanceof Array?v:[v],D._bindMultiple.call(D,v,A,C),D},O.prototype.unbind=function(v,A){var C=this;return C.bind.call(C,v,function(){},A)},O.prototype.trigger=function(v,A){var C=this;return C._directMap[v+":"+A]&&C._directMap[v+":"+A]({},v),C},O.prototype.reset=function(){var v=this;return v._callbacks={},v._directMap={},v},O.prototype.stopCallback=function(v,A){var C=this;if((" "+A.className+" ").indexOf(" mousetrap ")>-1||P(A,C.target))return!1;if("composedPath"in v&&typeof v.composedPath=="function"){var D=v.composedPath()[0];D!==v.target&&(A=D)}return A.tagName=="INPUT"||A.tagName=="SELECT"||A.tagName=="TEXTAREA"||A.isContentEditable},O.prototype.handleKey=function(){var v=this;return v._handleKey.apply(v,arguments)},O.addKeycodes=function(v){for(var A in v)v.hasOwnProperty(A)&&(s[A]=v[A]);o=null},O.init=function(){var v=O(t);for(var A in v)A.charAt(0)!=="_"&&(O[A]=function(C){return function(){return v[C].apply(v,arguments)}}(A))},O.init(),e.Mousetrap=O,d.exports&&(d.exports=O),typeof n=="function"&&n.amd&&n(function(){return O})})(typeof window<"u"?window:null,typeof window<"u"?document:null)})(ao);const co={data:()=>({game:{}}),mounted(){this.gameInit()},methods:{gameInit(){class d extends io{init(){}preload(){}async create(){console.clear(),this.warpSpeed("-ground"),this.ball=this.physics.add.sphere({radius:.5,x:2,y:5,z:2,mass:.2},{lambert:{color:"hotpink"}}),new on().load("/assets/models/test-track/scene.gltf",t=>{const n=t.scene.children[0];n.scale.set(5,5,5),n.position.set(-25,-420,0),n.traverse(s=>{s.isMesh&&(s.castShadow=s.receiveShadow=!0,s.material.metalness=0,s.material.roughness=1)}),this.scene.add(n),this.physics.add.existing(n,{mass:0,shape:"concaveMesh"}),this.car=new ui(this)})}update(){}}Hr("/assets/ammo",()=>new oo({parent:"game",scenes:[d]}))}}},lo={ref:"game",id:"game",style:{width:"100%",height:"600px"}};function uo(d,e,t,n,s,i){return pi(),di("div",null,[dn("div",lo,null,512),dn("pre",null,fi(d.game),1)])}const go=hi(co,[["render",uo]]);export{go as default};
