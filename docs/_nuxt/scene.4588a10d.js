import{h as gt,i as J,j as Ve,C as X,S as Qt,k as Zt,D as yt,e as ie,s as fe,l as Z,d as B,M as ee,V as C,Q as W,I as $t,O as bt,m as wt,n as Jt,o as de,p as es,q as Tt,r as xt,t as De,u as oe,v as ue,w as re,x as ke,y as At,z as ts,a as ce,E as ss,b as pe,G as Te,H as Et,J as ns,K as me,N as be,U as St,W as Lt,X as Mt,Y as is,Z as _t,_ as os,$ as rs,a0 as Rt,a1 as as,a2 as cs,a3 as ls,a4 as hs,a5 as ds,a6 as us,a7 as ms,a8 as fs,a9 as ps,aa as Ze,ab as gs,ac as ys,ad as $e,ae as bs,B as ws,af as Ts,ag as xs,ah as Ct,ai as As,aj as Es,ak as Ss,g as Ls,al as Ms,am as _s,an as Rs,ao as Cs,ap as Pt,aq as Ps,ar as Ds,as as se,at as ne,au as Je,av as Dt,aw as et,R as Os,F as q,ax as tt,ay as Is,az as Vs,aA as Ot,aB as ks,aC as vs,aD as Ns,aE as Bs}from"./three.module.792bc64d.js";import{l as we,E as xe,a as Fs,C as Us,b as zs,A as Hs,c as Me,d as js,e as Gs,f as Ks,i as Ws}from"./matter.22d1f548.js";import{Y as Xs,o as Ys,f as qs,Z as Qs}from"./entry.8100cb04.js";class Zs extends gt{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new sn(t)}),this.register(function(t){return new hn(t)}),this.register(function(t){return new dn(t)}),this.register(function(t){return new on(t)}),this.register(function(t){return new rn(t)}),this.register(function(t){return new an(t)}),this.register(function(t){return new cn(t)}),this.register(function(t){return new tn(t)}),this.register(function(t){return new ln(t)}),this.register(function(t){return new nn(t)}),this.register(function(t){return new Js(t)}),this.register(function(t){return new un(t)}),this.register(function(t){return new mn(t)})}load(e,t,s,n){const i=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=J.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){n?n(c):console.error(c),i.manager.itemError(e),i.manager.itemEnd(e)},r=new Ve(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(c){try{i.parse(c,o,function(h){t(h),i.manager.itemEnd(e)},a)}catch(h){a(h)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let i;const o={},a={};if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(J.decodeText(new Uint8Array(e,0,4))===It){try{o[_.KHR_BINARY_GLTF]=new fn(e)}catch(h){n&&n(h);return}i=JSON.parse(o[_.KHR_BINARY_GLTF].content)}else i=JSON.parse(J.decodeText(new Uint8Array(e)));else i=e;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const r=new _n(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});r.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const h=this.pluginCallbacks[c](r);a[h.name]=h,o[h.name]=!0}if(i.extensionsUsed)for(let c=0;c<i.extensionsUsed.length;++c){const h=i.extensionsUsed[c],l=i.extensionsRequired||[];switch(h){case _.KHR_MATERIALS_UNLIT:o[h]=new en;break;case _.KHR_DRACO_MESH_COMPRESSION:o[h]=new pn(i,this.dracoLoader);break;case _.KHR_TEXTURE_TRANSFORM:o[h]=new gn;break;case _.KHR_MESH_QUANTIZATION:o[h]=new yn;break;default:l.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}r.setExtensions(o),r.setPlugins(a),r.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,i){s.parse(e,t,n,i)})}}function $s(){let f={};return{get:function(e){return f[e]},add:function(e,t){f[e]=t},remove:function(e){delete f[e]},removeAll:function(){f={}}}}const _={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Js{constructor(e){this.parser=e,this.name=_.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const i=t.json,r=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let c;const h=new X(16777215);r.color!==void 0&&h.fromArray(r.color);const l=r.range!==void 0?r.range:0;switch(r.type){case"directional":c=new yt(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Zt(h),c.distance=l;break;case"spot":c=new Qt(h),c.distance=l,r.spot=r.spot||{},r.spot.innerConeAngle=r.spot.innerConeAngle!==void 0?r.spot.innerConeAngle:0,r.spot.outerConeAngle=r.spot.outerConeAngle!==void 0?r.spot.outerConeAngle:Math.PI/4,c.angle=r.spot.outerConeAngle,c.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return c.position.set(0,0,0),c.decay=2,Q(c,r),r.intensity!==void 0&&(c.intensity=r.intensity),c.name=t.createUniqueName(r.name||"light_"+e),n=Promise.resolve(c),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(r){return s._getNodeRef(t.cache,a,r)})}}class en{constructor(){this.name=_.KHR_MATERIALS_UNLIT}getMaterialType(){return ie}extendParams(e,t,s){const n=[];e.color=new X(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}i.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",i.baseColorTexture,fe))}return Promise.all(n)}}class tn{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class sn{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new B(a,a)}return Promise.all(i)}}class nn{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(i)}}class on{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new X(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=n.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",o.sheenColorTexture,fe)),o.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(i)}}class rn{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(i)}}class an{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new X(a[0],a[1],a[2]),Promise.all(i)}}class cn{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class ln{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Z}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new X(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",o.specularColorTexture,fe)),Promise.all(i)}}class hn{constructor(e){this.parser=e,this.name=_.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,o)}}class dn{constructor(e){this.parser=e,this.name=_.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const o=i.extensions[t],a=n.images[o.source];let r=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(r=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,o.source,r);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class un{constructor(e){this.name=_.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(a){const r=n.byteOffset||0,c=n.byteLength||0,h=n.count,l=n.byteStride,d=new Uint8Array(a,r,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(h,l,d,n.mode,n.filter).then(function(m){return m.buffer}):o.ready.then(function(){const m=new ArrayBuffer(h*l);return o.decodeGltfBuffer(new Uint8Array(m),h,l,d,n.mode,n.filter),m})})}else return null}}class mn{constructor(e){this.name=_.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const c of n.primitives)if(c.mode!==U.TRIANGLES&&c.mode!==U.TRIANGLE_STRIP&&c.mode!==U.TRIANGLE_FAN&&c.mode!==void 0)return null;const o=s.extensions[this.name].attributes,a=[],r={};for(const c in o)a.push(this.parser.getDependency("accessor",o[c]).then(h=>(r[c]=h,r[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(c=>{const h=c.pop(),l=h.isGroup?h.children:[h],d=c[0].count,m=[];for(const p of l){const g=new ee,b=new C,y=new W,w=new C(1,1,1),S=new $t(p.geometry,p.material,d);for(let A=0;A<d;A++)r.TRANSLATION&&b.fromBufferAttribute(r.TRANSLATION,A),r.ROTATION&&y.fromBufferAttribute(r.ROTATION,A),r.SCALE&&w.fromBufferAttribute(r.SCALE,A),S.setMatrixAt(A,g.compose(b,y,w));for(const A in r)A!=="TRANSLATION"&&A!=="ROTATION"&&A!=="SCALE"&&p.geometry.setAttribute(A,r[A]);bt.prototype.copy.call(S,p),S.frustumCulled=!1,this.parser.assignFinalMaterial(S),m.push(S)}return h.isGroup?(h.clear(),h.add(...m),h):m[0]}))}}const It="glTF",le=12,st={JSON:1313821514,BIN:5130562};class fn{constructor(e){this.name=_.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,le);if(this.header={magic:J.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==It)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-le,n=new DataView(e,le);let i=0;for(;i<s;){const o=n.getUint32(i,!0);i+=4;const a=n.getUint32(i,!0);if(i+=4,a===st.JSON){const r=new Uint8Array(e,le+i,o);this.content=J.decodeText(r)}else if(a===st.BIN){const r=le+i;this.body=e.slice(r,r+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class pn{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=_.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,i=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},r={},c={};for(const h in o){const l=Oe[h]||h.toLowerCase();a[l]=o[h]}for(const h in e.attributes){const l=Oe[h]||h.toLowerCase();if(o[h]!==void 0){const d=s.accessors[e.attributes[h]],m=ae[d.componentType];c[l]=m.name,r[l]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(l){n.decodeDracoFile(h,function(d){for(const m in d.attributes){const p=d.attributes[m],g=r[m];g!==void 0&&(p.normalized=g)}l(d)},a,c)})})}}class gn{constructor(){this.name=_.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class yn{constructor(){this.name=_.KHR_MESH_QUANTIZATION}}class Vt extends xs{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,i=e*n*3+n;for(let o=0;o!==n;o++)t[o]=s[i+o];return t}interpolate_(e,t,s,n){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,r=a*2,c=a*3,h=n-t,l=(s-t)/h,d=l*l,m=d*l,p=e*c,g=p-c,b=-2*m+3*d,y=m-d,w=1-b,S=y-d+l;for(let A=0;A!==a;A++){const T=o[g+A+a],E=o[g+A+r]*h,R=o[p+A+a],V=o[p+A]*h;i[A]=w*T+S*E+b*R+y*V}return i}}const bn=new W;class wn extends Vt{interpolate_(e,t,s,n){const i=super.interpolate_(e,t,s,n);return bn.fromArray(i).normalize().toArray(i),i}}const U={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},ae={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},nt={9728:as,9729:Tt,9984:cs,9985:ls,9986:hs,9987:xt},it={33071:ds,33648:us,10497:De},_e={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Oe={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Y={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Tn={CUBICSPLINE:void 0,LINEAR:_t,STEP:ms},Re={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function xn(f){return f.DefaultMaterial===void 0&&(f.DefaultMaterial=new ke({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:fs})),f.DefaultMaterial}function he(f,e,t){for(const s in t.extensions)f[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Q(f,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(f.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function An(f,e,t){let s=!1,n=!1,i=!1;for(let c=0,h=e.length;c<h;c++){const l=e[c];if(l.POSITION!==void 0&&(s=!0),l.NORMAL!==void 0&&(n=!0),l.COLOR_0!==void 0&&(i=!0),s&&n&&i)break}if(!s&&!n&&!i)return Promise.resolve(f);const o=[],a=[],r=[];for(let c=0,h=e.length;c<h;c++){const l=e[c];if(s){const d=l.POSITION!==void 0?t.getDependency("accessor",l.POSITION):f.attributes.position;o.push(d)}if(n){const d=l.NORMAL!==void 0?t.getDependency("accessor",l.NORMAL):f.attributes.normal;a.push(d)}if(i){const d=l.COLOR_0!==void 0?t.getDependency("accessor",l.COLOR_0):f.attributes.color;r.push(d)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(r)]).then(function(c){const h=c[0],l=c[1],d=c[2];return s&&(f.morphAttributes.position=h),n&&(f.morphAttributes.normal=l),i&&(f.morphAttributes.color=d),f.morphTargetsRelative=!0,f})}function En(f,e){if(f.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)f.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(f.morphTargetInfluences.length===t.length){f.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)f.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Sn(f){const e=f.extensions&&f.extensions[_.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+ot(e.attributes):t=f.indices+":"+ot(f.attributes)+":"+f.mode,t}function ot(f){let e="";const t=Object.keys(f).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+f[t[s]]+";";return e}function Ie(f){switch(f){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Ln(f){return f.search(/\.jpe?g($|\?)/i)>0||f.search(/^data\:image\/jpeg/)===0?"image/jpeg":f.search(/\.webp($|\?)/i)>0||f.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Mn=new ee;class _n{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new $s,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=!1,i=-1;typeof navigator<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,i=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||n&&i<98?this.textureLoader=new wt(this.options.manager):this.textureLoader=new Jt(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Ve(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(o){const a={scene:o[0][n.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:n.asset,parser:s,userData:{}};he(i,a,n),Q(a,n),Promise.all(s._invokeAll(function(r){return r.afterRoot&&r.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n].joints;for(let a=0,r=o.length;a<r;a++)e[o[a]].isBone=!0}for(let n=0,i=e.length;n<i;n++){const o=e[n];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(s[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),i=(o,a)=>{const r=this.associations.get(o);r!=null&&this.associations.set(a,r);for(const[c,h]of o.children.entries())i(h,a.children[c])};return i(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,o){return s.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[_.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,o){s.load(J.resolveURL(t.uri,n.path),i,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const o=_e[n.type],a=ae[n.componentType],r=n.normalized===!0,c=new a(n.count*o);return Promise.resolve(new de(c,o,r))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(o){const a=o[0],r=_e[n.type],c=ae[n.componentType],h=c.BYTES_PER_ELEMENT,l=h*r,d=n.byteOffset||0,m=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,p=n.normalized===!0;let g,b;if(m&&m!==l){const y=Math.floor(d/m),w="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+y+":"+n.count;let S=t.cache.get(w);S||(g=new c(a,y*m,n.count*m/h),S=new es(g,m/h),t.cache.add(w,S)),b=new ps(S,r,d%m/h,p)}else a===null?g=new c(n.count*r):g=new c(a,d,n.count*r),b=new de(g,r,p);if(n.sparse!==void 0){const y=_e.SCALAR,w=ae[n.sparse.indices.componentType],S=n.sparse.indices.byteOffset||0,A=n.sparse.values.byteOffset||0,T=new w(o[1],S,n.sparse.count*y),E=new c(o[2],A,n.sparse.count*r);a!==null&&(b=new de(b.array.slice(),b.itemSize,b.normalized));for(let R=0,V=T.length;R<V;R++){const L=T[R];if(b.setX(L,E[R*r]),r>=2&&b.setY(L,E[R*r+1]),r>=3&&b.setZ(L,E[R*r+2]),r>=4&&b.setW(L,E[R*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return b})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,o=t.images[i];let a=this.textureLoader;if(o.uri){const r=s.manager.getHandler(o.uri);r!==null&&(a=r)}return this.loadTextureImage(e,i,a)}loadTextureImage(e,t,s){const n=this,i=this.json,o=i.textures[e],a=i.images[t],r=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[r])return this.textureCache[r];const c=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=o.name||a.name||"";const d=(i.samplers||{})[o.sampler]||{};return h.magFilter=nt[d.magFilter]||Tt,h.minFilter=nt[d.minFilter]||xt,h.wrapS=it[d.wrapS]||De,h.wrapT=it[d.wrapT]||De,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[r]=c,c}loadImageSource(e,t){const s=this,n=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(l=>l.clone());const o=n.images[e],a=self.URL||self.webkitURL;let r=o.uri||"",c=!1;if(o.bufferView!==void 0)r=s.getDependency("bufferView",o.bufferView).then(function(l){c=!0;const d=new Blob([l],{type:o.mimeType});return r=a.createObjectURL(d),r});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(r).then(function(l){return new Promise(function(d,m){let p=d;t.isImageBitmapLoader===!0&&(p=function(g){const b=new Ze(g);b.needsUpdate=!0,d(b)}),t.load(J.resolveURL(l,i.path),p,void 0,m)})}).then(function(l){return c===!0&&a.revokeObjectURL(r),l.userData.mimeType=o.mimeType||Ln(o.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",r),l});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const i=this;return this.getDependency("texture",s.index).then(function(o){if(!o)return null;if(s.texCoord!==void 0&&s.texCoord!=0&&!(t==="aoMap"&&s.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+s.texCoord+" for texture "+t+" not yet supported."),i.extensions[_.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[_.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const r=i.associations.get(o);o=i.extensions[_.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),i.associations.set(o,r)}}return n!==void 0&&(o.encoding=n),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let r=this.cache.get(a);r||(r=new oe,ue.prototype.copy.call(r,s),r.color.copy(s.color),r.map=s.map,r.sizeAttenuation=!1,this.cache.add(a,r)),s=r}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let r=this.cache.get(a);r||(r=new re,ue.prototype.copy.call(r,s),r.color.copy(s.color),this.cache.add(a,r)),s=r}if(n||i||o){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let r=this.cache.get(a);r||(r=s.clone(),i&&(r.vertexColors=!0),o&&(r.flatShading=!0),n&&(r.normalScale&&(r.normalScale.y*=-1),r.clearcoatNormalScale&&(r.clearcoatNormalScale.y*=-1)),this.cache.add(a,r),this.associations.set(r,this.associations.get(s))),s=r}s.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=s}getMaterialType(){return ke}loadMaterial(e){const t=this,s=this.json,n=this.extensions,i=s.materials[e];let o;const a={},r=i.extensions||{},c=[];if(r[_.KHR_MATERIALS_UNLIT]){const l=n[_.KHR_MATERIALS_UNLIT];o=l.getMaterialType(),c.push(l.extendParams(a,i,t))}else{const l=i.pbrMetallicRoughness||{};if(a.color=new X(1,1,1),a.opacity=1,Array.isArray(l.baseColorFactor)){const d=l.baseColorFactor;a.color.fromArray(d),a.opacity=d[3]}l.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",l.baseColorTexture,fe)),a.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,a.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",l.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",l.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}i.doubleSided===!0&&(a.side=At);const h=i.alphaMode||Re.OPAQUE;if(h===Re.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===Re.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&o!==ie&&(c.push(t.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new B(1,1),i.normalTexture.scale!==void 0)){const l=i.normalTexture.scale;a.normalScale.set(l,l)}return i.occlusionTexture!==void 0&&o!==ie&&(c.push(t.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&o!==ie&&(a.emissive=new X().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&o!==ie&&c.push(t.assignTexture(a,"emissiveMap",i.emissiveTexture,fe)),Promise.all(c).then(function(){const l=new o(a);return i.name&&(l.name=i.name),Q(l,i),t.associations.set(l,{materials:e}),i.extensions&&he(n,l,i),l})}createUniqueName(e){const t=ts.sanitizeNodeName(e||"");let s=t;for(let n=1;this.nodeNamesUsed[s];++n)s=t+"_"+n;return this.nodeNamesUsed[s]=!0,s}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function i(a){return s[_.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(r){return rt(r,a,t)})}const o=[];for(let a=0,r=e.length;a<r;a++){const c=e[a],h=Sn(c),l=n[h];if(l)o.push(l.promise);else{let d;c.extensions&&c.extensions[_.KHR_DRACO_MESH_COMPRESSION]?d=i(c):d=rt(new ce,c,t),n[h]={primitive:c,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,s=this.json,n=this.extensions,i=s.meshes[e],o=i.primitives,a=[];for(let r=0,c=o.length;r<c;r++){const h=o[r].material===void 0?xn(this.cache):this.getDependency("material",o[r].material);a.push(h)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(r){const c=r.slice(0,r.length-1),h=r[r.length-1],l=[];for(let m=0,p=h.length;m<p;m++){const g=h[m],b=o[m];let y;const w=c[m];if(b.mode===U.TRIANGLES||b.mode===U.TRIANGLE_STRIP||b.mode===U.TRIANGLE_FAN||b.mode===void 0)y=i.isSkinnedMesh===!0?new ss(g,w):new pe(g,w),y.isSkinnedMesh===!0&&!y.geometry.attributes.skinWeight.normalized&&y.normalizeSkinWeights(),b.mode===U.TRIANGLE_STRIP?y.geometry=at(y.geometry,gs):b.mode===U.TRIANGLE_FAN&&(y.geometry=at(y.geometry,Rt));else if(b.mode===U.LINES)y=new Te(g,w);else if(b.mode===U.LINE_STRIP)y=new Et(g,w);else if(b.mode===U.LINE_LOOP)y=new ns(g,w);else if(b.mode===U.POINTS)y=new me(g,w);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+b.mode);Object.keys(y.geometry.morphAttributes).length>0&&En(y,i),y.name=t.createUniqueName(i.name||"mesh_"+e),Q(y,i),b.extensions&&he(n,y,b),t.assignFinalMaterial(y),l.push(y)}for(let m=0,p=l.length;m<p;m++)t.associations.set(l[m],{meshes:e,primitives:m});if(l.length===1)return l[0];const d=new be;t.associations.set(d,{meshes:e});for(let m=0,p=l.length;m<p;m++)d.add(l[m]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new St(Lt.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new Mt(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Q(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,i=t.joints.length;n<i;n++)s.push(this.getDependency("node",t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const i=n.pop(),o=n,a=[],r=[];for(let c=0,h=o.length;c<h;c++){const l=o[c];if(l){a.push(l);const d=new ee;i!==null&&d.fromArray(i.array,c*16),r.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new is(a,r)})}loadAnimation(e){const s=this.json.animations[e],n=[],i=[],o=[],a=[],r=[];for(let c=0,h=s.channels.length;c<h;c++){const l=s.channels[c],d=s.samplers[l.sampler],m=l.target,p=m.node,g=s.parameters!==void 0?s.parameters[d.input]:d.input,b=s.parameters!==void 0?s.parameters[d.output]:d.output;n.push(this.getDependency("node",p)),i.push(this.getDependency("accessor",g)),o.push(this.getDependency("accessor",b)),a.push(d),r.push(m)}return Promise.all([Promise.all(n),Promise.all(i),Promise.all(o),Promise.all(a),Promise.all(r)]).then(function(c){const h=c[0],l=c[1],d=c[2],m=c[3],p=c[4],g=[];for(let y=0,w=h.length;y<w;y++){const S=h[y],A=l[y],T=d[y],E=m[y],R=p[y];if(S===void 0)continue;S.updateMatrix();let V;switch(Y[R.path]){case Y.weights:V=bs;break;case Y.rotation:V=$e;break;case Y.position:case Y.scale:default:V=ys;break}const L=S.name?S.name:S.uuid,P=E.interpolation!==void 0?Tn[E.interpolation]:_t,I=[];Y[R.path]===Y.weights?S.traverse(function(M){M.morphTargetInfluences&&I.push(M.name?M.name:M.uuid)}):I.push(L);let D=T.array;if(T.normalized){const M=Ie(D.constructor),O=new Float32Array(D.length);for(let N=0,j=D.length;N<j;N++)O[N]=D[N]*M;D=O}for(let M=0,O=I.length;M<O;M++){const N=new V(I[M]+"."+Y[R.path],A.array,D,P);E.interpolation==="CUBICSPLINE"&&(N.createInterpolant=function(H){const $=this instanceof $e?wn:Vt;return new $(this.times,this.values,this.getValueSize()/3,H)},N.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),g.push(N)}}const b=s.name?s.name:"animation_"+e;return new os(b,void 0,g)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(i){const o=s._getNodeRef(s.meshCache,n.mesh,i);return n.weights!==void 0&&o.traverse(function(a){if(!!a.isMesh)for(let r=0,c=n.weights.length;r<c;r++)a.morphTargetInfluences[r]=n.weights[r]}),o})}loadNode(e){const t=this.json,s=this.extensions,n=this,i=t.nodes[e],o=i.name?n.createUniqueName(i.name):"";return function(){const a=[],r=n._invokeOne(function(d){return d.createNodeMesh&&d.createNodeMesh(e)});r&&a.push(r),i.camera!==void 0&&a.push(n.getDependency("camera",i.camera).then(function(d){return n._getNodeRef(n.cameraCache,i.camera,d)})),n._invokeAll(function(d){return d.createNodeAttachment&&d.createNodeAttachment(e)}).forEach(function(d){a.push(d)});const c=[],h=i.children||[];for(let d=0,m=h.length;d<m;d++)c.push(n.getDependency("node",h[d]));const l=i.skin===void 0?Promise.resolve(null):n.getDependency("skin",i.skin);return Promise.all([Promise.all(a),Promise.all(c),l])}().then(function(a){const r=a[0],c=a[1],h=a[2];let l;if(i.isBone===!0?l=new rs:r.length>1?l=new be:r.length===1?l=r[0]:l=new bt,l!==r[0])for(let d=0,m=r.length;d<m;d++)l.add(r[d]);if(i.name&&(l.userData.name=i.name,l.name=o),Q(l,i),i.extensions&&he(s,l,i),i.matrix!==void 0){const d=new ee;d.fromArray(i.matrix),l.applyMatrix4(d)}else i.translation!==void 0&&l.position.fromArray(i.translation),i.rotation!==void 0&&l.quaternion.fromArray(i.rotation),i.scale!==void 0&&l.scale.fromArray(i.scale);n.associations.has(l)||n.associations.set(l,{}),n.associations.get(l).nodes=e,h!==null&&l.traverse(function(d){!d.isSkinnedMesh||d.bind(h,Mn)});for(let d=0,m=c.length;d<m;d++)l.add(c[d]);return l})}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,i=new be;s.name&&(i.name=n.createUniqueName(s.name)),Q(i,s),s.extensions&&he(t,i,s);const o=s.nodes||[],a=[];for(let r=0,c=o.length;r<c;r++)a.push(n.getDependency("node",o[r]));return Promise.all(a).then(function(r){for(let h=0,l=r.length;h<l;h++)i.add(r[h]);const c=h=>{const l=new Map;for(const[d,m]of n.associations)(d instanceof ue||d instanceof Ze)&&l.set(d,m);return h.traverse(d=>{const m=n.associations.get(d);m!=null&&l.set(d,m)}),l};return n.associations=c(i),i})}}function Rn(f,e,t){const s=e.attributes,n=new ws;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],r=a.min,c=a.max;if(r!==void 0&&c!==void 0){if(n.set(new C(r[0],r[1],r[2]),new C(c[0],c[1],c[2])),a.normalized){const h=Ie(ae[a.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const a=new C,r=new C;for(let c=0,h=i.length;c<h;c++){const l=i[c];if(l.POSITION!==void 0){const d=t.json.accessors[l.POSITION],m=d.min,p=d.max;if(m!==void 0&&p!==void 0){if(r.setX(Math.max(Math.abs(m[0]),Math.abs(p[0]))),r.setY(Math.max(Math.abs(m[1]),Math.abs(p[1]))),r.setZ(Math.max(Math.abs(m[2]),Math.abs(p[2]))),d.normalized){const g=Ie(ae[d.componentType]);r.multiplyScalar(g)}a.max(r)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}f.boundingBox=n;const o=new Ts;n.getCenter(o.center),o.radius=n.min.distanceTo(n.max)/2,f.boundingSphere=o}function rt(f,e,t){const s=e.attributes,n=[];function i(o,a){return t.getDependency("accessor",o).then(function(r){f.setAttribute(a,r)})}for(const o in s){const a=Oe[o]||o.toLowerCase();a in f.attributes||n.push(i(s[o],a))}if(e.indices!==void 0&&!f.index){const o=t.getDependency("accessor",e.indices).then(function(a){f.setIndex(a)});n.push(o)}return Q(f,e),Rn(f,e,t),Promise.all(n).then(function(){return e.targets!==void 0?An(f,e.targets,t):f})}function at(f,e){let t=f.getIndex();if(t===null){const o=[],a=f.getAttribute("position");if(a!==void 0){for(let r=0;r<a.count;r++)o.push(r);f.setIndex(o),t=f.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),f}const s=t.count-2,n=[];if(e===Rt)for(let o=1;o<=s;o++)n.push(t.getX(0)),n.push(t.getX(o)),n.push(t.getX(o+1));else for(let o=0;o<s;o++)o%2===0?(n.push(t.getX(o)),n.push(t.getX(o+1)),n.push(t.getX(o+2))):(n.push(t.getX(o+2)),n.push(t.getX(o+1)),n.push(t.getX(o)));n.length/3!==s&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=f.clone();return i.setIndex(n),i}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Cn extends pe{constructor(e,t){super(e,t),this.isExtendedMesh=!0,this.isGroup=!1,this.vector3=new C,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class kt{constructor(){this._defaultMaterial=new Ct({color:13421772})}get(){return this._defaultMaterial}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Pn{constructor(e){this.scene=e,this.isHeadless=e==="headless",this.defaultMaterial=new kt}get make(){return{plane:(e={},t={})=>this.makePlane(e,t),box:(e={},t={})=>this.makeBox(e,t),sphere:(e={},t={})=>this.makeSphere(e,t),cylinder:(e={},t={})=>this.makeCylinder(e,t),cone:(e={},t={})=>this.makeCone(e,t),torus:(e={},t={})=>this.makeTorus(e,t),extrude:(e,t={})=>this.makeExtrude(e,t)}}get add(){return{mesh:e=>this.addMesh(e),existing:e=>this.addExisting(e),plane:(e={},t={})=>this.addPlane(e,t),box:(e={},t={})=>this.addBox(e,t),ground:(e,t={})=>this.addGround(e,t),sphere:(e={},t={})=>this.addSphere(e,t),cylinder:(e={},t={})=>this.addCylinder(e,t),cone:(e={},t={})=>this.addCone(e,t),torus:(e={},t={})=>this.addTorus(e,t),extrude:(e,t={})=>this.addExtrude(e,t),material:(e={})=>this.addMaterial(e)}}addExisting(...e){this.scene!=="headless"&&this.scene.add(...e)}addMesh(e){if(Array.isArray(e))for(let t=0;t<e.length;t++)this.addExisting(e[t]);else this.addExisting(e);return this}createMesh(e,t,s){const{x:n=0,y:i=0,z:o=0}=s;let a;switch(!Array.isArray(t)&&t.type){case"LineBasicMaterial":a=new Et(e,t);break;case"PointsMaterial":a=new me(e,t);break;default:a=new Cn(e,t);break}return a.position.set(n,i,o),a.castShadow=a.receiveShadow=!0,a}makeExtrude(e,t){const{x:s,y:n,z:i,name:o,shape:a,autoCenter:r=!0,breakable:c=!1,...h}=e,{depth:l=1,bevelEnabled:d=!1}=h,m=new As(a,{depth:l,bevelEnabled:d,...h}),p=this.addMaterial(t),g=this.createMesh(m,p,{x:s,y:n,z:i});return r&&g.geometry.center(),g.name=o||`body_id_${g.id}`,g.shape="extrude",g}addExtrude(e,t={}){const s=this.makeExtrude(e,t);return this.addExisting(s),s}makePlane(e,t){const{x:s,y:n,z:i,name:o,breakable:a=!1,...r}=e,c=new Es(r.width||1,r.height||1,r.widthSegments||1,r.heightSegments||1),h=this.addMaterial(t);h.side=At;const l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="plane",l}addPlane(e,t){const s=this.makePlane(e,t);return this.addExisting(s),s}makeSphere(e,t){const{x:s,y:n,z:i,name:o,breakable:a=!1,...r}=e,c=new Ss(r.radius||1,r.widthSegments||16,r.heightSegments||12,r.phiStart||void 0,r.phiLength||void 0,r.thetaStart||void 0,r.thetaLength||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="sphere",l}addSphere(e={},t={}){const s=this.makeSphere(e,t);return this.addExisting(s),s}makeBox(e,t){const{x:s,y:n,z:i,name:o,breakable:a=!1,...r}=e,c=new Ls(r.width||1,r.height||1,r.depth||1,r.widthSegments||void 0,r.heightSegments||void 0,r.depthSegments||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="box",l}addBox(e={},t={}){const s=this.makeBox(e,t);return this.addExisting(s),s}addGround(e,t={}){const s=this.makeBox(e,t);return s.rotateX(Lt.degToRad(90)),this.addExisting(s),s}makeCylinder(e={},t={}){const{x:s,y:n,z:i,name:o,breakable:a=!1,...r}=e,c=new Ms(r.radiusTop||1,r.radiusBottom||1,r.height||1,r.radiusSegments||void 0,r.heightSegments||void 0,r.openEnded||void 0,r.thetaStart||void 0,r.thetaLength||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="cylinder",l}addCylinder(e={},t={}){const s=this.makeCylinder(e,t);return this.addExisting(s),s}makeCone(e={},t={}){const{x:s,y:n,z:i,name:o,breakable:a=!1,...r}=e,c=new _s(r.radius||1,r.height||1,r.radiusSegments||8,r.heightSegments||1,r.openEnded||!1,r.thetaStart||0,r.thetaLength||2*Math.PI),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="cone",l}addCone(e={},t={}){const s=this.makeCone(e,t);return this.addExisting(s),s}makeTorus(e={},t={}){const{x:s,y:n,z:i,name:o,breakable:a=!1,...r}=e,c=new Rs(r.radius||void 0,r.tube||void 0,r.radialSegments||void 0,r.tubularSegments||void 0,r.arc||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=o||`body_id_${l.id}`,l.shape="torus",l}addTorus(e={},t={}){const s=this.makeTorus(e,t);return this.addExisting(s),s}addMaterial(e={}){const t=Object.keys(e)[0];let s;if(this.scene==="headless")return this.defaultMaterial.get();switch(t){case"basic":s=new ie(e.basic);break;case"normal":s=new Ps(e.normal);break;case"standard":s=new ke(e.standard);break;case"lambert":s=new Ct(e.lambert);break;case"phong":s=new Pt(e.phong);break;case"physical":typeof e.physical<"u"?s=new Z(e.physical):(we("You need to pass parameters to the physical material. (Fallback to default material)"),s=this.defaultMaterial.get());break;case"toon":s=new Cs(e.toon);break;case"line":s=new re(e.line);break;case"points":s=new oe(e.points);break;case"custom":s=e.custom||this.defaultMaterial.get();break;default:s=this.defaultMaterial.get();break}return s}}const ct={type:"change"},Ce={type:"start"},lt={type:"end"};class Dn extends Ds{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new C,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:se.ROTATE,MIDDLE:se.DOLLY,RIGHT:se.PAN},this.touches={ONE:ne.ROTATE,TWO:ne.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(u){u.addEventListener("keydown",We),this._domElementKeyEvents=u},this.saveState=function(){s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=function(){s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(ct),s.update(),i=n.NONE},this.update=function(){const u=new C,x=new W().setFromUnitVectors(e.up,new C(0,1,0)),k=x.clone().invert(),v=new C,z=new W,te=2*Math.PI;return function(){const Qe=s.object.position;u.copy(Qe).sub(s.target),u.applyQuaternion(x),a.setFromVector3(u),s.autoRotate&&i===n.NONE&&L(R()),s.enableDamping?(a.theta+=r.theta*s.dampingFactor,a.phi+=r.phi*s.dampingFactor):(a.theta+=r.theta,a.phi+=r.phi);let G=s.minAzimuthAngle,K=s.maxAzimuthAngle;return isFinite(G)&&isFinite(K)&&(G<-Math.PI?G+=te:G>Math.PI&&(G-=te),K<-Math.PI?K+=te:K>Math.PI&&(K-=te),G<=K?a.theta=Math.max(G,Math.min(K,a.theta)):a.theta=a.theta>(G+K)/2?Math.max(G,a.theta):Math.min(K,a.theta)),a.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=c,a.radius=Math.max(s.minDistance,Math.min(s.maxDistance,a.radius)),s.enableDamping===!0?s.target.addScaledVector(h,s.dampingFactor):s.target.add(h),u.setFromSpherical(a),u.applyQuaternion(k),Qe.copy(s.target).add(u),s.object.lookAt(s.target),s.enableDamping===!0?(r.theta*=1-s.dampingFactor,r.phi*=1-s.dampingFactor,h.multiplyScalar(1-s.dampingFactor)):(r.set(0,0,0),h.set(0,0,0)),c=1,l||v.distanceToSquared(s.object.position)>o||8*(1-z.dot(s.object.quaternion))>o?(s.dispatchEvent(ct),v.copy(s.object.position),z.copy(s.object.quaternion),l=!1,!0):!1}}(),this.dispose=function(){s.domElement.removeEventListener("contextmenu",Xe),s.domElement.removeEventListener("pointerdown",je),s.domElement.removeEventListener("pointercancel",Ge),s.domElement.removeEventListener("wheel",Ke),s.domElement.removeEventListener("pointermove",Ee),s.domElement.removeEventListener("pointerup",Se),s._domElementKeyEvents!==null&&s._domElementKeyEvents.removeEventListener("keydown",We)};const s=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=n.NONE;const o=1e-6,a=new Je,r=new Je;let c=1;const h=new C;let l=!1;const d=new B,m=new B,p=new B,g=new B,b=new B,y=new B,w=new B,S=new B,A=new B,T=[],E={};function R(){return 2*Math.PI/60/60*s.autoRotateSpeed}function V(){return Math.pow(.95,s.zoomSpeed)}function L(u){r.theta-=u}function P(u){r.phi-=u}const I=function(){const u=new C;return function(k,v){u.setFromMatrixColumn(v,0),u.multiplyScalar(-k),h.add(u)}}(),D=function(){const u=new C;return function(k,v){s.screenSpacePanning===!0?u.setFromMatrixColumn(v,1):(u.setFromMatrixColumn(v,0),u.crossVectors(s.object.up,u)),u.multiplyScalar(k),h.add(u)}}(),M=function(){const u=new C;return function(k,v){const z=s.domElement;if(s.object.isPerspectiveCamera){const te=s.object.position;u.copy(te).sub(s.target);let ge=u.length();ge*=Math.tan(s.object.fov/2*Math.PI/180),I(2*k*ge/z.clientHeight,s.object.matrix),D(2*v*ge/z.clientHeight,s.object.matrix)}else s.object.isOrthographicCamera?(I(k*(s.object.right-s.object.left)/s.object.zoom/z.clientWidth,s.object.matrix),D(v*(s.object.top-s.object.bottom)/s.object.zoom/z.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}}();function O(u){s.object.isPerspectiveCamera?c/=u:s.object.isOrthographicCamera?(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom*u)),s.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function N(u){s.object.isPerspectiveCamera?c*=u:s.object.isOrthographicCamera?(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/u)),s.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function j(u){d.set(u.clientX,u.clientY)}function H(u){w.set(u.clientX,u.clientY)}function $(u){g.set(u.clientX,u.clientY)}function vt(u){m.set(u.clientX,u.clientY),p.subVectors(m,d).multiplyScalar(s.rotateSpeed);const x=s.domElement;L(2*Math.PI*p.x/x.clientHeight),P(2*Math.PI*p.y/x.clientHeight),d.copy(m),s.update()}function Nt(u){S.set(u.clientX,u.clientY),A.subVectors(S,w),A.y>0?O(V()):A.y<0&&N(V()),w.copy(S),s.update()}function Bt(u){b.set(u.clientX,u.clientY),y.subVectors(b,g).multiplyScalar(s.panSpeed),M(y.x,y.y),g.copy(b),s.update()}function Ft(u){u.deltaY<0?N(V()):u.deltaY>0&&O(V()),s.update()}function Ut(u){let x=!1;switch(u.code){case s.keys.UP:u.ctrlKey||u.metaKey||u.shiftKey?P(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):M(0,s.keyPanSpeed),x=!0;break;case s.keys.BOTTOM:u.ctrlKey||u.metaKey||u.shiftKey?P(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):M(0,-s.keyPanSpeed),x=!0;break;case s.keys.LEFT:u.ctrlKey||u.metaKey||u.shiftKey?L(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):M(s.keyPanSpeed,0),x=!0;break;case s.keys.RIGHT:u.ctrlKey||u.metaKey||u.shiftKey?L(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):M(-s.keyPanSpeed,0),x=!0;break}x&&(u.preventDefault(),s.update())}function Ne(){if(T.length===1)d.set(T[0].pageX,T[0].pageY);else{const u=.5*(T[0].pageX+T[1].pageX),x=.5*(T[0].pageY+T[1].pageY);d.set(u,x)}}function Be(){if(T.length===1)g.set(T[0].pageX,T[0].pageY);else{const u=.5*(T[0].pageX+T[1].pageX),x=.5*(T[0].pageY+T[1].pageY);g.set(u,x)}}function Fe(){const u=T[0].pageX-T[1].pageX,x=T[0].pageY-T[1].pageY,k=Math.sqrt(u*u+x*x);w.set(0,k)}function zt(){s.enableZoom&&Fe(),s.enablePan&&Be()}function Ht(){s.enableZoom&&Fe(),s.enableRotate&&Ne()}function Ue(u){if(T.length==1)m.set(u.pageX,u.pageY);else{const k=Le(u),v=.5*(u.pageX+k.x),z=.5*(u.pageY+k.y);m.set(v,z)}p.subVectors(m,d).multiplyScalar(s.rotateSpeed);const x=s.domElement;L(2*Math.PI*p.x/x.clientHeight),P(2*Math.PI*p.y/x.clientHeight),d.copy(m)}function ze(u){if(T.length===1)b.set(u.pageX,u.pageY);else{const x=Le(u),k=.5*(u.pageX+x.x),v=.5*(u.pageY+x.y);b.set(k,v)}y.subVectors(b,g).multiplyScalar(s.panSpeed),M(y.x,y.y),g.copy(b)}function He(u){const x=Le(u),k=u.pageX-x.x,v=u.pageY-x.y,z=Math.sqrt(k*k+v*v);S.set(0,z),A.set(0,Math.pow(S.y/w.y,s.zoomSpeed)),O(A.y),w.copy(S)}function jt(u){s.enableZoom&&He(u),s.enablePan&&ze(u)}function Gt(u){s.enableZoom&&He(u),s.enableRotate&&Ue(u)}function je(u){s.enabled!==!1&&(T.length===0&&(s.domElement.setPointerCapture(u.pointerId),s.domElement.addEventListener("pointermove",Ee),s.domElement.addEventListener("pointerup",Se)),qt(u),u.pointerType==="touch"?Xt(u):Kt(u))}function Ee(u){s.enabled!==!1&&(u.pointerType==="touch"?Yt(u):Wt(u))}function Se(u){Ye(u),T.length===0&&(s.domElement.releasePointerCapture(u.pointerId),s.domElement.removeEventListener("pointermove",Ee),s.domElement.removeEventListener("pointerup",Se)),s.dispatchEvent(lt),i=n.NONE}function Ge(u){Ye(u)}function Kt(u){let x;switch(u.button){case 0:x=s.mouseButtons.LEFT;break;case 1:x=s.mouseButtons.MIDDLE;break;case 2:x=s.mouseButtons.RIGHT;break;default:x=-1}switch(x){case se.DOLLY:if(s.enableZoom===!1)return;H(u),i=n.DOLLY;break;case se.ROTATE:if(u.ctrlKey||u.metaKey||u.shiftKey){if(s.enablePan===!1)return;$(u),i=n.PAN}else{if(s.enableRotate===!1)return;j(u),i=n.ROTATE}break;case se.PAN:if(u.ctrlKey||u.metaKey||u.shiftKey){if(s.enableRotate===!1)return;j(u),i=n.ROTATE}else{if(s.enablePan===!1)return;$(u),i=n.PAN}break;default:i=n.NONE}i!==n.NONE&&s.dispatchEvent(Ce)}function Wt(u){switch(i){case n.ROTATE:if(s.enableRotate===!1)return;vt(u);break;case n.DOLLY:if(s.enableZoom===!1)return;Nt(u);break;case n.PAN:if(s.enablePan===!1)return;Bt(u);break}}function Ke(u){s.enabled===!1||s.enableZoom===!1||i!==n.NONE||(u.preventDefault(),s.dispatchEvent(Ce),Ft(u),s.dispatchEvent(lt))}function We(u){s.enabled===!1||s.enablePan===!1||Ut(u)}function Xt(u){switch(qe(u),T.length){case 1:switch(s.touches.ONE){case ne.ROTATE:if(s.enableRotate===!1)return;Ne(),i=n.TOUCH_ROTATE;break;case ne.PAN:if(s.enablePan===!1)return;Be(),i=n.TOUCH_PAN;break;default:i=n.NONE}break;case 2:switch(s.touches.TWO){case ne.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;zt(),i=n.TOUCH_DOLLY_PAN;break;case ne.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Ht(),i=n.TOUCH_DOLLY_ROTATE;break;default:i=n.NONE}break;default:i=n.NONE}i!==n.NONE&&s.dispatchEvent(Ce)}function Yt(u){switch(qe(u),i){case n.TOUCH_ROTATE:if(s.enableRotate===!1)return;Ue(u),s.update();break;case n.TOUCH_PAN:if(s.enablePan===!1)return;ze(u),s.update();break;case n.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;jt(u),s.update();break;case n.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Gt(u),s.update();break;default:i=n.NONE}}function Xe(u){s.enabled!==!1&&u.preventDefault()}function qt(u){T.push(u)}function Ye(u){delete E[u.pointerId];for(let x=0;x<T.length;x++)if(T[x].pointerId==u.pointerId){T.splice(x,1);return}}function qe(u){let x=E[u.pointerId];x===void 0&&(x=new B,E[u.pointerId]=x),x.set(u.pageX,u.pageY)}function Le(u){const x=u.pointerId===T[0].pointerId?T[1]:T[0];return E[x.pointerId]}s.domElement.addEventListener("contextmenu",Xe),s.domElement.addEventListener("pointerdown",je),s.domElement.addEventListener("pointercancel",Ge),s.domElement.addEventListener("wheel",Ke,{passive:!1}),this.update()}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class On{constructor(e,t){this.physics=e,this.ammo=t,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.impact=[],this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new Dt,this.tmpQuaternion=new W,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new xe,this.name=t.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){typeof this.eventEmitter>"u"&&(this.eventEmitter=new xe)}get needUpdate(){return this._needUpdate}set needUpdate(e){!e&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=e}onUpdateEvent(e,t=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,t?this.eventEmitter.once("update",()=>{e()}):this.eventEmitter.on("update",()=>{e()})}get on(){return{update:e=>this.onUpdateEvent(e),collision:e=>this.onCollision(e)}}get once(){return{update:e=>this.onUpdateEvent(e,!0)}}onCollision(e){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",t=>{const{bodies:s,event:n}=t;s[0].name===this.name?e(s[1],n):s[1].name===this.name&&e(s[0],n)})}transform(){const e=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(e)}refresh(){const e=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(e)}setRotation(e,t,s){const n=this.tmpEuler.set(e,t,s),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(n),this.tmpBtQuaternion.setValue(0,0,0,1);const o=this.tmpBtQuaternion;o.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(o)}get rotation(){let e,t,s;const i=this.physics.worldTransform.getRotation();let o=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());o.w>1&&(o=o.normalize());const a=2*Math.acos(o.w),r=Math.sqrt(1-o.w*o.w);return r<.001?(e=o.x,t=o.y,s=o.z):(e=o.x/r,t=o.y/r,s=o.z/r),{x:e*a,y:t*a,z:s*a}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(e,t,s){this.physics.worldTransform.getOrigin().setValue(e,t,s)}get position(){const e=this.physics.worldTransform;return{x:e.getOrigin().x(),y:e.getOrigin().y(),z:e.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(e){this.tmpBtVector3.setValue(e,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(e){this.tmpBtVector3.setValue(this.velocity.x,e,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(e){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,e),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(e){this.tmpBtVector3.setValue(e,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(e){this.tmpBtVector3.setValue(this.angularVelocity.x,e,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(e){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,e),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(e){this.tmpBtVector3.setValue(e,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(e){this.tmpBtVector3.setValue(0,e,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(e){this.tmpBtVector3.setValue(0,0,e),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(e,t){this.tmpBtVector3.setValue(e.x||0,e.y||0,e.z||0),this.tmpBtVector3_1.setValue(t.x||0,t.y||0,t.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(e){this.ammo.setCollisionFlags(e)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(e){this.ammo.setRestitution(e)}setBounciness(e){this.setRestitution(e)}setFriction(e){this.ammo.setFriction(e)}setDamping(e,t){this.ammo.setDamping(e,t)}setGravity(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(e){this.ammo.setCcdMotionThreshold(e)}setCcdSweptSphereRadius(e){this.ammo.setCcdSweptSphereRadius(e)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class In{constructor(e,t){this.factory=e,this.addExisting=t}addPlane(e={},t={}){const s=this.factory.add.plane(e,t);return this.addExisting(s,e),s}addSphere(e={},t={}){const s=this.factory.add.sphere(e,t);return this.addExisting(s,e),s}addBox(e={},t={}){const s=this.factory.add.box(e,t);return this.addExisting(s,e),s}addGround(e,t={}){const s=this.factory.add.ground(e,t),n={...e,mass:0,collisionFlags:1};return this.addExisting(s,n),s}addCylinder(e={},t={}){const s=this.factory.add.cylinder(e,t);return this.addExisting(s,e),s}addCone(e={},t={}){const s=this.factory.add.cone(e,t);return this.addExisting(s,e),s}addTorus(e={},t={}){const s=this.factory.add.torus(e,t);return this.addExisting(s,e),s}addExtrude(e,t={}){const s=this.factory.add.extrude(e,t);return s.translateX(1),this.addExisting(s),s}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Vn{constructor(e,t){this.worldTransform=e,this.physicsWorld=t,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(e,t=0){return new Ammo.btVector3(typeof(e==null?void 0:e.x)<"u"?e.x:t,typeof(e==null?void 0:e.y)<"u"?e.y:t,typeof(e==null?void 0:e.z)<"u"?e.z:t)}get addConstraints(){return{lock:(e,t,s)=>this.lock(e,t,s),fixed:(e,t,s)=>this.fixed(e,t,s),pointToPoint:(e,t,s,n)=>this.pointToPoint(e,t,s,n),hinge:(e,t,s,n)=>this.hinge(e,t,s,n),slider:(e,t,s={},n)=>this.slider(e,t,s,n),spring:(e,t,s={},n)=>this.spring(e,t,s,n),coneTwist:(e,t,s={frameA:{},frameB:{}},n)=>this.coneTwist(e,t,s,n),dof:(e,t,s,n)=>this.dof(e,t,s,n)}}getTransform(e,t,s={x:0,y:0,z:0},n=!1){s={x:0,y:0,z:0,...s};const i=(a,r)=>{var c=(a.x()-r.x())/2+s.x,h=(a.y()-r.y())/2+s.y,l=(a.z()-r.z())/2+s.z;return new Ammo.btVector3(c,h,l)},o=new Ammo.btTransform;if(o.setIdentity(),n){const a=i(e.getWorldTransform().getOrigin(),t.getWorldTransform().getOrigin()),r=new Ammo.btTransform;r.setIdentity(),r.setOrigin(a);const c=e.getCenterOfMassTransform().inverse().op_mul(t.getWorldTransform());return c.op_mul(r),{transformA:c,transformB:r}}else return o.setOrigin(new Ammo.btVector3(s.x,s.y,s.z)),{transformA:e.getCenterOfMassTransform().inverse().op_mul(t.getWorldTransform()).op_mul(o),transformB:o}}lock(e,t,s=!0){const n={x:0,y:0,z:0};return this.dof(e,t,{angularLowerLimit:n,angularUpperLimit:n},s)}fixed(e,t,s=!0){const n=this.getTransform(e.ammo,t.ammo);n.transformA.setRotation(e.ammo.getWorldTransform().getRotation()),n.transformB.setRotation(t.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(e.ammo,t.ammo,n.transformA,n.transformB);return this.physicsWorld.addConstraint(i,s),i}pointToPoint(e,t,s={},n=!0){const{pivotA:i,pivotB:o}=s,a=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),r=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),c=new Ammo.btPoint2PointConstraint(e.ammo,t.ammo,a,r);return this.physicsWorld.addConstraint(c,n),c}hinge(e,t,s={},n=!0){const{pivotA:i,pivotB:o,axisA:a,axisB:r}=s,c=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),h=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),l=new Ammo.btVector3((a==null?void 0:a.x)||0,(a==null?void 0:a.y)||0,(a==null?void 0:a.z)||0),d=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),m=new Ammo.btHingeConstraint(e.ammo,t.ammo,c,h,l,d,!0);return this.physicsWorld.addConstraint(m,n),m}slider(e,t,s={},n=!0){const i=this.getTransform(e.ammo,t.ammo),{frameA:o={},frameB:a={},linearLowerLimit:r=0,linearUpperLimit:c=0,angularLowerLimit:h=0,angularUpperLimit:l=0}=s,d=i.transformA.getRotation();d.setEulerZYX(o.x||0,o.y||0,o.z||0),i.transformA.setRotation(d);const m=i.transformB.getRotation();m.setEulerZYX(a.x||0,a.y||0,a.z||0),i.transformB.setRotation(m);const p=new Ammo.btSliderConstraint(e.ammo,t.ammo,i.transformA,i.transformB,!0);return p.setLowerLinLimit(r),p.setUpperLinLimit(c),p.setLowerAngLimit(h),p.setUpperAngLimit(l),this.physicsWorld.addConstraint(p,n),p}spring(e,t,s={},n=!0){const{stiffness:i=50,damping:o=.01,angularLock:a=!1,linearLowerLimit:r={},linearUpperLimit:c={},angularLowerLimit:h={},angularUpperLimit:l={},offset:d={},center:m=!1,enableSpring:p=!0}=s,g={x:0,y:0,z:0,...d},b=this.getTransform(e.ammo,t.ammo,g,m),y=new Ammo.btGeneric6DofSpringConstraint(e.ammo,t.ammo,b.transformA,b.transformB,!0);this.tmpBtVector3.setValue(r.x||0,r.y||0,r.z||0),y.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(c.x||0,c.y||0,c.z||0),y.setLinearUpperLimit(this.tmpBtVector3),a?(this.tmpBtVector3.setValue(0,0,0),y.setAngularLowerLimit(this.tmpBtVector3),y.setAngularUpperLimit(this.tmpBtVector3)):(console.log(h,l),y.setAngularLowerLimit(this.toAmmoV3(h,-Math.PI)),y.setAngularUpperLimit(this.toAmmoV3(l,Math.PI)));for(let w=0;w<3;w++)y.enableSpring(w,p),y.setStiffness(w,i),y.setDamping(w,o);return this.physicsWorld.addConstraint(y,n),y}coneTwist(e,t,s,n=!0){const{frameA:i,frameB:o}=s,a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0);const r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),this.getTransform(e.ammo,t.ammo);const c=new Ammo.btConeTwistConstraint(t.ammo,e.ammo,a,r);return c.setAngularOnly(!0),this.physicsWorld.addConstraint(c,n),c}dof(e,t,s={},n=!0){const{offset:i,center:o=!1}=s,a={x:0,y:0,z:0,...i},r=this.getTransform(e.ammo,t.ammo,a,o),c=new Ammo.btGeneric6DofConstraint(e.ammo,t.ammo,r.transformA,r.transformB,!0),{linearLowerLimit:h,linearUpperLimit:l,angularLowerLimit:d,angularUpperLimit:m}=s,p=this.toAmmoV3(h),g=this.toAmmoV3(l),b=this.toAmmoV3(d,-Math.PI),y=this.toAmmoV3(m,Math.PI);return c.setLinearLowerLimit(p),c.setLinearUpperLimit(g),c.setAngularLowerLimit(b),c.setAngularUpperLimit(y),Ammo.destroy(p),Ammo.destroy(g),Ammo.destroy(b),Ammo.destroy(y),this.physicsWorld.addConstraint(c,n),c}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */const kn=(f,e)=>{const{radius:t=1,tube:s=.4,tubularSegments:n=8}=f,i=Math.PI,o=n,a=Math.sqrt(2*s*s-2*s*s*Math.cos(2*i/o)),r=new Ammo.btVector3(s,i/o+.5*a,s),c=new Ammo.btCylinderShape(r);c.setMargin(.05);const h=new Ammo.btCompoundShape,l=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,t,0),m=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let p=0;p<o;p++){const g=p*2*i/o,b=d.rotate(l,g),y=new Ammo.btTransform;m.setRotation(l,g+Math.PI/2),y.setIdentity(),y.setOrigin(b),y.setRotation(m),h.addChildShape(y,c)}return h};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class vn extends xe{addCollider(e,t,s){!e.body||!t.body||(e.body.checkCollisions=!0,t.body.checkCollisions=!0,this.on("collision",n=>{var a,r;const{bodies:i,event:o}=n;((a=i[0])==null?void 0:a.name)&&((r=i[1])==null?void 0:r.name)&&(e==null?void 0:e.name)&&(t==null?void 0:t.name)&&(i[0].name===e.name&&i[1].name===t.name||i[1].name===e.name&&i[0].name===t.name)&&s(o)}))}}const ht={NoDebug:0,DrawWireframe:1,DrawAabb:2,DrawFeaturesText:4,DrawContactPoints:8,NoDeactivation:16,NoHelpText:32,DrawText:64,ProfileTimings:128,EnableSatComparison:256,DisableBulletLCP:512,EnableCCD:1024,DrawConstraints:1<<11,DrawConstraintLimits:1<<12,FastWireframe:1<<13,DrawNormals:1<<14,DrawOnTop:1<<15,MAX_DEBUG_DRAW_MODE:4294967295};class Nn{constructor(e,t,s={}){this.scene=e,this.world=t,this.options=s,this.debugDrawMode=s.debugDrawMode||ht.DrawWireframe;const n=this.debugDrawMode&ht.DrawOnTop||!1,i=s.maxBufferSize||1e6;this.geometry=new ce;const o=new Float32Array(i*3),a=new Float32Array(i*3);this.geometry.setAttribute("position",new de(o,3).setUsage(et)),this.geometry.setAttribute("color",new de(a,3).setUsage(et)),this.index=0;const r=new re({vertexColors:!0,depthTest:!n});this.mesh=new Te(this.geometry,r),n&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){!this.enabled||(this.index!=0&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(e,t,s){const n=Ammo.HEAPF32,i=n[(s+0)/4],o=n[(s+4)/4],a=n[(s+8)/4],r=n[(e+0)/4],c=n[(e+4)/4],h=n[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,r,c,h),this.geometry.attributes.color.setXYZ(this.index++,i,o,a);const l=n[(t+0)/4],d=n[(t+4)/4],m=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,d,m),this.geometry.attributes.color.setXYZ(this.index++,i,o,a)}drawContactPoint(e,t,s,n,i){const o=Ammo.HEAPF32,a=o[(i+0)/4],r=o[(i+4)/4],c=o[(i+8)/4],h=o[(e+0)/4],l=o[(e+4)/4],d=o[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,h,l,d),this.geometry.attributes.color.setXYZ(this.index++,a,r,c);const m=o[(t+0)/4]*s,p=o[(t+4)/4]*s,g=o[(t+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,h+m,l+p,d+g),this.geometry.attributes.color.setXYZ(this.index++,a,r,c)}reportErrorWarning(e){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(e)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(e,t){console.warn("TODO: draw3dText")}setDebugMode(e){this.debugDrawMode=e}getDebugMode(){return this.debugDrawMode}}const Bn=(f,e)=>{typeof window<"u"&&(window.__loadPhysics=!0),Fs(f,()=>{Ammo().then(()=>{e()})})};/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class Fn extends xe{constructor(e,t={}){super(),this.scene=e,this.config=t,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=t.gravity||{x:0,y:-9.81,z:0},this.isHeadless=e==="headless",this.tmpEuler=new Dt,this.tmpQuaternion=new W,this.tmpVector3=new C,this.tmpVector3a=new C,this.tmpMatrix4=new ee,this.tmpMatrix4a=new ee,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new C,this.impactPoint=new C,this.impactNormal=new C,e!=="headless"&&(this.defaultMaterial=new kt),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(e){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=e}destroy(e){var i;const t=Object.keys(e).includes("body")?e.body:e;if(typeof(t==null?void 0:t.ammo)>"u")return;let s=t.ammo.threeObject;const n=s.name;if(n&&s&&(i=s==null?void 0:s.body)!=null&&i.ammo){s.body.isSoftBody?this.physicsWorld.removeSoftBody(s.body.ammo):this.physicsWorld.removeRigidBody(s.body.ammo),s.body.destructor(),s.body=void 0,s.hasBody=!1,delete t.ammo.threeObject;for(let o=0;o<this.rigidBodies.length;o++)this.rigidBodies[o].name===n&&(this.rigidBodies.splice(o,1),o--)}this.scene==="headless"&&s&&(s=null)}setup(){if(this.worldTransform=new Ammo.btTransform,typeof this.config.setupPhysicsWorld=="function"?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),this.scene!=="headless"){this.convexBreaker=new Us,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let e=0;e<500;e++)this.objectsToRemove[e]=null}this.collisionEvents=new vn,this.factory=new Pn(this.scene),this.shapes=new In(this.factory,(e,t)=>this.addExisting(e,t)),this.constraints=new Vn(this.worldTransform,this.physicsWorld),this.scene!=="headless"&&(this.debugDrawer=new Nn(this.scene,this.physicsWorld,{}))}updateDebugger(){this.scene!=="headless"&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const e=this.gravity,{softBodies:t=!1}=this.config;let s;if(!t){const n=new Ammo.btDefaultCollisionConfiguration,i=new Ammo.btCollisionDispatcher(n),o=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(i,o,a,n)}if(t){const n=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,i=new Ammo.btCollisionDispatcher(n),o=new Ammo.btDbvtBroadphase,a=new Ammo.btSequentialImpulseConstraintSolver,r=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(i,o,a,n,r)}return s.setGravity(new Ammo.btVector3(e.x,e.y,e.z)),s}createDebrisFromBreakableObject(e,t){this.scene!=="headless"&&(e.material=t.material,e.shape="hull",e.fragmentDepth=t.fragmentDepth+1,e.name=`${t.name}__DEBRIS_${e.id}`,this.scene.add(e),this.addExisting(e,{autoCenter:!0}),e.body.fractureImpulse=t.body.fractureImpulse,e.body.breakable=!1,setTimeout(()=>{e.body.breakable=!0},2500))}removeDebris(e){this.scene!=="headless"&&(this.scene.remove(e),this.destroy(e))}update(e){this.updatePhysics(e),this.detectCollisions()}updatePhysics(e){const t=e/1e3;this.physicsWorld.stepSimulation(t,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let s=0;s<this.rigidBodies.length;s++){const n=this.rigidBodies[s];n.body.impact=[];const o=n.body.ammo.getMotionState();if(o){if(o.getWorldTransform(this.worldTransform),n.body.didUpdate&&(n.body._emitUpdateEvents&&n.body.eventEmitter.emit("update"),n.body.didUpdate=!1),n.body.ammo.isKinematicObject()&&n.body.needUpdate)n.getWorldQuaternion(this.tmpQuaternion),n.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),o.setWorldTransform(this.worldTransform),n.body.needUpdate=!1;else if(!n.body.skipUpdate){if(!n.body.ammo.isStaticObject()){const a=this.worldTransform.getOrigin(),r=this.worldTransform.getRotation(),c=n.body.offset;if(n.body.ignoreScale)this.tmpVector3a.set(n.scale.x,n.scale.y,n.scale.z);else{const h=n.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(h.x(),h.y(),h.z())}this.tmpVector3.set(a.x()+c.x,a.y()+c.y,a.z()+c.z),this.tmpQuaternion.set(r.x(),r.y(),r.z(),r.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),n.parent?parseInt(Os)>=123?this.tmpMatrix4a.copy(n.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(n.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(n.position,n.quaternion,n.scale)}}}}}detectCollisions(){var n,i;const e=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const t=this.physicsWorld.getDispatcher(),s=t.getNumManifolds();for(let o=0;o<s;o++){const a=t.getManifoldByIndexInternal(o),r=a.getNumContacts(),c=Ammo.castObject(a.getBody0(),Ammo.btRigidBody),h=Ammo.castObject(a.getBody1(),Ammo.btRigidBody),l=c.threeObject,d=h.threeObject;if(!l||!d||c.name===""&&h.name==="")continue;const m=(n=l.body)==null?void 0:n.checkCollisions,p=(i=d.body)==null?void 0:i.checkCollisions,g=l.body.breakable,b=d.body.breakable,y=l.body.fractureImpulse,w=d.body.fractureImpulse,S=m||p,A=g||b;if(typeof l.fragmentDepth>"u"&&(l.fragmentDepth=0),typeof d.fragmentDepth>"u"&&(d.fragmentDepth=0),!S&&!A)continue;let T=!1,E=0,R="start";for(let L=0;L<r;L++){const P=a.getContactPoint(L);if(P.getDistance()<=0){T=!0;const D=P.getAppliedImpulse(),M=P.get_m_positionWorldOnB(),O=P.get_m_normalWorldOnB();if(m||p){const N=[l.uuid,d.uuid].sort(),j=`${N[0]}__${N[1]}`;if(this.earlierDetectedCollisions.find(H=>H.combinedName===j)&&(R="collision"),!e.find(H=>H.combinedName===j)){e.push({combinedName:j,collision:!0});const H={x:M.x(),y:M.y(),z:M.z()},$={x:O.x(),y:O.y(),z:O.z()};l.body.impact.push({impulse:D,point:H,normal:$,name:d.name}),d.body.impact.push({impulse:D,point:H,normal:$,name:l.name}),this.collisionEvents.emit("collision",{bodies:[l,d],event:R})}}D>=E&&(E=D,(g||b)&&(this.impactPoint.set(M.x(),M.y(),M.z()),this.impactNormal.set(O.x(),O.y(),O.z())));break}}if(!T||!A)continue;const V=2;if(this.emptyV3.set(0,0,0),l.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:g,physicsBody:c},d.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:b,physicsBody:h},g&&E>y&&l.fragmentDepth<V){const L=this.convexBreaker.subdivideByImpact(l,this.impactPoint,this.impactNormal,1,2),P=L.length;for(let I=0;I<P;I++){const D=c.getLinearVelocity(),M=c.getAngularVelocity(),O=L[I];O.userData.ammoPhysicsData.velocity.set(D.x(),D.y(),D.z()),O.userData.ammoPhysicsData.angularVelocity.set(M.x(),M.y(),M.z()),this.createDebrisFromBreakableObject(O,l)}this.objectsToRemove[this.numObjectsToRemove++]=l}if(b&&E>w&&d.fragmentDepth<V){const L=this.convexBreaker.subdivideByImpact(d,this.impactPoint,this.impactNormal,1,2),P=L.length;for(let I=0;I<P;I++){const D=h.getLinearVelocity(),M=h.getAngularVelocity(),O=L[I];O.userData.ammoPhysicsData.velocity.set(D.x(),D.y(),D.z()),O.userData.ammoPhysicsData.angularVelocity.set(M.x(),M.y(),M.z()),this.createDebrisFromBreakableObject(O,d)}this.objectsToRemove[this.numObjectsToRemove++]=d}}for(let o=0;o<this.numObjectsToRemove;o++)this.removeDebris(this.objectsToRemove[o]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(o=>{const{combinedName:a}=o;if(!e.find(r=>r.combinedName===a)){const r=a.split("__"),c=this.rigidBodies.find(d=>d.uuid===r[0]),h=this.rigidBodies.find(d=>d.uuid===r[1]),l="end";c&&h&&this.collisionEvents.emit("collision",{bodies:[c,h],event:l})}}),this.earlierDetectedCollisions=[...e]}setGravity(e=0,t=-9.8,s=0){this.tmpBtVector3.setValue(e,t,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(e=1)=>{this.debugDrawer.setDebugMode(e)},disable:()=>{this.debugDrawer.disable()}}}start(){if(typeof Ammo>"u"){we("Are you sure you included ammo.js?");return}typeof Ammo=="function"?Ammo().then(()=>{this.setup()}):this.setup()}get add(){return{collider:(e,t,s)=>this.collisionEvents.addCollider(e,t,s),constraints:this.constraints.addConstraints,existing:(e,t)=>this.addExisting(e,t),plane:(e={},t={})=>this.shapes.addPlane(e,t),sphere:(e={},t={})=>this.shapes.addSphere(e,t),ground:(e={},t={})=>this.shapes.addGround(e,t),box:(e={},t={})=>this.shapes.addBox(e,t),cylinder:(e={},t={})=>this.shapes.addCylinder(e,t),cone:(e={},t={})=>this.shapes.addCone(e,t),torus:(e={},t={})=>this.shapes.addTorus(e,t),extrude:(e,t={})=>this.shapes.addExtrude(e,t),raycaster:(e="closest")=>e==="closest"?new zs(this):new Hs(this)}}prepareThreeObjectForCollisionShape(e,t={}){var r,c;const{autoCenter:s=!1}=t,n={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let i="unknown";const o=((r=e.geometry)==null?void 0:r.type)||"unknown";/box/i.test(o)?i="box":/cone/i.test(o)?i="cone":/cylinder/i.test(o)?i="cylinder":/extrude/i.test(o)?i="extrude":/plane/i.test(o)?i="plane":/sphere/i.test(o)?i="sphere":/torus/i.test(o)&&(i="torus");let a={...n,...(c=e==null?void 0:e.geometry)==null?void 0:c.parameters};return t.shape?(a={...n,...t},i=t.shape):e.shape&&(i=e.shape),Object.keys(a).forEach(h=>{typeof a[h]>"u"&&n[h]&&(a[h]=n[h])}),s&&e.geometry.center(),i==="cylinder"&&(a.radius=t.radius||a.radiusTop),i==="extrude"&&(i="hacd"),(i==="mesh"||i==="convex")&&(i="convexMesh"),i==="concave"&&(i="concaveMesh"),i==="unknown"&&(we(`Shape for ${e==null?void 0:e.name} not recognized! Will fallback to box.`),i="box"),{shape:i,params:a,object:e}}createCollisionShape(e,t,s){const n=s!=null&&s.quaternion?s==null?void 0:s.quaternion:new W(0,0,0,1),{axis:i="y"}=t,o=new Ammo.btVector3,a=s==null?void 0:s.geometry;s&&(a==null?void 0:a.isGeometry)&&(s.geometry=new ce().fromGeometry(a));const r=p=>{const g=new ee().elements,b=[],y=[],w=[];return Ws(p,{},(S,A,T)=>{b.push(S),y.push(A),w.push(T)}),{vertices:b,matrices:y,indexes:w,matrixWorld:g}};let c={};this.complexShapes.indexOf(e)!==-1&&(c=r(s));let h;switch(e){case"box":o.setValue(t.width/2,t.height/2,t.depth/2),h=new Ammo.btBoxShape(o);break;case"sphere":h=new Ammo.btSphereShape(t.radius);break;case"cylinder":switch(i){case"y":o.setValue(t.radius,t.height/2,t.radius),h=new Ammo.btCylinderShape(o);break;case"x":o.setValue(t.height/2,t.radius,t.radius),h=new Ammo.btCylinderShapeX(o);break;case"z":o.setValue(t.radius,t.radius,t.height/2),h=new Ammo.btCylinderShapeZ(o);break}break;case"cone":switch(i){case"y":h=new Ammo.btConeShape(t.radius,t.height);break;case"x":h=new Ammo.btConeShapeX(t.radius,t.height);break;case"z":h=new Ammo.btConeShapeZ(t.radius,t.height);break}break;case"capsule":switch(i){case"y":h=new Ammo.btCapsuleShape(t.radius,t.height);break;case"x":h=new Ammo.btCapsuleShapeX(t.radius,t.height);break;case"z":h=new Ammo.btCapsuleShapeZ(t.radius,t.height);break}break;case"torus":h=kn(t,n);break;case"plane":h=Me(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...t,concave:!1});break;case"hull":h=Ks(c.vertices,c.matrices,c.matrixWorld,t);break;case"hacd":h=Gs(c.vertices,c.matrices,c.indexes,c.matrixWorld,t);break;case"vhacd":h=js(c.vertices,c.matrices,c.indexes,c.matrixWorld,t);break;case"convexMesh":h=Me(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...t,concave:!1});break;case"concaveMesh":h=Me(c.vertices,c.matrices,c.indexes,c.matrixWorld,{...t,concave:!0});break}Ammo.destroy(o);const{x:l,y:d,z:m}=t;return(l||d||m)&&(h._compoundOffset={x:l||0,y:d||0,z:m||0}),Array.isArray(h)&&(h=this.mergeCollisionShapesToCompoundShape(h)),h}mergeCollisionShapesToCompoundShape(e){const t=new Ammo.btCompoundShape;return e.forEach(s=>{const{_childOffset:n,_compoundOffset:i}=s;if(n){const{pos:o,quat:a,scale:r,margin:c}=n,h=this.applyPosQuatScaleMargin(s,o,a,r,c);t.addChildShape(h,s)}else if(i){const o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),t.addChildShape(o,s)}else{const o=new Ammo.btTransform;o.setIdentity(),t.addChildShape(o,s)}}),t}addExisting(e,t={}){const{hasBody:s}=e;if(s){we(`Object "${e.name}" already has a physical body!`);return}const n=new C,i=new W,o=new C;e.getWorldPosition(n),e.getWorldQuaternion(i),e.getWorldScale(o);const a=(t.collisionFlags||0).toString(2).slice(-1)==="1",r=(t.collisionFlags||0).toString(2).slice(-2,-1)==="1",{shape:c="unknown",compound:h=[],mass:l=a||r?0:1,collisionFlags:d=0,collisionGroup:m=1,collisionMask:p=-1,offset:g=void 0,breakable:b=!1,addChildren:y=!0,margin:w=.01,ignoreScale:S=!1,fractureImpulse:A=1}=t;if(S&&o.set(1,1,1),h.length>=1){const L=h.map(M=>this.createCollisionShape(M.shape,M)),P=this.mergeCollisionShapesToCompoundShape(L),I=this.applyPosQuatScaleMargin(P,n,i,o,w),D=this.collisionShapeToRigidBody(P,I,l,r);this.addRigidBodyToWorld(e,D,d,m,p,g),e.body.breakable=b,e.body.fractureImpulse=A,e.body.ignoreScale=S;return}const T=[];if(c!=="unknown"||e.isMesh){const L=this.prepareThreeObjectForCollisionShape(e,t),P=this.createCollisionShape(L.shape,L.params,L.object);T.push(P)}if(c==="unknown"&&y&&e.children.length>=1&&e.children.forEach(L=>{if(L.isMesh){const P=this.prepareThreeObjectForCollisionShape(L),I=this.createCollisionShape(P.shape,P.params,P.object);I._childOffset={pos:L.position.clone(),quat:L.quaternion.clone(),scale:L.scale.clone(),margin:w},T.push(I)}}),T.length===0){const L=this.prepareThreeObjectForCollisionShape(e,t),P=this.createCollisionShape(L.shape,L.params,L.object);T.push(P)}const E=T.length===1?T[0]:this.mergeCollisionShapesToCompoundShape(T),R=this.applyPosQuatScaleMargin(E,n,i,o,w),V=this.collisionShapeToRigidBody(E,R,l,r);this.addRigidBodyToWorld(e,V,d,m,p,g),e.body.breakable=b,e.body.fractureImpulse=A,e.body.ignoreScale=S}addRigidBodyToWorld(e,t,s,n,i,o){this.rigidBodies.push(e),this.physicsWorld.addRigidBody(t,n,i);const a=Object.values(t)[0];e.name||(e.name=`object-${e.id}`),t.name=e.name,e.body=new On(this,t),e.hasBody=!0,e.ptr=a,t.threeObject=e,o&&(e.body.offset={x:0,y:0,z:0,...o}),e.body.setCollisionFlags(s)}applyPosQuatScaleMargin(e,t=new C,s=new W,n=new C,i=.01){e.setMargin(i);const o=new Ammo.btQuaternion(0,0,0,1);o.setValue(s.x,s.y,s.z,s.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(t.x,t.y,t.z),a.setRotation(o),Ammo.destroy(o);const r=new Ammo.btVector3(n.x,n.y,n.z);return e.setLocalScaling(r),Ammo.destroy(r),a}collisionShapeToRigidBody(e,t,s,n){const i=new Ammo.btDefaultMotionState(t),o=new Ammo.btVector3(0,0,0);s>0&&e.calculateLocalInertia(s,o);const a=new Ammo.btRigidBodyConstructionInfo(s,i,e,o),r=new Ammo.btRigidBody(a);return(s>0||n)&&r.setActivationState(4),r}}const Un={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class Ae{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const zn=new Mt(-1,1,1,-1,0,1),ve=new ce;ve.setAttribute("position",new q([-1,3,0,-1,-1,0,3,-1,0],3));ve.setAttribute("uv",new q([0,2,0,0,2,0],2));class Hn{constructor(e){this._mesh=new pe(ve,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,zn)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class jn extends Ae{constructor(e,t){super(),this.textureID=t!==void 0?t:"tDiffuse",e instanceof tt?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=Is.clone(e.uniforms),this.material=new tt({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new Hn(this.material)}render(e,t,s){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=s.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class dt extends Ae{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,s){const n=e.getContext(),i=e.state;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0);let o,a;this.inverse?(o=0,a=1):(o=1,a=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),i.buffers.stencil.setFunc(n.ALWAYS,o,4294967295),i.buffers.stencil.setClear(a),i.buffers.stencil.setLocked(!0),e.setRenderTarget(s),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),i.buffers.color.setLocked(!1),i.buffers.depth.setLocked(!1),i.buffers.stencil.setLocked(!1),i.buffers.stencil.setFunc(n.EQUAL,1,4294967295),i.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),i.buffers.stencil.setLocked(!0)}}class Gn extends Ae{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class Kn{constructor(e,t){if(this.renderer=e,t===void 0){const s=e.getSize(new B);this._pixelRatio=e.getPixelRatio(),this._width=s.width,this._height=s.height,t=new Vs(this._width*this._pixelRatio,this._height*this._pixelRatio),t.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new jn(Un),this.clock=new Ot}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);t!==-1&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){e===void 0&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let s=!1;for(let n=0,i=this.passes.length;n<i;n++){const o=this.passes[n];if(o.enabled!==!1){if(o.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(n),o.render(this.renderer,this.writeBuffer,this.readBuffer,e,s),o.needsSwap){if(s){const a=this.renderer.getContext(),r=this.renderer.state.buffers.stencil;r.setFunc(a.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),r.setFunc(a.EQUAL,1,4294967295)}this.swapBuffers()}dt!==void 0&&(o instanceof dt?s=!0:o instanceof Gn&&(s=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(e===void 0){const t=this.renderer.getSize(new B);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,e=this.renderTarget1.clone(),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(s,n),this.renderTarget2.setSize(s,n);for(let i=0;i<this.passes.length;i++)this.passes[i].setSize(s,n)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class Wn extends Ae{constructor(e,t,s,n,i){super(),this.scene=e,this.camera=t,this.overrideMaterial=s,this.clearColor=n,this.clearAlpha=i!==void 0?i:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new X}render(e,t,s){const n=e.autoClear;e.autoClear=!1;let i,o;this.overrideMaterial!==void 0&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),i=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:s),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,i),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=o),e.autoClear=n}}const Xn=/^[og]\s*(.+)?/,Yn=/^mtllib /,qn=/^usemtl /,Qn=/^usemap /,ut=/\s+/,mt=new C,Pe=new C,ft=new C,pt=new C,F=new C,ye=new X;function Zn(){const f={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,i){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const a={index:this.materials.length,name:n||"",mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(r){const c={index:typeof r=="number"?r:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),n&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}},s&&s.name&&typeof s.clone=="function"){const n=s.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseNormalIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseUVIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/2)*2},addVertex:function(e,t,s){const n=this.vertices,i=this.object.geometry.vertices;i.push(n[e+0],n[e+1],n[e+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[s+0],n[s+1],n[s+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,s){const n=this.normals,i=this.object.geometry.normals;i.push(n[e+0],n[e+1],n[e+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[s+0],n[s+1],n[s+2])},addFaceNormal:function(e,t,s){const n=this.vertices,i=this.object.geometry.normals;mt.fromArray(n,e),Pe.fromArray(n,t),ft.fromArray(n,s),F.subVectors(ft,Pe),pt.subVectors(mt,Pe),F.cross(pt),F.normalize(),i.push(F.x,F.y,F.z),i.push(F.x,F.y,F.z),i.push(F.x,F.y,F.z)},addColor:function(e,t,s){const n=this.colors,i=this.object.geometry.colors;n[e]!==void 0&&i.push(n[e+0],n[e+1],n[e+2]),n[t]!==void 0&&i.push(n[t+0],n[t+1],n[t+2]),n[s]!==void 0&&i.push(n[s+0],n[s+1],n[s+2])},addUV:function(e,t,s){const n=this.uvs,i=this.object.geometry.uvs;i.push(n[e+0],n[e+1]),i.push(n[t+0],n[t+1]),i.push(n[s+0],n[s+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,s,n,i,o,a,r,c){const h=this.vertices.length;let l=this.parseVertexIndex(e,h),d=this.parseVertexIndex(t,h),m=this.parseVertexIndex(s,h);if(this.addVertex(l,d,m),this.addColor(l,d,m),a!==void 0&&a!==""){const p=this.normals.length;l=this.parseNormalIndex(a,p),d=this.parseNormalIndex(r,p),m=this.parseNormalIndex(c,p),this.addNormal(l,d,m)}else this.addFaceNormal(l,d,m);if(n!==void 0&&n!==""){const p=this.uvs.length;l=this.parseUVIndex(n,p),d=this.parseUVIndex(i,p),m=this.parseUVIndex(o,p),this.addUV(l,d,m),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let s=0,n=e.length;s<n;s++){const i=this.parseVertexIndex(e[s],t);this.addVertexPoint(i),this.addColor(i)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const s=this.vertices.length,n=this.uvs.length;for(let i=0,o=e.length;i<o;i++)this.addVertexLine(this.parseVertexIndex(e[i],s));for(let i=0,o=t.length;i<o;i++)this.addUVLine(this.parseUVIndex(t[i],n))}};return f.startObject("",!1),f}class $n extends gt{constructor(e){super(e),this.materials=null}load(e,t,s,n){const i=this,o=new Ve(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(i.parse(a))}catch(r){n?n(r):console.error(r),i.manager.itemError(e)}},s,n)}setMaterials(e){return this.materials=e,this}parse(e){const t=new Zn;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const s=e.split(`
`);let n=[];for(let a=0,r=s.length;a<r;a++){const c=s[a].trimStart();if(c.length===0)continue;const h=c.charAt(0);if(h!=="#")if(h==="v"){const l=c.split(ut);switch(l[0]){case"v":t.vertices.push(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3])),l.length>=7?(ye.setRGB(parseFloat(l[4]),parseFloat(l[5]),parseFloat(l[6])).convertSRGBToLinear(),t.colors.push(ye.r,ye.g,ye.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3]));break;case"vt":t.uvs.push(parseFloat(l[1]),parseFloat(l[2]));break}}else if(h==="f"){const d=c.slice(1).trim().split(ut),m=[];for(let g=0,b=d.length;g<b;g++){const y=d[g];if(y.length>0){const w=y.split("/");m.push(w)}}const p=m[0];for(let g=1,b=m.length-1;g<b;g++){const y=m[g],w=m[g+1];t.addFace(p[0],y[0],w[0],p[1],y[1],w[1],p[2],y[2],w[2])}}else if(h==="l"){const l=c.substring(1).trim().split(" ");let d=[];const m=[];if(c.indexOf("/")===-1)d=l;else for(let p=0,g=l.length;p<g;p++){const b=l[p].split("/");b[0]!==""&&d.push(b[0]),b[1]!==""&&m.push(b[1])}t.addLineGeometry(d,m)}else if(h==="p"){const d=c.slice(1).trim().split(" ");t.addPointGeometry(d)}else if((n=Xn.exec(c))!==null){const l=(" "+n[0].slice(1).trim()).slice(1);t.startObject(l)}else if(qn.test(c))t.object.startMaterial(c.substring(7).trim(),t.materialLibraries);else if(Yn.test(c))t.materialLibraries.push(c.substring(7).trim());else if(Qn.test(c))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(h==="s"){if(n=c.split(" "),n.length>1){const d=n[1].trim().toLowerCase();t.object.smooth=d!=="0"&&d!=="off"}else t.object.smooth=!0;const l=t.object.currentMaterial();l&&(l.smooth=t.object.smooth)}else{if(c==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+c+'"')}}t.finalize();const i=new be;if(i.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let a=0,r=t.objects.length;a<r;a++){const c=t.objects[a],h=c.geometry,l=c.materials,d=h.type==="Line",m=h.type==="Points";let p=!1;if(h.vertices.length===0)continue;const g=new ce;g.setAttribute("position",new q(h.vertices,3)),h.normals.length>0&&g.setAttribute("normal",new q(h.normals,3)),h.colors.length>0&&(p=!0,g.setAttribute("color",new q(h.colors,3))),h.hasUVIndices===!0&&g.setAttribute("uv",new q(h.uvs,2));const b=[];for(let w=0,S=l.length;w<S;w++){const A=l[w],T=A.name+"_"+A.smooth+"_"+p;let E=t.materials[T];if(this.materials!==null){if(E=this.materials.create(A.name),d&&E&&!(E instanceof re)){const R=new re;ue.prototype.copy.call(R,E),R.color.copy(E.color),E=R}else if(m&&E&&!(E instanceof oe)){const R=new oe({size:10,sizeAttenuation:!1});ue.prototype.copy.call(R,E),R.color.copy(E.color),R.map=E.map,E=R}}E===void 0&&(d?E=new re:m?E=new oe({size:1,sizeAttenuation:!1}):E=new Pt,E.name=A.name,E.flatShading=!A.smooth,E.vertexColors=p,t.materials[T]=E),b.push(E)}let y;if(b.length>1){for(let w=0,S=l.length;w<S;w++){const A=l[w];g.addGroup(A.groupStart,A.groupCount,w)}d?y=new Te(g,b):m?y=new me(g,b):y=new pe(g,b)}else d?y=new Te(g,b[0]):m?y=new me(g,b[0]):y=new pe(g,b[0]);y.name=c.name,i.add(y)}else if(t.vertices.length>0){const a=new oe({size:1,sizeAttenuation:!1}),r=new ce;r.setAttribute("position",new q(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(r.setAttribute("color",new q(t.colors,3)),a.vertexColors=!0);const c=new me(r,a);i.add(c)}return i}}const Jn={props:{modelValue:{type:[Object,Function],default:()=>({})}},data(){return{}},methods:{init(){Bn("/assets/ammo",()=>{var c,h;console.clear();const f=l=>{this.$emit("update:modelValue",l),this.$parent.$forceUpdate()},e=()=>({width:this.$el.offsetWidth,height:this.$el.offsetHeight});let t={loaded:0,options:{},preload:()=>({}),onProgress:()=>{},onCreate:()=>{},onUpdate:()=>{},...this.modelValue,input:{}};t.options={fps:60,debug:!1,gridHelper:!1,orbitControls:!1,...t.options};const{width:s,height:n}=e();t.canvas={wrapper:this.$el,width:s,height:n},t.scene=new ks,t.camera=new St(50,s/n,1,1e3),t.clock=new Ot,t.scene.add(t.light=new yt(16777215,2)),t.renderer=(()=>{const{width:l,height:d}=e(),m=new vs;return m.setSize(l,d),this.$el.appendChild(m.domElement),m.domElement.style.width="100%",m.domElement.style.height="100%",m})(),t.effectComposer=new Kn(t.renderer),t.effectComposer.addPass(new Wn(t.scene,t.camera)),t.physics=new Fn(t.scene),t.options.debug&&((c=t.physics.debug)==null||c.enable(),(h=t.physics.debug)==null||h.mode(2048+4096)),t.options.gridHelper&&t.scene.add(t.gridHelper=new Ns(10,10)),t.orbitControls=(()=>t.options.orbitControls?(t.camera.position.set(5,5,5),new Dn(t.camera,t.renderer.domElement)):!1)(),t.getData=function(){return this};const i=()=>{const{width:l,height:d}=e();t.canvas.width=l,t.canvas.height=d,t.renderer.setSize(l,d),t.camera.aspect=l/d,t.camera.updateProjectionMatrix(),f(t)},o=l=>{l.type=="keydown"?(t.input[l.key]=!0,t.input[l.code]=!0,t.input[l.keyCode]=!0):(t.input[l.key]=!1,t.input[l.code]=!1,t.input[l.keyCode]=!1),f(t)},a=()=>{t.onUpdate(),t.scene.traverse(l=>{const d=l.onUpdate||l.userData.onUpdate||!1;typeof d=="function"&&d.call(l)}),t.physics.update(t.clock.getDelta()*1e3),t.renderer.render(t.scene,t.camera),t.orbitControls&&t.orbitControls.update(),t.options.debug&&t.physics.updateDebugger(),t.effectComposer.render(),f(t)},r=()=>{t.onCreate(),t.scene.traverse(d=>{const m=d.onCreate||d.userData.onCreate||!1;typeof m=="function"&&m.call(d)});const l=setInterval(a,1e3/t.options.fps);window.addEventListener("resize",i),window.addEventListener("keyup",o),window.addEventListener("keydown",o),this.onBeforeUnmount=()=>{window.removeEventListener("resize",i),window.removeEventListener("keyup",i),window.removeEventListener("keydown",i),clearInterval(l)}};(()=>{if(f(t),Object.keys(t.preload()).length==0)return t.loaded=1,r();const l=Object.assign(new Bs,{onStart:(d,m,p)=>{},onProgress:(d,m,p)=>{const g=m/p;t.loaded=g,f(t),t.onProgress({percent:g,url:d,itemsLoaded:m,itemsTotal:p})},onError:d=>{},onLoad:()=>{t.loaded=1,r()}});for(let[d,m]of Object.entries(t.preload()))m={type:!1,url:"",onLoad:p=>p,...m,loader:!1},m.type=="obj"?(m.loader=new $n(l),m.loader.load(m.url,p=>{m.onLoad(p),t[d]=p,f(t)})):m.type=="gltf"?(m.loader=new Zs(l),m.loader.load(m.url,p=>{p=p.scene.children[0],m.onLoad(p),t[d]=p,f(t)})):m.type=="texture"&&(m.loader=new wt(l),m.loader.load(m.url,p=>{m.onLoad(p),t[d]=p,f(t)}))})()})},onAnimate:()=>({}),onBeforeUnmount:()=>({})},mounted(){this.init()},beforeUnmount(){this.onBeforeUnmount()}},ei={style:{position:"relative",width:"100%",height:"600px"}};function ti(f,e,t,s,n,i){return Ys(),qs("div",ei,[Qs(f.$slots,"default",{game:t.modelValue})])}const oi=Xs(Jn,[["render",ti]]);export{oi as default};
